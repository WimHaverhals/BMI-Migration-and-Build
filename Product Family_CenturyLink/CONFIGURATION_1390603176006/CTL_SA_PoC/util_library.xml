<?xml version="1.0" encoding="UTF-8"?><bm_lib_func_zip_deploy><id>4180575</id><container_id>4133367</container_id><func_type>1</func_type><data>[B@71e1ed18</data><_children><bm_lib_func><id>724789197</id><name><en><![CDATA[Temp No Special Characters]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[ctlNoSpecialCharacters]]></variable_name><description><en><![CDATA[This util will take the value in your attribute you pass it, and output true if all characters in the string attr is either a alpha, numeric, or a space. It will pass a false if any special characters. It was written for DE228.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>724789196</function_id><main_script_text></main_script_text><date_modified>1386360776000</date_modified><guid><![CDATA[sbcenturylink_724789197]]></guid><_children><bm_function><id>724789196</id><ref_type>16</ref_type><script_text><![CDATA[//*****************************************************************************************************
//** Function:    No special characters (ctlnospecialcharacters)                                              
//** Type:        Util                                                                 
//**                                                                                                 
//** Description: It will go through your attribute to verify that only Alpha, Numeric or spaces are entered 
//**                 
//** Parameters:  attribute: The attribute you want checked
//**                                                                                            
//** History:     Date     Author     Comment                                                        
//**              12/6/13 BBarnhart   This was written for DE228
//*****************************************************************************************************
retVal = false;
charArr = split(attribute,"");
remove (charArr, 0);
   
for char in charArr{
          if((char >= "a" AND char <= "Z") OR isnumber(char) OR  char == " ") {
			retVal = true;
	}
	  else{
	    retVal = false;
		break;
     }
}     
return retVal;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_ctlNoSpecialCharacters_724789196]]></java_class_name><child_class_names></child_class_names><date_modified>1386360776000</date_modified><guid><![CDATA[sbcenturylink_724789196]]></guid><_children></_children></bm_function><bm_lib_func_param><id>724789199</id><bm_lib_func_id>724789197</bm_lib_func_id><param_name><![CDATA[attribute]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1386360776000</date_modified><order_no>1</order_no><guid><![CDATA[sbcenturylink_724789199]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>191391250</id><name><en><![CDATA[Populate Dict For Array]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[populateDictForArray]]></variable_name><description><en><![CDATA[Based on templateID either inserts isDeletable array or action array in the input dictionary addonVsAddonDataDict and return the same dictionary]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>18</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>191391249</function_id><main_script_text></main_script_text><date_modified>1358564314000</date_modified><guid><![CDATA[testsavvis_161400319]]></guid><_children><bm_function><id>191391249</id><ref_type>16</ref_type><script_text><![CDATA[//*********************************************************************************************************************
//** Function:    Populate Dict For Array (populateDictForArray)                                         	     **
//** Type:        Utility Library Function                                                                    	     **
//**                                                                                                          	     **
//** Description: Based on templateID either inserts isDeletable array or action array in the input dictionary       **
//**		  addonVsAddonDataDict and returns the same dictionary                 	    		             **
//**                                                                                                                 **
//** Parameters:  templateID - special offer id, has a value if the addon is imported from a special offer           **
//**              addon - name of the addon for which the function is called   					     **
//**              addonsSelectedArray - array of all the selected addons                                             **
//**              isDeletableArray - isDeletable array attribute   						     **
//**              actionArray - action array attribute								     **
//**              addonVsAddonDataDict - dictionary with key as addon name and value of isDeletable array attribute  **
//**                                     or action array attribute and addonArray                                    **
//**                                                                                                                 **
//** Return Type: string[] Dictionary - returns dictionary addonVsAddonDataDict with updated information             **
//**                                                                                                                 **
//** History:     Date     Author       Comment                                                                      **
//**              09/07/12 SKharche     New implementation to support Special Offer Is Deletable and Change scenario **
//**                                    Supports VER 62770                                                           **
//*********************************************************************************************************************

//If the input addon is not selected then if the templateID is NOT blank add the isDeletable array 
//else add action array to the return dictionary

if(findinarray(addonsSelectedArray, addon) == -1) {
	//Check to see if addon already exists in the addon array in the dictionary, if yes then append the addon to that addon array
	//else append addon to empty array and add it to the dictionary
	addonArray = string[];
	if(containskey(addonVsAddonDataDict, "addonArray")) {
		addonArray = get(addonVsAddonDataDict, "addonArray");
	}
	append(addonArray, addon);
	put(addonVsAddonDataDict, "addonArray", addonArray);
	
	if(templateID <> "") {
		put(addonVsAddonDataDict, addon, isDeletableArray);
	}
	else {
		put(addonVsAddonDataDict, addon, actionArray);
	}
}

return addonVsAddonDataDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_populateDictForArray_191391249]]></java_class_name><child_class_names></child_class_names><date_modified>1358564314000</date_modified><guid><![CDATA[testsavvis_161400318]]></guid><_children></_children></bm_function><bm_lib_func_param><id>191391251</id><bm_lib_func_id>191391250</bm_lib_func_id><param_name><![CDATA[templateID]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564314000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_161400321]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391252</id><bm_lib_func_id>191391250</bm_lib_func_id><param_name><![CDATA[addon]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564314000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_161400322]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391253</id><bm_lib_func_id>191391250</bm_lib_func_id><param_name><![CDATA[addonsSelectedArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564314000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_161400323]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391254</id><bm_lib_func_id>191391250</bm_lib_func_id><param_name><![CDATA[isDeletableArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564314000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_161400324]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391255</id><bm_lib_func_id>191391250</bm_lib_func_id><param_name><![CDATA[actionArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564314000</date_modified><order_no>5</order_no><guid><![CDATA[testsavvis_161400325]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391256</id><bm_lib_func_id>191391250</bm_lib_func_id><param_name><![CDATA[addonVsAddonDataDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1358564314000</date_modified><order_no>6</order_no><guid><![CDATA[testsavvis_161412340]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>166332670</id><name><en><![CDATA[Currency Conversion]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[currencyConversion]]></variable_name><description><en><![CDATA[VER 63746 - Takes in a currency amount in one currency, and converts it into the amount of the second given currency.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>2</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>166332669</function_id><main_script_text></main_script_text><date_modified>1358564318000</date_modified><guid><![CDATA[testsavvis_147357408]]></guid><_children><bm_function><id>166332669</id><ref_type>16</ref_type><script_text><![CDATA[if(inputCurrency == outputCurrency){
	return amount;
}
else {
	exchangeRate = 1.0;
	currencyRecords = bmql("SELECT ExchangeRate FROM SpotCurrencyRate WHERE SourceCurrency = $inputCurrency AND TargetCurrency = $outputCurrency");
	for  record in currencyRecords {
		exchangeRate = getfloat(record, "ExchangeRate");
	}
	return amount * exchangeRate;
}]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_currencyConversion_166332669]]></java_class_name><child_class_names></child_class_names><date_modified>1358564318000</date_modified><guid><![CDATA[testsavvis_147357407]]></guid><_children></_children></bm_function><bm_lib_func_param><id>166332671</id><bm_lib_func_id>166332670</bm_lib_func_id><param_name><![CDATA[amount]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>4</datatype><date_modified>1358564318000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_147357410]]></guid></bm_lib_func_param><bm_lib_func_param><id>166332672</id><bm_lib_func_id>166332670</bm_lib_func_id><param_name><![CDATA[inputCurrency]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_147357411]]></guid></bm_lib_func_param><bm_lib_func_param><id>166332673</id><bm_lib_func_id>166332670</bm_lib_func_id><param_name><![CDATA[outputCurrency]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_147357412]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>224741302</id><name><en><![CDATA[Concat String If Fits]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[concatStringIfFits]]></variable_name><description><en><![CDATA[Concatenate two strings if the result string has a length less than 255 characters]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>224741301</function_id><main_script_text></main_script_text><date_modified>1358564311000</date_modified><guid><![CDATA[testsavvis_182605098]]></guid><_children><bm_function><id>224741301</id><ref_type>16</ref_type><script_text><![CDATA[//*********************************************************************************************************************
//** Function:    Concat String If Fits (concatStringIfFits)                  
//** Type:        Utility Library Function                                                                           
//**                                                                                                                 
//** Description: Concatenate two strings if the result string has a length less than 255 characters
//**                                                                                                                 
//** Parameters:  baseString - base string in which new string wil be added                                     
//**              newString  - new string to be added to the base string
//**                                                                                                                 
//** Return Type: string                                      
//**                                                                                                                 
//** History:     Date     Author       Comment                                                                      
//**              10/30/12 SKharche     VER 65151 - Change Pre Validation attribute from text to text area
//**                                                In V12.2 the attribute will be changed to text area, for now 
//**                                                the fix it is to present the error message in chunks
//*********************************************************************************************************************

concatenatedString = baseString + newString;
if(len(concatenatedString) <= 255) {
    return concatenatedString;
}

return baseString;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_concatStringIfFits_224741301]]></java_class_name><child_class_names></child_class_names><date_modified>1358564311000</date_modified><guid><![CDATA[testsavvis_182605097]]></guid><_children></_children></bm_function><bm_lib_func_param><id>224741303</id><bm_lib_func_id>224741302</bm_lib_func_id><param_name><![CDATA[baseString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564311000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_182605100]]></guid></bm_lib_func_param><bm_lib_func_param><id>224741304</id><bm_lib_func_id>224741302</bm_lib_func_id><param_name><![CDATA[newString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564311000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_182605101]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>392706749</id><name><en><![CDATA[Encode Name Value Pair]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[encodeNameValuePair]]></variable_name><description><en><![CDATA[VER 66539: Encodes Two String Arrays (one for names, one for values) into a set of name-value pairs and returns a delimited string.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>392706748</function_id><main_script_text></main_script_text><date_modified>1371905635000</date_modified><guid><![CDATA[testsavvis_283732307]]></guid><_children><bm_function><id>392706748</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Encode Name Value Pair(encodeNameValuePair)
//** Type:        Utility Library Function   
//**
//** Description: Encodes Two String Arrays (one for names, one for values) into a set of name-value pairs.
//**              Those pairs will be used in the CRMExtraInfo Section in getRecommendedItemsReturnString2
//** 
//** Param:       namesArray         - String array containing the names for the name-value pairs
//**              valuesArray        - String Array containing the values for the name-value pairs
//**              nameValueDelimiter - delimiter between name and value
//**              pairDelimiter      - delimiter between multiple nameValuePairs
//**
//** Return type: String - Delimited string of name-value pairs
//**              String Format is: name1'nameValueDelimiter'value1'pairDelimiter'name2'nameValueDelimiter'value2
//**                                NOTE: the keywords 'nameValueDelimiter' and 'pairDelimiter' are replaced by actual delimiters
//**
//** History:     Date     Author       Comment 
//**              03/25/13 Skharche    VER 66539 - CTL Code Reconciliation 
//**              05/20/13 SKharche    BIGMACH-2001 - CTL code reconciliation. Fixed a bug.   
//************************************************************************************************************

nameValDelim = nameValueDelimiter;
pairDelim    = pairDelimiter;
retVal       = "";

index = 0;

// If the delimiters are blank then use default delimiters
if(nameValDelim == "") { nameValDelim = "="; } 
if(pairDelim == "") { pairDelim = "^"; }

for name in namesArray{
    if(NOT isnull(valuesArray[index]) AND valuesArray[index] <> ""){
        // BIGMACH-2001 - retVal should be complete list
        retVal = retVal + name + nameValDelim + valuesArray[index] + pairDelim;
    }
    index = index + 1;
}
if(retVal <> ""){
    retVal = substring(retVal, 0, len(retVal) - len(pairDelim));
}

return retVal;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_encodeNameValuePair_392706748]]></java_class_name><child_class_names></child_class_names><date_modified>1371905635000</date_modified><guid><![CDATA[testsavvis_283732306]]></guid><_children></_children></bm_function><bm_lib_func_param><id>392706750</id><bm_lib_func_id>392706749</bm_lib_func_id><param_name><![CDATA[namesArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1371905635000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_283732309]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706751</id><bm_lib_func_id>392706749</bm_lib_func_id><param_name><![CDATA[valuesArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1371905635000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_283732310]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706752</id><bm_lib_func_id>392706749</bm_lib_func_id><param_name><![CDATA[nameValueDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905635000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_283732311]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706753</id><bm_lib_func_id>392706749</bm_lib_func_id><param_name><![CDATA[pairDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905635000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_283732312]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>263833281</id><name><en><![CDATA[Set Address Array Elements]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[setAddressArrayElements]]></variable_name><description><en><![CDATA[Returns the array for address array attributes for an array addon]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>263833280</function_id><main_script_text></main_script_text><date_modified>1358564310000</date_modified><guid><![CDATA[sbsavvis_199808854]]></guid><_children><bm_function><id>263833280</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Set Address Array Elements (setAddressArrayElements)                       
//** Type:        Utility Library Function                                                                   
//**                                                                                                          
//** Description: Returns string array, for address array attributes of an array addon.
//**              For array addons, if the addon is supporting networkZAddress then 4 attributes are created per 
//**              array - xxNetworkZAddress, xxNetworkZAddressTech, xxNetworkZAddressCountry, xxNetworkZAddressName.
//**              xx is the array prefix. This function is used to set these attributes.             
//**       
//** Parameters:  encodedAddressData            - encoded address data attribute that contains a delimited string 
//**                                              with the below format
//**                                              address!$!addressTech$!$!addressCountry!$!addressName
//**              addressElement                - name of the element user wants to pull from encodedAddressData 
//**                                              eg: user wants to get addressTech from the encodedAddressData then
//**                                                  addressElement will have value addressTech  
//**              addressIndexAttributeArray    - address index attribute (place where user enters the address index)
//**              addressElementAttributeArray  - array attribute that needs to be populated (eg: xxNetworkZAddress)
//**                                              this parameter is the actual array that needs to be overwritten                      
//**
//** Return type: string[]
//**                                                                                                    
//** History:     Date     Author       Comment                                                               
//**              12/03/12 SKharche     VER 65624 - Support Line Level Address Info & Fix Pricing
//**                                                A bug was found in QA which was fixed under this VER itself
//**************************************************************************************************************

resultArray = string[];

// Split the EncodedAddressData on the delimiter !$!
addressElements = split(encodedAddressData, "!$!");

// addressElementIndex is used to pull the corresct part of the array addressElements
// Assume user is looking for address which is present at index 0, overwrite if this is not the case
addressElementIndex = 0; 

if(lower(addressElement) == "addresstech") {
    addressElementIndex = 1;
}elif(lower(addressElement) == "addresscountry") {
    addressElementIndex = 2;
} elif(lower(addressElement) == "addressname"){
    addressElementIndex = 3;
}

indexes = range(sizeofarray(addressIndexAttributeArray));
for index in indexes {
    // Check if addressIndexAttributeArray's instance has a value greater than 0
    // AND if addressElementAttributeArray's instance is BLANK or string null
    // NOTE: checking string "null" is important becasue we ran into an issue where this is set with the word null
    //       by using isnull() did not fix it so we are comparing it with the string "null"
    // If the above is true then copy the value from the addressElements - meaning we are adding new value to the array
    // Else we just keep the same value of the array - meaning it's not changed
    
    // This function will only CHANGE one value of the source array (4th parameter) and will copy over the remaining values (if present) into the result array
    if(addressIndexAttributeArray[index] > 0 AND (addressElementAttributeArray[index] == "" OR lower(addressElementAttributeArray[index]) == "null")) {
        resultArray[index] = addressElements[addressElementIndex];
    }
    else {
        resultArray[index] = addressElementAttributeArray[index];
    }
}

return resultArray;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_setAddressArrayElements_263833280]]></java_class_name><child_class_names></child_class_names><date_modified>1358564310000</date_modified><guid><![CDATA[sbsavvis_199808853]]></guid><_children></_children></bm_function><bm_lib_func_param><id>263833282</id><bm_lib_func_id>263833281</bm_lib_func_id><param_name><![CDATA[encodedAddressData]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564310000</date_modified><order_no>1</order_no><guid><![CDATA[sbsavvis_199808856]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833283</id><bm_lib_func_id>263833281</bm_lib_func_id><param_name><![CDATA[addressElement]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564310000</date_modified><order_no>2</order_no><guid><![CDATA[sbsavvis_199808857]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833284</id><bm_lib_func_id>263833281</bm_lib_func_id><param_name><![CDATA[addressIndexAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>7</datatype><date_modified>1358564310000</date_modified><order_no>3</order_no><guid><![CDATA[sbsavvis_199808858]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833285</id><bm_lib_func_id>263833281</bm_lib_func_id><param_name><![CDATA[addressElementAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564310000</date_modified><order_no>4</order_no><guid><![CDATA[sbsavvis_199808859]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>485337039</id><name><en><![CDATA[Diff Arrays]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[diffArrays]]></variable_name><description><en><![CDATA[BIGMACH-1796 - Gives difference in two arrays. Returns items in firstArray that are not in secondArray]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>485337038</function_id><main_script_text></main_script_text><date_modified>1371905637000</date_modified><guid><![CDATA[testsavvis_346416784]]></guid><_children><bm_function><id>485337038</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Diff Arrays(diffArrays)
//** Type:        Utility Library Function   
//**
//** Description: Gives difference in two arrays. Returns items in firstArray that are not in secondArray
//** 
//** Param:       firstArray  - base items 
//**              secondArray - items that needs to be removed
//**
//** Return type: string array
//**
//** History:     Date     Author       Comment 
//**              05/28/13 Skharche     BIGMACH-1796 - Renew or release inventory items 
//************************************************************************************************************

retVal = string[];

// Iterate through firstArray and collect a list of all the items that are present in firstArray but not in secondArray
for item in firstArray {
    if(item <> "" AND findinarray(secondArray, item) == -1) {
        append(retVal, item);
    }
}

return retVal;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_diffArrays_485337038]]></java_class_name><child_class_names></child_class_names><date_modified>1371905637000</date_modified><guid><![CDATA[testsavvis_346416783]]></guid><_children></_children></bm_function><bm_lib_func_param><id>485337040</id><bm_lib_func_id>485337039</bm_lib_func_id><param_name><![CDATA[firstArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1371905637000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_346416786]]></guid></bm_lib_func_param><bm_lib_func_param><id>485337041</id><bm_lib_func_id>485337039</bm_lib_func_id><param_name><![CDATA[secondArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1371905637000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_346416787]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>42922588</id><name><en><![CDATA[Get Legacy Constraints Valid Options For Scalar]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getLegacyConstraintsValidOptionsForScalar]]></variable_name><description><en><![CDATA[Grabs the existing option values for a scalar attribute on an existing AIP, then removes all such values from the list of constrained options so as to keep existing products from being inadvertently constrained.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>42922587</function_id><main_script_text></main_script_text><date_modified>1358564312000</date_modified><guid><![CDATA[LEGACY_42922588]]></guid><_children><bm_function><id>42922587</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Legacy Constraints Valid Options For Scalar (getLegacyConstraintsValidOptionsForScalar) **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Grabs the existing option values for a scalar attribute on an existing AIP,                 **
//**              then removes all such values from the list of constrained options so as to keep existing    **
//**              products from being inadvertently constrained.                                              **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

AIPInt = 0;
retOptionVal = optionVal;

//Convert the AIP into integer as the data table has AIPIds as integers
if(AIP <> "" and isnumber(AIP)) {
	AIPInt = atoi(AIP);
}

//Get the legacy valid option for the corresponding AIPs
aipOptionDict = dict("string");
rows = bmql("SELECT AcctProdId, OptionValue FROM AcctProdOption WHERE AcctProdId = $AIPInt AND AttrName=$attrName");
for row in rows {
print row;
	id = get(row, "AcctProdId");
	val = get(row, "OptionValue");
	put(aipOptionDict, id, val);
}

//If the optionVals are constrained exclude those if present in the data table for that specific AIP
if(containskey(aipOptionDict, AIP)) {
	val = get(aipOptionDict, AIP);
	if(val <> "") {
		retOptionVal = replace(optionVal, "|^|" + val, "");     /* if val is 2nd or later in a list */
		retOptionVal = replace(retOptionVal, val + "|^|" , ""); /* if val is first in a list */
		retOptionVal = replace(retOptionVal, val, "");          /* if val is all by itself ... */    
	}
}

return retOptionVal;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getLegacyConstraintsValidOptionsForScalar_42922587]]></java_class_name><child_class_names></child_class_names><date_modified>1358564312000</date_modified><guid><![CDATA[LEGACY_42922587]]></guid><_children></_children></bm_function><bm_lib_func_param><id>42922590</id><bm_lib_func_id>42922588</bm_lib_func_id><param_name><![CDATA[AIP]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564312000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_42922590]]></guid></bm_lib_func_param><bm_lib_func_param><id>42922591</id><bm_lib_func_id>42922588</bm_lib_func_id><param_name><![CDATA[attrName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564312000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_42922591]]></guid></bm_lib_func_param><bm_lib_func_param><id>42922592</id><bm_lib_func_id>42922588</bm_lib_func_id><param_name><![CDATA[optionVal]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564312000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_42922592]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>485337025</id><name><en><![CDATA[Get Notify Email]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getNotifyEmail]]></variable_name><description><en><![CDATA[BIGMACH-2110 - Create a list of email addresses to which email notifications should be sent]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>485337024</function_id><main_script_text></main_script_text><date_modified>1376745601000</date_modified><guid><![CDATA[testsavvis_355832041]]></guid><_children><bm_function><id>485337024</id><ref_type>16</ref_type><script_text><![CDATA[//*****************************************************************************************************
//** Function:    Gte Notify Emails (getNotifyEmails)                                                             
//** Type:        Util
//**                                                                                                 
//** Description: Create a list of email addresses to which email notifications should be sent      
//**                                                                                                 
//** Parameters:  actionName         - action name of the caller  
//**              keywordVsValueDict - hash map containing information that is required by the util such as emails etc
//**
//** Calling Functions / Use Cases                                                                   
//**              Calling Function          actionName        
//**              Submit Order              Submit Order or Normal Submit Order
//**		  SubmitOrder               Submit Order (if expedite on)
//**		  SubmitOrder               Normal Submit Order (if expedite off)
//**		  Redline Submit Order      Submit Order (regardless of expedite flag)
//**                                             
//** History:     Date     Author     Comment                                                        
//**              06/06/13 SKharche   BIGMACH-2110 - Create a list of email addresses to which email notifications should be sent
//**	          07/24/13 STillett   BIGMACH-2376 - allow for "Normal Submit Order" actionName
//*****************************************************************************************************

ret = "";
solutionsEngineerEmails = "";
clientSolutionPartner   = "";
projectManager          = "";

//Note: "Normal Submit Order" will leave out the OP team
if(actionName == "Submit Order" OR actionName == "Normal Submit Order") {
    if(actionName == "Submit Order") {
        ret = ret + "Order.Processing@savvis.com;";
    }
    
    if(containskey(keywordVsValueDict, "Solutions Engineer Emails")) {
        solutionsEngineerEmails = get(keywordVsValueDict, "Solutions Engineer Emails");
    }
    
    if(solutionsEngineerEmails <> ""){
        ret = ret + replace(solutionsEngineerEmails, ",", ";") + ";";
    }
    
    if(containskey(keywordVsValueDict, "Client Solution Partner")) {
        clientSolutionPartner = get(keywordVsValueDict, "Client Solution Partner");
    }
    
    if(containskey(keywordVsValueDict, "Project Manager")) {
        projectManager = get(keywordVsValueDict, "Project Manager");
    }
    
    // Get the email addresses for CSP and PM from the DynamicMenu data table
    tblData = bmql("SELECT Attr1 FROM DynamicMenu WHERE InternalValue=$clientSolutionPartner OR InternalValue=$projectManager");
    for data in tblData {
        ret = ret + get(data, "Attr1") + ";";
    }
}

return ret;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getNotifyEmail_485337024]]></java_class_name><child_class_names></child_class_names><date_modified>1376745601000</date_modified><guid><![CDATA[testsavvis_355832040]]></guid><_children></_children></bm_function><bm_lib_func_param><id>485337026</id><bm_lib_func_id>485337025</bm_lib_func_id><param_name><![CDATA[actionName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1376745601000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_355832043]]></guid></bm_lib_func_param><bm_lib_func_param><id>485337027</id><bm_lib_func_id>485337025</bm_lib_func_id><param_name><![CDATA[keywordVsValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1376745601000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_355832044]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>38127360</id><name><en><![CDATA[Make BM Commerce Button]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[makeBMCommerceButton]]></variable_name><description><en><![CDATA[Use this code to make an HTML button into a BM-CSS friendly action.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>38127359</function_id><main_script_text></main_script_text><date_modified>1358564316000</date_modified><guid><![CDATA[LEGACY_38127360]]></guid><_children><bm_function><id>38127359</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Make BM Commerce Button (makeBMCommerceButton)                                              **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Use this code to make an HTML button into a BM-CSS friendly action.                         **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

ret = "";
if(actionID <> ""){
	ret = "<table cellspacing=\"0\" cellpadding=\"0\" style=\"cursor: pointer;\">"
	+ "<tbody><tr><td class=\"button-left\"> </td>"
	+ "<td nowrap=\"true\" class=\"button-middle\">";
	if(actionImage <> ""){
		ret = ret + "<div style=\"margin: 0px 0px 1px 0px;\">"
		+ "<a style=\"padding-left: 16px; position: relative;\" id=\"" + actionID + "\" class=\"button-text\">"
		+ "<img border=\"0\" src=\"" + actionImage + "\" style=\"width: 16px; height: 16px; top: -1px; left: -3px; position: absolute;\"> </img>"
		+ actionName + "</a></div>";
	}
	else {
		ret = ret + "<div style=\"margin: 0px 0px 1px;\">"
		+ "<a id=\"" + actionID + "\" class=\"button-text\">"
		+ actionName + "</a></div>";
	}
	ret = ret + "</td><td class=\"button-right\"> </td></tr></tbody></table>";
}
return ret;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_makeBMCommerceButton_38127359]]></java_class_name><child_class_names></child_class_names><date_modified>1358564316000</date_modified><guid><![CDATA[LEGACY_38127359]]></guid><_children></_children></bm_function><bm_lib_func_param><id>38127362</id><bm_lib_func_id>38127360</bm_lib_func_id><param_name><![CDATA[actionID]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564316000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_38127362]]></guid></bm_lib_func_param><bm_lib_func_param><id>38127363</id><bm_lib_func_id>38127360</bm_lib_func_id><param_name><![CDATA[actionName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564316000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_38127363]]></guid></bm_lib_func_param><bm_lib_func_param><id>38130321</id><bm_lib_func_id>38127360</bm_lib_func_id><param_name><![CDATA[actionImage]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564316000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_38130321]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>623982879</id><name><en><![CDATA[Get Elements By Tag Name Large]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getElementsByTagNameLarge]]></variable_name><description><en><![CDATA[This function is used to return all the values fromt he input xml for the tag specified. This is supports large XML since BM arrays only support 1000 elements we create a 2D array splitting our data with max 1000 entries for one outer index.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>12</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>623982878</function_id><main_script_text></main_script_text><date_modified>1384812629000</date_modified><guid><![CDATA[testsavvis_459509532]]></guid><_children><bm_function><id>623982878</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************
//** Function:    Get Elements By Tag Name Large (getElementsByTagNameLarge)
//** Type:        Utility Library Function                                                                    
//**                                                                                                          
//** Description: This function is used to return all the values fromt the input xml for the tag specified.
//**              This supports large XML and since BM arrays only support 1000 elements we create a 2D
//**              array splitting our data with max 1000 x 50 entries
//**              inputs: xml (string), tag (string)                                                          
//**                                                                                                          
//** History:     Date     Author       Comment                                                               
//**              09/05/13 SKharhce     Initial Implementation
//**	          11/18/13 STillett     BIGMACH-3013: make function more efficient
//**************************************************************************************************

// NOTE: Most of the code below is duplicate to the util function getElementsByTagName() with the exception
// that this returns a 2D array where the maximum elements that can be stored are 1000 x 50 = 50000

// NOTE: LIMITATION of 2D array: The maximum number of rows supported is 1000 and the maximum number of columns is 50.

result = String[][];

attrTag   = "<" + tag + " ";
startTag  = "<" + tag + ">";
emptyTag  = "<" + tag + "/>";
endTag    = "</" + tag + ">";

tempXML = xml;
startIndex = 0;

nodeTypes = String[]{attrTag,startTag,emptyTag};
nodeTypesFoundInXML = String[];
//BIGMACH-3013
//Let's peek into the string to see if any of these three tags exist.  That way, in the next loop we won't waste
//time on EVERY iteration looking for tags that don't exist.
for each in nodeTypes {
    index = find(tempXML, each);
        if(index <> -1) {
        	append(nodeTypesFoundInXML, each);
        }
}
nodeTypeRange = range(sizeofarray(nodeTypesFoundInXML));

// collect all the data for the specified tag 
outerIndexes = range(1000);
innerIndexes = range(50);
for outerIndex in outerIndexes {
    for innerIndex in innerIndexes {
        nextNodeIndex = -1;
        nextNodeType  = -1;
          
        for nodeType in nodeTypeRange {
            index = find(tempXML, nodeTypesFoundInXML[nodeType], startIndex);
            if(index > -1 and (nextNodeIndex == -1 or nextNodeIndex > index)) {
                  nextNodeIndex = index;
                  nextNodeType = nodeType;
            }
        }
          
        if(nextNodeIndex == -1) {
            break;
        }
        
        // Check for empty tag
        if(nodeTypesFoundInXML[nextNodeType] == emptyTag) {
            endIndex = nextNodeIndex + len(emptyTag);
        }
        else {
            // Calculate the end index
            endIndex = find(tempXML,endTag, startIndex);
            if(endIndex == -1) {
                  break;
            }
            endIndex = endIndex + len(endTag);
        }
        startIndex = endIndex;
        
        result[outerIndex][innerIndex] = substring(tempXML,nextNodeIndex+len(startTag),endIndex-len(endTag));
        //tempXML = substring(tempXML, endIndex);
    }
}

return result;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getElementsByTagNameLarge_623982878]]></java_class_name><child_class_names></child_class_names><date_modified>1384812630000</date_modified><guid><![CDATA[testsavvis_459509531]]></guid><_children></_children></bm_function><bm_lib_func_param><id>623982880</id><bm_lib_func_id>623982879</bm_lib_func_id><param_name><![CDATA[xml]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1384812629000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_459509534]]></guid></bm_lib_func_param><bm_lib_func_param><id>623982881</id><bm_lib_func_id>623982879</bm_lib_func_id><param_name><![CDATA[tag]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1384812630000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_459509535]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>127184077</id><name><en><![CDATA[Is Reuters BAN]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[isReutersBAN]]></variable_name><description><en><![CDATA[Used to determine if the given BAN belongs to Reuters. This should be the only place where this list is maintained !]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>127184076</function_id><main_script_text></main_script_text><date_modified>1358564314000</date_modified><guid><![CDATA[testsavvis_124954132]]></guid><_children><bm_function><id>127184076</id><ref_type>16</ref_type><script_text><![CDATA[/*************************************************************************************************************
-- Function:    Is Reuters BAN (isReutersBAN)
-- Type:        Utility Function
--
-- History:     Used to determine if the given BAN belongs to Reuters.  This will provide a single place to 
--              maintain the list of BANS associated with Reuters.
-- 
--  Date         Author     Comment  
--  05/29/12     MBelin     VER 63157 - Refactored existing code into this utility function
*************************************************************************************************************/

// Assume false ...
returnValue = false;

BPIDArray = integer[];
append(BPIDArray, 124669);
append(BPIDArray, 107527);
append(BPIDArray, 105798);
append(BPIDArray, 124271);
append(BPIDArray, 109498);

// If the BPID is in the list (i.e. offset is not -1) then this must be a Reuters BAN.
if(findinarray(BPIDArray, BPID) <> -1)
{
	returnValue = true;
}
return returnValue;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_isReutersBAN_127184076]]></java_class_name><child_class_names></child_class_names><date_modified>1358564314000</date_modified><guid><![CDATA[testsavvis_124954131]]></guid><_children></_children></bm_function><bm_lib_func_param><id>127184078</id><bm_lib_func_id>127184077</bm_lib_func_id><param_name><![CDATA[BPID]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1358564314000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_124954134]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>623982873</id><name><en><![CDATA[Filter QCC Products]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[filterQCCProducts]]></variable_name><description><en><![CDATA[BIGMACH-2528: Returns an array of models on the quote that are QCC models]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>623982872</function_id><main_script_text><![CDATA[a = string[] {"CTL Optical Wavelength Services", "abc"};
ret = util.filterQCCProducts(a);
return ret;]]></main_script_text><date_modified>1379768483000</date_modified><guid><![CDATA[testsavvis_441946790]]></guid><_children><bm_function><id>623982872</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Filter QCC Products (filterQCCProducts)                                                   
//** Type:        Utility Library Function                                                                    
//**                                                                                                          
//** Description: Returns an array of models that are QCC Network models from the quote
//**
//** Parameters:  productArray - array of all products on the quote                                
//**                                                                                                          
//** History:     Date     Author       Comment                                                               
//**              08/27/13 STillett     BIGMACH-2528: Creation                                
//*************************************************************************************************************

retArray = string[];

qccModelsOnQuote = bmql("SELECT Product FROM QCCProducts WHERE Product IN $productArray");
for each in qccModelsOnQuote {
	append(retArray, get(each, "Product"));
}

return retArray;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_filterQCCProducts_623982872]]></java_class_name><child_class_names></child_class_names><date_modified>1379768483000</date_modified><guid><![CDATA[testsavvis_441946789]]></guid><_children></_children></bm_function><bm_lib_func_param><id>623982874</id><bm_lib_func_id>623982873</bm_lib_func_id><param_name><![CDATA[productArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1379768483000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_441946792]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5856445</id><name><en><![CDATA[Get Elements By Tag Name]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getElementsByTagName]]></variable_name><description><en><![CDATA[This function is used to return all the values fromt he input xml for the tag specified.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>5856444</function_id><main_script_text></main_script_text><date_modified>1358564316000</date_modified><guid><![CDATA[LEGACY_5856445]]></guid><_children><bm_function><id>5856444</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Elements By Tag Name (getElementsByTagName)                                             **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: This function is used to return all the values fromt he input xml for the tag specified.    **
//**              inputs: xml (string), tag (string)                                                          **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

result = String[];

// maximum number of elements
loop = split(xml,"<" + tag);
rest = xml;

attrTag = "<" + tag + " ";
noAttrTag = "<" + tag + ">";
emptyTag = "<" + tag + "/>";
endTag = "</" + tag + ">";

nodeTypes = String[]{attrTag,noAttrTag,emptyTag};
nodeTypeRange = range(sizeofarray(nodeTypes));

for i in loop {
      nextNodeIndex = -1;
      nextNodeType = -1;
      
      for j in nodeTypeRange {
            index = find(rest,nodeTypes[j]);
            if(index > -1 and (nextNodeIndex == -1 or nextNodeIndex > index)) {
                  nextNodeIndex = index;
                  nextNodeType = j;
            }
      }
      
      if(nextNodeIndex == -1) {
            break;
      }
      
      if(nodeTypes[nextNodeType] == emptyTag) {
            endIndex = nextNodeIndex + len(emptyTag);
      }
      else {
            endIndex = find(rest,endTag);
            if(endIndex == -1) {
                  break;
            }
            endIndex = endIndex + len(endTag);
      }
      append(result,substring(rest,nextNodeIndex+len(noAttrTag),endIndex-len(endTag)));
      rest = substring(rest,endIndex);
}

return result;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getElementsByTagName_5856444]]></java_class_name><child_class_names></child_class_names><date_modified>1358564316000</date_modified><guid><![CDATA[LEGACY_5856444]]></guid><_children></_children></bm_function><bm_lib_func_param><id>5856447</id><bm_lib_func_id>5856445</bm_lib_func_id><param_name><![CDATA[xml]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564316000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_5856447]]></guid></bm_lib_func_param><bm_lib_func_param><id>5856448</id><bm_lib_func_id>5856445</bm_lib_func_id><param_name><![CDATA[tag]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564316000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_5856448]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>392706742</id><name><en><![CDATA[CTL Get Pricing]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[ctlGetPricing]]></variable_name><description><en><![CDATA[VER 66539/US402/527:Generates the full XML of the pricing integration piece, then sends it to the pricing web service to get back the correct pricing strings.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>32</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>392706741</function_id><main_script_text><![CDATA[quoteInfoDict 	= dict("string");
docNumArray     = string[];
lineInfoDict 	= dict("string");

put(quoteInfoDict, "BPID", "205316");
put(quoteInfoDict, "CURRENCY", "USD");
put(quoteInfoDict, "TRANSACTIONID", "729509287");
put(quoteInfoDict, "QUOTENUMBER", "291721");
put(quoteInfoDict, "OPPTYID", "006Z0000007jSRYIA2"); 
put(quoteInfoDict, "SYSTEM", "int1centurylink"); 
put(quoteInfoDict, "USERNAME", "johnsmith");
put(quoteInfoDict, "CONTRACTTERMS", "12, 24, 36"); 
put(quoteInfoDict, "BANNUMBER", "New"); 
put(quoteInfoDict, "NODENAME", "bigmachines.node1");
put(quoteInfoDict, "SAVVISCOMPANY", "");
put(quoteInfoDict, "SESSIONID", "DEB3A85096545549E35EE6EB69916E39");
put(quoteInfoDict, "SALESCHANNEL", "Central");

append(docNumArray, "6");
append(docNumArray, "7");

put(lineInfoDict, "6:RENEWAL", "false");
put(lineInfoDict, "6:PRICINGSRC", "NYP");
put(lineInfoDict, "6:PARENT", "");
put(lineInfoDict, "6:MRCLIST", "0.0");
put(lineInfoDict, "6:REGION", "North America");
put(lineInfoDict, "6:BRAND", "Q.ADVAN M");
put(lineInfoDict, "6:PRETTYDESC", "IQ Networking Port - Private!$!NEWLINE!$!!$!NEWLINE!$!!$!INDENT!$!Circuit Speed: DS-1");
put(lineInfoDict, "6:PRICE_STATUS", "");
put(lineInfoDict, "6:TERM", "36");
put(lineInfoDict, "6:REPLACEMENT", "0");
put(lineInfoDict, "6:LOCATION", "");
put(lineInfoDict, "6:EZPROMO", "");
put(lineInfoDict, "6:COMMIT", "10000.0");
put(lineInfoDict, "6:OPTION", "ServiceCategoryCode^=^IQ^-^PORT_TYPE^=^PRIVATE^-^BILLING_TYPE^=^FLAT^-^ACCESS_TYPE^=^DEDICATED IP^-^WAN_BANDWID^=^1500^-^ACCESS_SPEED^=^DS-1");
put(lineInfoDict, "6:PARENTDOC", "5");
put(lineInfoDict, "6:PACKAGE", "IQ Networking Port - Private");
put(lineInfoDict, "6:REUSE_LOOP", "false");
put(lineInfoDict, "6:MODELNAME", "Aggregate Billing");
put(lineInfoDict, "6:COMMERCEEXTRAINFO", "AggregateFlag^=^true");
put(lineInfoDict, "6:QUANTITY", "2");
put(lineInfoDict, "6:TOTALLOOPMRC", "2000");

put(lineInfoDict, "7:RENEWAL", "false");
put(lineInfoDict, "7:PRICINGSRC", "NYP");
put(lineInfoDict, "7:PARENT", "");
put(lineInfoDict, "7:MRCLIST", "0.0");
put(lineInfoDict, "7:REGION", "North America");
put(lineInfoDict, "7:BRAND", "Q.ADVAN M");
put(lineInfoDict, "7:PRETTYDESC", "IQ Networking Port - Private!$!NEWLINE!$!!$!NEWLINE!$!!$!INDENT!$!Circuit Speed: 10Mbps");
put(lineInfoDict, "7:PRICE_STATUS", "");
put(lineInfoDict, "7:TERM", "36");
put(lineInfoDict, "7:REPLACEMENT", "0");
put(lineInfoDict, "7:LOCATION", "");
put(lineInfoDict, "7:EZPROMO", "");
put(lineInfoDict, "7:COMMIT", "10000.0");
put(lineInfoDict, "7:OPTION", "ServiceCategoryCode^=^IQ^-^PORT_TYPE^=^PRIVATE^-^BILLING_TYPE^=^FLAT^-^ACCESS_TYPE^=^ETHERNET^-^WAN_BANDWID^=^10^-^ACCESS_SPEED^=^10BT");
put(lineInfoDict, "7:PARENTDOC", "5");
put(lineInfoDict, "7:PACKAGE", "IQ Networking Port - Private");
put(lineInfoDict, "7:REUSE_LOOP", "false");
put(lineInfoDict, "7:MODELNAME", "Aggregate Billing");
put(lineInfoDict, "7:COMMERCEEXTRAINFO", "AggregateFlag^=^true");
put(lineInfoDict, "7:QUANTITY", "3");
put(lineInfoDict, "7:TOTALLOOPMRC", "2000");

return util.ctlGetPricing(quoteInfoDict, docNumArray, lineInfoDict);]]></main_script_text><date_modified>1390601783000</date_modified><guid><![CDATA[testsavvis_279240808]]></guid><_children><bm_function><id>392706741</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    CTL Get Pricing(ctlGetPricing)
//** Type:        Utility Library Function   
//**
//** Description: Generates the full XML of the pricing integration piece, then sends it to the pricing web   
//**              service to get back the correct pricing strings. Used in getAllPrices commerce function.    
//** 
//** Param:       keyVsQuoteValueDict      - contains quote level information such as quote number, session id, transaction id etc
//**              docNumArray              - list of document numbers that forms part of the key to docNumKeyVsLineValueDict
//**              docNumKeyVsLineValueDict - contains line level information such as part number, aip, a & z address etc
//**                                       - it has a complex key with format docNum:KEY (the valid values for KEY are mentioned below)
//**
//** Return type: dictionary of string dictionaries - contains various dictionaries such as pricing string, options string etc
//**                                                - outer dict key: valid values for key GENERAL_INFO, PRICING_STRING, OPTION_STRING, 
//**                                                                                       VENDOR_STRING, USAGE_STRING, TOTAL_STRING
//**                                                - inner dict key: documentNumber
//**
//** History:     Date     Author    Story       Comment    
//**              03/26/13 SPingle   US 527    - Initial Implementation
//**                       JGSmith   US 718    - Integrate data from configuration; add EZ stub; add debug return;    
//**                       JGSmith   US 606    - Return stubbed pricing messages.  Note that this should be removed
//**                                           - once the ESL service is integrated.
//**                       JGSmith   US 606    - Return message type at part and model level
//**                       SKharche  VER 66539 - CTL Code Reconciliation
//**              04/22/13 SKharche  VER 66870 - CTL Code Reconciliation
//**              03/29/13 SPingle   US 698    - Remove EZ promo stub. Get global vars and make webservice call to CXG/ESL           
//**                                             Parsing the output XML for tags and retrieving prices.
//**                                             Add response values from service to utility response string.
//**                                             Handling Pricing Errors
//**              04/02/13 JGSmith   US 698    - Updates to location reference id
//**              04/05/13 SPingle   US 603    - Get Pricing Messages, if any, for Local Loops from ESL response.
//**              04/05/13 JGSmith   US 765    - Get ICBFlag in MRC and NRC response
//**              04/15/13 JGSmith   Bugs      - Fixing various bugs with LIT, ERR, and ICB handling
//**              05/20/13 SKharche  BIGMACH-2001 - CTL code reconciliation
//**              04/26/13 JGSmith   US 765    - New product attributes for source and target item codes
//**              04/25/13 SPingle   US 605    - Retrieve EZ Pricing price levels from ESL Service.
//**              04/29/13 JGSmith   US 637    - Change request type; retrieve tracking id in response if any
//**              05/02/13 JGSmith   US 605    - Allways ask for EZ pricing
//**              05/10/13 SPingle   US 605    - EZ promo is already selected on priced part, apply the appropriate EZ pricing level to those parts
//**              05/15/13 SPingle   US 765    - ICB additional error handling if non- zero ICB price returned
//**              06/04/13 SKharche  BIGMACH-2002 - CTL code reconciliation
//**              05/24/13 JGSmith   US 1212   - Add processing of Field Discretion (FD) levels
//**              05/15/13 SPingle   US 1210   - Identify bundle promo price in response.
//**              05/15/13 SPingle   US 1257   - Identify Volume discounted value as List MRC.
//**              05/29/13 JGSmith   US 1266   - Add ICB override and change to pricing status on ICB
//**              05/02/13 JGSmith   US 1212   - Allways ask for FD pricing
//**              05/30/13 SPingle   US 1265   - Append MRC and NRC promo name as a string and return to a line attribute
//**              07/10/13 SKharche  BIGMACH-2291 - CTL code reconciliation
//**                       JGSmith   US 1344      - Pass pretty description to CTL pricing utility (for update with tracking id)
//**              08/05/13 SKharche  BIGMACH-2347 - CTL code reconciliation
//**              07/22/13 JGSmith   US 1103      - Use configured source price as list
//**              07/26/13 PAthelli  US 1342      - Use ctlSalesChannel table whether to call EZ or FD pricing
//**              08/12/13 SPingle   Bugs         - Fixed a bug related to ERR items while missing pricing
//**              09/23/13 SKharche  BIGMACH-2710 - CTL code reconciliation
//**              08/08/13 JGSmith   US 1632      - Added instrumentation
//**              09/12/13 SPingle   US 1350      - NRC Waivers for Standard Pricing
//**              09/12/13 RMendoza  US 1923      - Sort EZ Levels string
//**              11/18/13 SKharche  BIGMACH-3012 - CTL code reconciliation
//**              11/12/13 SPingle   US 2133      - Support iQ Networking Transition Promotion Pricing in CPQ
//**              11/21/13 SPingle   US 2213      - Fix to allow reading the bundle promo [Initial Promotion 1] once from a response. 
//**              12/02/13 JGSmith   Performance  - Commented out print statements and XML return.  Search for "XML_PRINT"
//**              12/19/13 RMendoza  US 2301      - Allowed for Loop Tracking ID to be updated/editable for pretty description
//**              01/17/14 JGSmith   US 1567      - Updates to support Aggregate Billing
//************************************************************************************************************


/* LIST of keys for quote info dictionary
    SYSTEM          - _system_supplier_company_name
    QUOTENUMBER     - quoteNumber_quote
    TRANSACTIONID   - transactionID_quote
    CURRENCY        - USD or if outputCurrency_quote is NOT empty then it's value
    SESSIONID       - current session id
*/

/* LIST of keys for line info dict - key is a complex key with format docNum:KEY
    OPTION          - tech description
    PACKAGE         - standard part name
    BRAND           - brand for line
    TERM            - term on line
    COMMIT          - commit on line
    EZPROMO         - promo selected for the line
    LOCATION        - location identifier for the line
    PARENTDOC       - parent document number, used for grouping parts
    PRETTYDESC      - display (pretty) description
    COMMERCEEXTRAINFO  - extra commerce-specific information generated during configuration
    QUANTITY        - the quantity of the part
    TOTALLOOPMRC    - From the model - the estimated total loop MRC for all parts in an aggregate billed model
*/

/*
    NOTE: delimited strings are returned by the pricing web service, below are the details of those delimited strings
    
    general_info    - error messages, debug information, and similar high level data
    pricingString   - for more information refer attribute description for pricingString_line
    totalString     - for more information refer attribute description for totalsString_line
*/

/* The following code deals with timing, and must remain before any other code in this utility

   The timing code will record the following time stamps:
       Time on entry to this utility
       Time imediately before call out to ESL pricing service
       Time on return from the pricing service
       Time just before returning from this utility
       
   The code will then calculate two durations: 
       Total time spent in this utility
       Total time spent waiting for the pricing service (also included in the former)
       
   These two durations will be added to the output dictionary under the key "INSTRUMENTATION" as a formatted string:
       Total Utility Time^=^uuuuu^-^Total Callout Time^=^ccccc
       
   The durations uuuuu and ccccc will be in milliseconds
*/

msTimeOnUtilityEntry = getcurrenttimeinmillis();            // Get this first so we have an accurate reading of the entry time
msTimeOnUtilityExit  = -1;                                  // To indicate that time has not yet been recorded
msTimeOnSvcCallout   = -1;
msTimeOnSvcReturn    = -1;
msUtilityDuration    = 0;
msSvcCalloutDuration = 0;

// End of timing related initialization code

retDict = dict("dict<string>"); // key: {GENERAL_INFO, PRICING_STRING, TOTAL_STRING}, value: corresponding dictionaries created above that stores the web service response
messageTypePartToModel  = dict("string");       // Key: model (parent document number); value: message type
parentDocuments         = string[];             // List of all parent documents found in pricing results

inputXML                = "";
outputXML               = "";
allConfigs              = "";
brandInfoXML            = "";
ezPriceString           = "";
fdPriceString           = "";                   // [US 1212]
appliedPromoString      = "";
ezPriceReturnStr        = "";
fdPriceReturnStr        = "";                   // [US 1212]
promoNameReturnStr      = "";                   // [US 1265]
brandCheckDict          = dict("integer");      // Brands encountered while processing the input data
brandSeqId              = 0;                    // Count the number of unique brands encountered
locationInfoXML         = "";
locationCheckDict       = dict("string");       // Locations encountered while processing the input data
priceItemInfoXML        = "";
system                  = "";
otherAttributesString   = "";                   // [US 606] Return any additional attributes and values
errorCount              = 0;                    // Temporary, since BML abhors a vacuum
pricedItemCount         = 0;                    // Temporary, to support stubbed pricing message responses
nrcWaiverString         = "";
nrcWaiverReturnStr      = "";

hasWaiverInfoList       = false;

inputHeaders               = dict("string");
docNumVsGeneralInfoDict    = dict("string");    // key: documentNumber, value: general information like error message, fault string etc
docNumVsPricingStringsDict = dict("string");    // key: documentNumber, value: pricing string present in <price> tag in the response xml
docNumVsTotalStringsDict   = dict("string");    // key: documentNumber, value: total string present in <total> tag in the response xml
docNumVsPriceResponseDict  = dict("string");    // key: compound key with doc # and keywords, value: MRC and NRC values from ESL response
promoCodeVsNoToESLFlagDict  = dict("string");   // key: IA Transition Promocode, value: Flag to Not sendToESL (Y/N)

// Variables to store data related to Aggregate Billing
aggBillModelDocNumArray    = string[];          // List of model document numbers that have aggregate billed parts
docNumVsAggBillInfoDict    = dict("string");    // Doc number plus key to various aggregate billing data
        // Keys in the above dictionary are:
        //  parentDocnum:PartDocnumList        : Comma separated list of part numbers for the given model (parent) doc num
        //  parentDocnum:TotalLoopMrc          : The total loop MRC for the aggregate billed model
        //  parentDocnum:ContractTerm          : The contract term in months
        //        docnum:IsAggregate           : Present only if this part (not a model) is aggregate billed
        //        docNum:MRC                   : The (final, net) MRC for an aggregate billed part
        //        docnum:PORT_TYPE             : The port type of an aggregate billed part
        //        docnum:QUANTITY              : The quantity of an aggregate billed part
        //        docnum:WAN_BANDWIDTH         : The bandwidth in MB (unless 1500) of an aggregate billed part
        //        docnum:EZLevel               : The EZ level for each aggregate billed part

//US #1342
reqEzDataInPricing="";
reqFdDataInPricing="";
reqEzDataInPricing_bln  ="true";
reqFdDataInPricing_bln  ="true";
// End of US #1342 changes

listOfTags      = string[] {"ESLPriceResponse", "ProcessStatus", "PricingException", "PriceItemResponse"};                         // list of outer tags in the response xml, stored in array so that we can loop
listOfInnerTags = string[] {"LineId", "PricingMessageList", "ItemAttributeList", "FDPricingInfoList"};    // list of inner tags in the response xml, store in array so that we can loop
listOfPriceListTags = string[] {"MRCPrice", "NRCPrice", "EZPricingInfo", "WaiverInfoList"};    // list of inner tags in each ItemPriceList tag of the response xml, store in array so that we can loop

if(containsKey(keyVsQuoteValueDict, "SYSTEM")) {
    system = get(keyVsQuoteValueDict, "SYSTEM");
}
//inputXML = urldatabypost("https://" + system + ".bigmachines.com/bmfsweb/" + system + "/image/WebServices/ctlPricingRequest.xml", "", "");

//US # 1342 fetch data from ctlsalesChannel
salesChannelQuote = get(keyVsQuoteValueDict, "SALESCHANNEL");
ctlSalesChannelresults = bmql("select ReqEzDataInPricing ,ReqFdDataInPricing from ctlSalesChannel where QuoteSalesChannel  = $salesChannelQuote");
for result in ctlSalesChannelresults {
  //Not sure how to hand if it returns more than one record values
  reqEzDataInPricing = get(result ,"ReqEzDataInPricing");
  reqFdDataInPricing = get(result ,"ReqFdDataInPricing");
}
//END OF US #1342

//US 2133: Get all possible IQ Transition Promos from table and store in dict.
IQTransPromoresults = bmql("select PromoName, SendToESL from ctlIQTransPromo");
for promo in IQTransPromoresults {
  promoCode = get(promo ,"PromoName");
  passToESL = get(promo ,"SendToESL");
  if(promoCode <> "" AND passToESL <> "" AND passToESL == "N" AND NOT isnull(promoCode) AND NOT isnull(passToESL)){
    put(promoCodeVsNoToESLFlagDict, promoCode, passToESL);      
  }
}

inputXML = "<?xml version=\"1.0\" encoding=\"utf-8\" ?>"
    + "<ESLPriceRequest xmlns=\"http://www.centurylink.com/XMLSchema/ESL\">"
    + "  <GenericInfo>"
    + "    <OpptyId>%OPPTYID%</OpptyId>"
    + "    <RequestId>%REQUESTID%</RequestId>"
    + "    <BrandInfo>%BRANDINFO%</BrandInfo>"
    + "    <CallingSystemName>?LLINGSYSTEM%</CallingSystemName>"
    + "    <RequestType>%REQUESTTYPE%</RequestType>"
    + "    <EZPricing>%REPLACEEZPRICING%</EZPricing>"             // [US 605] Allways ask for EZ [US #1342] now get decision from table
    + "    <FDPricing>%REPLACEFDPRICING%</FDPricing>"             // [US 1212] Allways ask for FD    [US #1342] now get decision from table
    + "    <PriceCurrencyType>%QUOTECURRENCY%</PriceCurrencyType>"
    + "  </GenericInfo>"
    + "  <LocationInfo>%EXTERNALLOCATIONREF%</LocationInfo>"
    + "  <PriceItemList>%PRICEITEMLIST%</PriceItemList>"
    + "</ESLPriceRequest>";

if(containsKey(keyVsQuoteValueDict, "OPPTYID")){
    inputXML = replace(inputXML, "%OPPTYID%", get(keyVsQuoteValueDict, "OPPTYID"));
}
if(containsKey(keyVsQuoteValueDict, "QUOTENUMBER")){
    inputXML = replace(inputXML, "%REQUESTID%", get(keyVsQuoteValueDict, "QUOTENUMBER"));
}
if(containsKey(keyVsQuoteValueDict, "CURRENCY")){
    inputXML = replace(inputXML, "%QUOTECURRENCY%", get(keyVsQuoteValueDict, "CURRENCY"));
}
inputXML = replace(inputXML, "%REQUESTTYPE%", "GenerateQuote");    // [US 637]  For pilot, allways GenerateQuote

// Begin of US #1342 changes
if(NOT isnull(reqEzDataInPricing ) AND (len(reqEzDataInPricing ) > 0) AND atoi(reqEzDataInPricing ) == 0  ){
    reqEzDataInPricing_bln="false";
}
    
if(NOT isnull(reqFdDataInPricing ) AND (len(reqFdDataInPricing ) > 0) AND atoi(reqFdDataInPricing ) == 0  ){
    reqFdDataInPricing_bln="false";
}
inputXML = replace(inputXML, "%REPLACEEZPRICING%", reqEzDataInPricing_bln); //default to true if if did not meet criteria.
inputXML = replace(inputXML, "%REPLACEFDPRICING%", reqFdDataInPricing_bln); //default to true if if did not meet criteria.

//End of changes  to US #1342

for each in docNumArray {
    eachBrand                   = "";
    eachTerm                    = "";
    eachCommit                  = "";
    eachLocationID              = "";
    eachOption                  = "";    
    eachPackage                 = "";
    eachQuantity                = 1;        // [US 1567] Used for aggregate billing
    productXML                  = "";
    pricingSource               = "";
    eachGroup                   = "";
    pricingSourceValue          = "";       // Composite value containing one or two pricing sources
    lineItemProductAttrListXML  = "";       // XML containing the line item product attributes
    targetItemCodesXML          = "";       // XML containing the target item code(s)
    itemAttributeListXML        = "";       // XML containing the item attributes
    thisBrandId                 = "";       //
    foundPricingDataRow         = false;    // Did our BMQL return anything?
    allItemAttributesSource     = "";
    serviceCategoryCode         = "";       // Input attribute along with eachPackage
    iQTransPromoStr             = "";       // String containing the promocode that are not sent in request.
    aggregateBilledPart         = false;
    if(containskey(docNumKeyVsLineValueDict, each + ":PRICINGSRC")){
        pricingSource = get(docNumKeyVsLineValueDict, each + ":PRICINGSRC");
    }
    
    priceStatus = get(docNumKeyVsLineValueDict, each + ":PRICE_STATUS");
    
    if((pricingSource == "NYP") OR (pricingSource == "ERR" AND priceStatus <> "")){
        //Only perform the below for NYP parts - Swapnil P (and ERR parts - JGS)
        pricedItemCount = pricedItemCount + 1;
        if(containskey(docNumKeyVsLineValueDict, each + ":OPTION")){
            eachOption = get(docNumKeyVsLineValueDict, each + ":OPTION");
        }
        if(containskey(docNumKeyVsLineValueDict, each + ":PACKAGE")){
            eachPackage = get(docNumKeyVsLineValueDict, each + ":PACKAGE");
        }
        if(containskey(docNumKeyVsLineValueDict, each + ":BRAND")){
            eachBrand = get(docNumKeyVsLineValueDict, each + ":BRAND");
        }
        if(containskey(docNumKeyVsLineValueDict, each + ":TERM")){
            eachTerm = get(docNumKeyVsLineValueDict, each + ":TERM");
        }
        if(containskey(docNumKeyVsLineValueDict, each + ":COMMIT")){
            eachCommit = get(docNumKeyVsLineValueDict, each + ":COMMIT");
        }
        if(containskey(docNumKeyVsLineValueDict, each + ":LOCATION")){
            eachLocationID = get(docNumKeyVsLineValueDict, each + ":LOCATION");
        }
        if(containskey(docNumKeyVsLineValueDict, each + ":PARENTDOC")){  // [US 718]
            eachGroup = get(docNumKeyVsLineValueDict, each + ":PARENTDOC");
        }
        if (containskey(docNumKeyVsLineValueDict, each + ":QUANTITY")) {
            quantityString = get(docNumKeyVsLineValueDict, each + ":QUANTITY");
            if (isnumber(quantityString)) {
                eachQuantity = atoi(quantityString);
            }
        }
        // [US 1567] Determine if the item is aggregate billed (default is false - see above)
        if (containskey(docNumKeyVsLineValueDict, each + ":COMMERCEEXTRAINFO")){
            commerceExtraInfoValue = get(docNumKeyVsLineValueDict, each + ":COMMERCEEXTRAINFO");
            // TODO: This code should be refactored to use a utility once utilities can call utilities since we want
            // to hide how the commerce extra info data is encoded
            ceiPairs = split(commerceExtraInfoValue, "^-^");
            for ceiPair in ceiPairs {
                if (ceiPair == "AggregateFlag^=^true") {
                    aggregateBilledPart = true;
                    put(docNumVsAggBillInfoDict, each + ":IsAggregate", "true");
                    // Capture the model (parent document for this part) and part
                    if (findinarray(aggBillModelDocNumArray, eachGroup) == -1) {
                        append(aggBillModelDocNumArray, eachGroup);
                    }
                    key = eachGroup + ":PartDocnumList";
                    if (containskey(docNumVsAggBillInfoDict, key)) {
                        put(docNumVsAggBillInfoDict, key, get(docNumVsAggBillInfoDict, key) + "," + each);
                    } else {
                        put(docNumVsAggBillInfoDict, key, each);
                    }
                    // Other model-level attributes
                    key = eachGroup + ":TotalLoopMrc";
                    if (NOT containskey(docNumVsAggBillInfoDict, key)) {
                        put(docNumVsAggBillInfoDict, key, get(docNumKeyVsLineValueDict, each + ":TOTALLOOPMRC"));
                    }
                    key = eachGroup + ":ContractTerm";
                    if (NOT containskey(docNumVsAggBillInfoDict, key)) {
                        put(docNumVsAggBillInfoDict, key, eachTerm);
                    }
                    put(docNumVsAggBillInfoDict, each + ":QUANTITY", string(eachQuantity));
                    break;  // We've found the aggregate billing flag; we can stop searching commerce extra info now
                }
            }
        }
        // [JGSmith: 04/04/13]  Extract service category code from Option string
        if (NOT isnull(eachOption) AND (eachOption <> "")) {
            tmpOptionPairs = split(eachOption, "^-^");
            for optionPair in tmpOptionPairs {
                nameAndValue = split(optionPair, "^=^");
                if (nameAndValue[0] == "ServiceCategoryCode") {
                    serviceCategoryCode = nameAndValue[1];
                }
            }
        }
        // Populate the brandinfo XML with unique brands on the quote- Swapnil P 3-15
        if(NOT containskey(brandCheckDict, eachBrand)){
            brandSeqId = brandSeqId + 1;
            put(brandCheckDict, eachBrand, brandSeqId);
            brandInfoXML = brandInfoXML + "<BrandSequenceId>" + string(brandSeqId) + "</BrandSequenceId>";
            brandInfoXML = brandInfoXML + "<Brand>" + eachBrand + "</Brand>";
            brandInfoXML = brandInfoXML + "<Term>" + eachTerm + "</Term>";
            brandInfoXML = brandInfoXML + "<Commit>" + eachCommit + "</Commit>";
            thisBrandId = string(brandSeqId);
        } else {
            // Existing brand, so use the sequence id saved for this brand
            thisBrandId = string(get(brandCheckDict, eachBrand));
        }
        
        // Populate the Locationinfo XML with unique locations's on the quote- Swapnil P 3-15
        // [US 698] Updated to use the SFDC id as reference, not include additional loc, and source to SFDC
        if(NOT containskey(locationCheckDict, eachLocationID)){
            put(locationCheckDict, eachLocationID, eachLocationID);
            if (eachLocationID <> "") {     // [JGS: 1/17/14] Don't add empty locations
                locationInfoXML = locationInfoXML 
                    + "<ExternalLocationRef>"
                    + "<LocationSource>SFDC</LocationSource>"
                    + "<LocationIdentifier>"
                    + "<LocationReferenceID>" + eachLocationID + "</LocationReferenceID>"
                    + "</LocationIdentifier>"
                    + "</ExternalLocationRef>";
            }
        }
        
        // [JGSmith: 3/18/13]  Fetch product specific data from data table for building XML pricing request
        // The result should return a single row.  Assume this is true (for now)
        // [JGSmith: 04/04/13]  Use the service category code as an additional input param when available
        pricingDataRows = recordset();
        if (serviceCategoryCode == "") {
            pricingDataRows = 
                bmql("SELECT ServiceCategoryCode, ComponentGroupCode, ApplicationCode, AccessMethodCode, " +
                     "MRCComponentCode, MRCPricingSource, NRCComponentCode, NRCPricingSource, " +
                     "ConstAttributeList1, ConstAttributeList2, ConstAttributeList3, ConstAttributeList4, " +
                     "SourceForList " +             // [US 1103]
                     "from ctlPricingData WHERE PartName = $eachPackage");
        } else {
            pricingDataRows = 
                bmql("SELECT ServiceCategoryCode, ComponentGroupCode, ApplicationCode, AccessMethodCode, " +
                     "MRCComponentCode, MRCPricingSource, NRCComponentCode, NRCPricingSource, " +
                     "ConstAttributeList1, ConstAttributeList2, ConstAttributeList3, ConstAttributeList4, " +
                     "SourceForList " +             // [US 1103]
                     "from ctlPricingData " +
                     "WHERE PartName = $eachPackage AND ServiceCategoryCode = $serviceCategoryCode");
        }
        // print pricingDataRows;
        for pricingDataRow in pricingDataRows {
            // Extract the individual elements from the result of the bmql query above
            constAttrList1 = get(pricingDataRow, "ConstAttributeList1");
            constAttrList2 = get(pricingDataRow, "ConstAttributeList2");
            constAttrList3 = get(pricingDataRow, "ConstAttributeList3");
            constAttrList4 = get(pricingDataRow, "ConstAttributeList4");
            mrcPricingSource = get(pricingDataRow, "MRCPricingSource");
            nrcPricingSource = get(pricingDataRow, "NRCPricingSource");
            mrcComponentCode = get(pricingDataRow, "MRCComponentCode");
            nrcComponentCode = get(pricingDataRow, "NRCComponentCode");
            sourceForList = get(pricingDataRow, "SourceForList");               // [US 1103]
            pricingSourceSeparator = "";
            componentCodeSeparator = "";
            foundPricingDataRow = true;
            // Note if more than one row is returned from the bmql query, we will execute this loop more than once
            // For now, we're going to be ok with this since we don't think it can happen
            
            // Build the pricing source value.  Only include separator if there are both MRC and NRC codes
            if (isnull(mrcPricingSource)) { mrcPricingSource = ""; }
            if (isnull(nrcPricingSource)) { nrcPricingSource = ""; }
            // TODO: if there are ever more than two, this code needs to be updated
            if ((mrcPricingSource <> "") and (mrcPricingSource <> "")) {
                pricingSourceSeparator = "^";
            }
            pricingSourceValue = mrcPricingSource + pricingSourceSeparator + nrcPricingSource;
            // Build the product attribute list for this item
            lineItemProductAttrListXML = lineItemProductAttrListXML + "<LineItemProductAttrList>"
                + "<LineItemProductAttr><ProductAttrName>AccessMethodCode</ProductAttrName><ProductAttrValue>"
                + get(pricingDataRow, "AccessMethodCode") + "</ProductAttrValue></LineItemProductAttr>"
                + "<LineItemProductAttr><ProductAttrName>ApplicationCode</ProductAttrName><ProductAttrValue>"
                + get(pricingDataRow, "ApplicationCode") + "</ProductAttrValue></LineItemProductAttr>"
                + "<LineItemProductAttr><ProductAttrName>ServiceCatCode</ProductAttrName><ProductAttrValue>"
                + get(pricingDataRow, "ServiceCategoryCode") + "</ProductAttrValue></LineItemProductAttr>"
                + "<LineItemProductAttr><ProductAttrName>PricingSource</ProductAttrName><ProductAttrValue>"
                + pricingSourceValue + "</ProductAttrValue></LineItemProductAttr>"
                + "<LineItemProductAttr><ProductAttrName>MRCPricingSource</ProductAttrName><ProductAttrValue>"
                + mrcPricingSource + "</ProductAttrValue></LineItemProductAttr>"
                + "<LineItemProductAttr><ProductAttrName>NRCPricingSource</ProductAttrName><ProductAttrValue>"
                + nrcPricingSource + "</ProductAttrValue></LineItemProductAttr>"
                + "<LineItemProductAttr><ProductAttrName>MRCTargetItemCode</ProductAttrName><ProductAttrValue>"
                + mrcComponentCode + "</ProductAttrValue></LineItemProductAttr>"
                + "<LineItemProductAttr><ProductAttrName>NRCTargetItemCode</ProductAttrName><ProductAttrValue>"
                + nrcComponentCode + "</ProductAttrValue></LineItemProductAttr>"
                + "<LineItemProductAttr><ProductAttrName>CGCode</ProductAttrName><ProductAttrValue>"
                + get(pricingDataRow, "ComponentGroupCode") + "</ProductAttrValue></LineItemProductAttr>"
                + "</LineItemProductAttrList>";
                
            // Need to add extra separators if the const attribute lists are non-empty and do not end with them
            separator = "^-^";
            if (NOT isnull(constAttrList1) AND (constAttrList1 <> "")) {
                if ((eachOption <> "") AND NOT endswith(eachOption, separator)) { 
                    eachOption = eachOption + separator;
                }
            }
            if (NOT isnull(constAttrList2) AND (constAttrList2 <> "") AND NOT endswith(constAttrList2, separator)) {
                constAttrList1 = constAttrList1 + separator;
            }
            if (NOT isnull(constAttrList3) AND (constAttrList3 <> "") AND NOT endswith(constAttrList3, separator)) {
                constAttrList2 = constAttrList2 + separator;
            }
            if (NOT isnull(constAttrList4) AND (constAttrList4 <> "") AND NOT endswith(constAttrList4, separator)) {
                constAttrList3 = constAttrList3 + separator;
            }
            // The full list of item attributes comes from the data table plus tech description
            allItemAttributesSource = eachOption
                + constAttrList1
                + constAttrList2
                + constAttrList3
                + constAttrList4;
            allItemAttributePairs = split(allItemAttributesSource, "^-^");
            //print allItemAttributePairs;
            // Convert list of attribute name/value pairs into the appropriate XML
            itemAttributeListXML = itemAttributeListXML + "<ItemAttributeList>";
            for itemAttributePair in allItemAttributePairs{
                itemAttrNameAndValue = split(itemAttributePair, "^=^");
                //SPingle 10/16/13: Added filter to not allow building tags with empty values
                if (itemAttrNameAndValue[0] <> "ServiceCategoryCode" AND NOT isnull(itemAttrNameAndValue[1]) AND itemAttrNameAndValue[1] <> "" AND itemAttrNameAndValue[1] <> "null") { // [JGSmith: 4/4/13]  Filter service category code
                    //US2133: Check if IQTrans PromoCode are found in tech description. Compare them with dict vals that we do not want to send in request.
                    //If found, do not added them to  <ItemAttribute> list in request but we will need to add these in pretty description. S
                    //So store them in temp attribute var.
                    if(containskey(promoCodeVsNoToESLFlagDict, itemAttrNameAndValue[1])){
                      iQTransPromoStr =  iQTransPromoStr + itemAttrNameAndValue[1] + "!$!NEWLINE!$!";      
                    }
                    else{
                        itemAttributeListXML = itemAttributeListXML
                            + "<ItemAttribute><Name>"
                            + itemAttrNameAndValue[0]
                            + "</Name><Value>"     // Note: enclosing value in CDATA in case of special characters
                            + itemAttrNameAndValue[1]
                            + "</Value></ItemAttribute>";
                        // [US 1567] Identify and extract values needed for aggregate billing calculation
                        if (aggregateBilledPart AND (itemAttrNameAndValue[0] == "WAN_BANDWID" OR itemAttrNameAndValue[0] == "PORT_TYPE")) {
                            put(docNumVsAggBillInfoDict, each + ":" + itemAttrNameAndValue[0], itemAttrNameAndValue[1]);
                        }
                    }
                }
            }
            itemAttributeListXML = itemAttributeListXML + "</ItemAttributeList>";
            // Build the target item codes XML.  Only include separator if there are both MRC and NRC codes
            if (isnull(mrcComponentCode)) { mrcComponentCode = ""; }
            if (isnull(nrcComponentCode)) { nrcComponentCode = ""; }
            // TODO: if there are ever more than two, this code needs to be updated
            if ((mrcComponentCode <> "") and (nrcComponentCode <> "")) {
                componentCodeSeparator = "^";
            }
            targetItemCodesXML = targetItemCodesXML + "<TargetItemCodes>"
                + mrcComponentCode + componentCodeSeparator + nrcComponentCode
                + "</TargetItemCodes>";

            // Assemble the price item info for this part
            priceItemInfoXML = priceItemInfoXML + "<PriceItemInfo>";
            priceItemInfoXML = priceItemInfoXML + "<LineGroupId>" + eachGroup + "</LineGroupId>";
            priceItemInfoXML = priceItemInfoXML + "<LineId>" + each + "</LineId>";
            priceItemInfoXML = priceItemInfoXML + "<BrandSequenceId>" + thisBrandId + "</BrandSequenceId>";
            // [US 1567] If this part is aggregate billed, include a flag to say so
            if (aggregateBilledPart) {
                priceItemInfoXML = priceItemInfoXML + "<AggregateBillingFlag>true</AggregateBillingFlag>";
            }
            if (eachLocationID <> "") {         // Not all parts have a location
                priceItemInfoXML = priceItemInfoXML 
                    + "<LocationIdentifier><LocationReferenceID>" 
                    + eachLocationID 
                    + "</LocationReferenceID></LocationIdentifier>";
            }
            priceItemInfoXML = priceItemInfoXML + lineItemProductAttrListXML;
            priceItemInfoXML = priceItemInfoXML + "<SourceItemCode>" + eachPackage + "</SourceItemCode>";
            priceItemInfoXML = priceItemInfoXML + targetItemCodesXML;
            priceItemInfoXML = priceItemInfoXML + itemAttributeListXML;
            priceItemInfoXML = priceItemInfoXML + "</PriceItemInfo>";
            
            // [US 1103] Identify the source to be used for the list price based on part name, and add to the (response) dictionary
            put (docNumVsPriceResponseDict, each + ":SOURCEFORLIST", sourceForList);
        }   // End of "for pricingDataRow in pricingDataRows"
        
        //US2133: Put the IQ trans string values in the price response dict so that we can use it while returning val as pretty desc.
        put(docNumVsPriceResponseDict, each + ":IQ_TRANS_PROMO", iQTransPromoStr);
        
        if (NOT foundPricingDataRow) {
            // No row in the DB table corresponding to our part number - need to include an error
            errorCount = errorCount + 1;
        }
    }
}

if (pricedItemCount <> 0) {
    // Substitute the brands, locations, and price item data in the XML request
    inputXML = replace(inputXML, "%BRANDINFO%", brandInfoXML);
    inputXML = replace(inputXML, "%EXTERNALLOCATIONREF%", locationInfoXML);
    inputXML = replace(inputXML, "%PRICEITEMLIST%", priceItemInfoXML);
    //US 698: Setup global vars for service endpoints.
    cxgPricingURL = "";
    cxgPricingCreds = "";
    callingSystemName = "CPQ";
    globalVarsResult = bmql("SELECT Keyword, Value FROM ctlGlobalVars");
    for val in globalVarsResult {
        if(get(val, "Keyword") == "CXG_PRICING_URL"){
            cxgPricingURL = get(val, "Value");
        }
        if(get(val, "Keyword") == "CXG_PRICING_CREDENTIAL_B64"){
            cxgPricingCreds = get(val, "Value");
        }
        if(get(val, "Keyword") == "CALLING_SYS_NAME"){
            callingSystemName = get(val, "Value");
        }
    }
    //Substitute the calling system name from the table value.
    inputXML = replace(inputXML, "?LLINGSYSTEM%", callingSystemName);
    // Populate the header dictionary with credentials
    // NOTE: the credentials should be specified in BASE64 format. username:password is converted to BASE64 format
    put(inputHeaders, "Authorization", "Basic "+ cxgPricingCreds);
    put(inputHeaders, "Content-Type", "text/xml");
    // [JGS 12/2/13] Print statements commented out as they can leak memory according to BMI
    // XML_PRINT - for debugging purposes, uncomment the next line but always replace comments
    // print inputXML;
    // Record the time immediately before calling the service.  Add no code between this and the urldatabypost call
    msTimeOnSvcCallout   = getcurrenttimeinmillis();
    outputXML = trim(urldatabypost(cxgPricingURL, inputXML, "NULL", inputHeaders));
    // Record the time immediately after calling the service.  Add no code between this and the urldatabypost call
    msTimeOnSvcReturn    = getcurrenttimeinmillis();

    // [JGS 12/2/13] Print statements commented out as they can leak memory according to BMI
    // XML_PRINT - for debugging purposes, uncomment the next line but always replace comments
    // print outputXML ;
    // Remove all name-space indicators from tags
    outputXML = replace(outputXML, "<esl:", "<");
    outputXML = replace(outputXML, "</esl:", "</");
    outputXML = replace(outputXML, "<e:", "<");
    outputXML = replace(outputXML, "</e:", "</");

    if(startswith(outputXML, "NULL")){
        put(docNumVsGeneralInfoDict, "INTEGRATION_ERROR", "There was an error with the Pricing Integration Web Service.");
    }
    else {
        // [JGS 12/2/13] Commented out the following line to reduce performance impacts in production
        // put(docNumVsGeneralInfoDict, "DEBUG_OUTPUT", outputXML);
        // US 698:Parsing the output XML for tags and retrieving prices
        getErrorMsg = false;
        for searchTag in listOfTags {
            dataInTag         = "";    
            blankTag          = "<" + searchTag + "/>";
            startTag          = "<" + searchTag + ">";
            startTagWithExtra = "<" + searchTag + " ";
            endTag            = "</" + searchTag + ">";
            
            startLen = len(startTag);
            endLen   = len(endTag);

            if(find(outputXML, blankTag) <> -1){
                dataInTag = "";
            }
            elif((find(outputXML, startTag) <> -1) AND (find(outputXML, endTag) <> -1)){
                dataInTag = substring(outputXML, find(outputXML, startTag) + startLen, find(outputXML, endTag));
            }
            elif((find(outputXML, startTagWithExtra) <> -1) AND (find(outputXML, endTag) <> -1)){
                temp = substring(outputXML, find(outputXML, startTagWithExtra) +  startLen, find(outputXML, endTag)); 
                pos = find(temp,">");
                dataInTag = substring(temp, pos + 1, len(temp));
            }
            else{
                dataInTag = "NULL";
            }
            if(searchTag == "ESLPriceResponse") {
                allConfigs = dataInTag;
            }
            if(searchTag == "ProcessStatus"){
                if(upper(dataInTag) == "FAILURE"){
                    getErrorMsg = true;
                }
            }
            if((searchTag == "PricingException") AND upper(dataInTag) <> "NULL" AND getErrorMsg == true) {
                statusStartTag = "<Status>";
                statusEndTag   = "</Status>";
                codeStartTag = "<Code>";
                codeEndTag   = "</Code>";
                messageStartTag = "<Message>";
                messageEndTag   = "</Message>";
                eslStatusInTag = substring(dataInTag, find(dataInTag, statusStartTag) + len(statusStartTag), find(dataInTag, statusEndTag));
                eslCodeInTag = substring(dataInTag, find(dataInTag, codeStartTag) + len(codeStartTag), find(dataInTag, codeEndTag));
                eslMsgInTag = substring(dataInTag, find(dataInTag, messageStartTag) + len(messageStartTag), find(dataInTag, messageEndTag));
                errorStr = eslMsgInTag + " Error Status:" + eslStatusInTag + " Error Code:" + eslCodeInTag;
                put(docNumVsGeneralInfoDict, "INTEGRATION_ERROR", errorStr);
            }
            elif((searchTag <> "PriceItemResponse") AND upper(dataInTag) <> "NULL" AND getErrorMsg == true){
                 put(docNumVsGeneralInfoDict, "INTEGRATION_ERROR", "Unknown process integration error.");
            }
        }
    }
    allConfigs  = replace(allConfigs, "</PriceItemResponse><PriceItemResponse>","</PriceItemResponse>!@!<PriceItemResponse>");
    configArray = split(allConfigs, "!@!");

    for config in configArray {
        configDocNum        = "";
        ezPriceString       = "";
        fdPriceString       = "";          // [US 1212] Assume no Field Discretion levels returned
        appliedPromoString  = "";
        nrcWaiverString     = "";
        bundleMRCPromoCount = 1;          //US 2213: Fix to only ready bundle promo once for MRCPrice
        bundleNRCPromoCount = 1;          //US 2213: Fix to only ready bundle promo once for NRCPrice
        hasWaiverInfoList   = false;
        isAggregate         = false;      // [US 1567] Used for caching data for aggregate billing calculations
        ezPriceStringArray  = String[];   // [US 1923] Create Array for ezPriceString
        for searchTag in listOfInnerTags {  //Get the line document number for each PriceItemResponse.
            outputXML         = config;
            dataInTag         = "";    
            blankTag          = "<" + searchTag + "/>";
            startTag          = "<" + searchTag + ">";
            startTagWithExtra = "<" + searchTag + " ";
            endTag            = "</" + searchTag + ">";
            
            startLen = len(startTag);
            endLen   = len(endTag);

            if(find(outputXML, blankTag) <> -1){
                dataInTag = "";
            }
            elif((find(outputXML, startTag) <> -1) AND (find(outputXML, endTag) <> -1)){
                dataInTag = substring(outputXML, find(outputXML, startTag) + startLen, find(outputXML, endTag));
            }
            elif((find(outputXML, startTagWithExtra) <> -1) AND (find(outputXML, endTag) <> -1)){
                temp = substring(outputXML, find(outputXML, startTagWithExtra) +  startLen, find(outputXML, endTag)); 
                pos = find(temp,">");
                dataInTag = substring(temp, pos + 1, len(temp));
            }
            else{
                dataInTag = "NULL";
            }
            
            if(searchTag == "LineId") {
                configDocNum = dataInTag;
                if (containskey(docNumVsAggBillInfoDict, configDocNum + ":IsAggregate") AND
                    get(docNumVsAggBillInfoDict, configDocNum + ":IsAggregate") == "true") {
                    isAggregate = true;
                }
            }
            elif(searchTag == "PricingMessageList" AND upper(dataInTag) <> "NULL") {
                messageInTag = "";
                addMsgInTag = "";
                statusStartTag = "<Status>";
                statusEndTag   = "</Status>";
                codeStartTag = "<Code>";
                codeEndTag   = "</Code>";
                messageStartTag = "<Message>";
                messageEndTag   = "</Message>";
                if(find(dataInTag, "<AdditionalMessage/>") <> -1){
                    addMsgInTag = "";
                }
                elif(find(dataInTag, "<AdditionalMessage>") <> -1){
                    additionalMsgStartTag = "<AdditionalMessage>";
                    additionalMsgEndTag   = "</AdditionalMessage>";
                    addMsgInTag = substring(dataInTag, find(dataInTag, additionalMsgStartTag) + len(additionalMsgStartTag), find(dataInTag, additionalMsgEndTag));
                }
                statusInTag = substring(dataInTag, find(dataInTag, statusStartTag) + len(statusStartTag), find(dataInTag, statusEndTag));
                codeInTag = substring(dataInTag, find(dataInTag, codeStartTag) + len(codeStartTag), find(dataInTag, codeEndTag));
                messageInTag = substring(dataInTag, find(dataInTag, messageStartTag) + len(messageStartTag), find(dataInTag, messageEndTag));
                put(docNumVsPriceResponseDict, configDocNum + ":MSGSTATUS", statusInTag);
                put(docNumVsPriceResponseDict, configDocNum + ":MSGCODE", codeInTag);
                put(docNumVsPriceResponseDict, configDocNum + ":MSG", messageInTag);
                if(addMsgInTag <> ""){
                    put(docNumVsPriceResponseDict, configDocNum + ":MSG", messageInTag + "<br><br>" + addMsgInTag);
                }
            }
            elif((searchTag == "ItemAttributeList") AND (dataInTag <> "") AND (upper(dataInTag) <> "NULL")) {
                // [US 637] Handle loop tracking id in response
                // Generic solution in the future, for now look for Name = "LL_TRACK_ID"
                attrNameStartTag = "<Name>";
                attrNameEndTag = "</Name>";
                attrValStartTag = "<Value>";
                attrValEndTag = "</Value>";
                attrNameInTag = substring(dataInTag,
                    find(dataInTag, attrNameStartTag) + len(attrNameStartTag),
                    find(dataInTag, attrNameEndTag));
                if (attrNameInTag == "LL_TRACK_ID") {
                    attrValueInTag = substring(dataInTag,
                        find(dataInTag, attrValStartTag) + len(attrValStartTag),
                        find(dataInTag, attrValEndTag));
                    put(docNumVsPriceResponseDict, configDocNum + ":LL_TRACK_ID", attrValueInTag);
                }
            }
            elif ((searchTag == "FDPricingInfoList") AND (dataInTag <> "") AND (upper(dataInTag) <> "NULL")) {
                // [US 1212] Extract the FD levels for this part.  COntent of dataInTag should be one ore more
                // <FDPricingInfo><FDLevel>Level 1</FDLevel><FDLimit>185.00</FDLimit></FDPricingInfo>
                dataInTag = replace(dataInTag, "</FDPricingInfo><FDPricingInfo>", "</FDPricingInfo>!@!<FDPricingInfo>");
                fdLevelStrings = split(dataInTag, "!@!");
                fdLevelCount = 0;
                for fdLevelString in fdLevelStrings {
                    fdLevel = substring(fdLevelString,
                        find(fdLevelString, "<FDLevel>") + 9,
                        find(fdLevelString, "</FDLevel>"));
                    fdLimit = substring(fdLevelString,
                        find(fdLevelString, "<FDLimit>") + 9,
                        find(fdLevelString, "</FDLimit>"));
                    if (fdLevelCount > 0) {
                        fdPriceString = fdPriceString + "^=^";
                    }
                    fdPriceString = fdPriceString + fdLevel + "^-^" + fdLimit;
                    fdLevelCount = fdLevelCount + 1;
                }
            }
        }
        //US 605: Get all the ItemPriceList's within a PriceItemResponse.
        config = replace(config, "</ItemPriceList><ItemPriceList>","</ItemPriceList>!@!<ItemPriceList>");
        allItemPriceLists = split(config, "!@!");
        for each in allItemPriceLists{//loop through all the "ItemPriceList" tags to gather the correct info for EZ pricing.
            ezLevel                 = "";
            modTypeInTag            = "";
            mrcPromoCodeInTag       = "";
            ezEligibilty            = "";
            mrcFinalInTag           = "";
            nrcFinalInTag           = "";
            for searchTag in listOfPriceListTags {
                outputXML         = each;
                dataInTag         = "";    
                blankTag          = "<" + searchTag + "/>";
                startTag          = "<" + searchTag + ">";
                startTagWithExtra = "<" + searchTag + " ";
                endTag            = "</" + searchTag + ">";
                
                startLen = len(startTag);
                endLen   = len(endTag);

                if(find(outputXML, blankTag) <> -1){
                    dataInTag = "";
                }
                elif((find(outputXML, startTag) <> -1) AND (find(outputXML, endTag) <> -1)){
                    dataInTag = substring(outputXML, find(outputXML, startTag) + startLen, find(outputXML, endTag));
                }
                elif((find(outputXML, startTagWithExtra) <> -1) AND (find(outputXML, endTag) <> -1)){
                    temp = substring(outputXML, find(outputXML, startTagWithExtra) +  startLen, find(outputXML, endTag)); 
                    pos = find(temp,">");
                    dataInTag = substring(temp, pos + 1, len(temp));
                }
                else{
                    dataInTag = "NULL";
                }
                if(searchTag == "MRCPrice" AND upper(dataInTag) <> "NULL") {
                    mrcListStartTag     = "<ItemListPrice>";
                    mrcListEndTag       = "</ItemListPrice>";
                    mrcFinalStartTag    = "<ItemFinalPrice>";
                    mrcFinalEndTag      = "</ItemFinalPrice>";
                    icbFlagStartTag     = "<ICBFlag>";
                    icbFlagEndTag       = "</ICBFlag>";
                    promoCodeStartTag   = "<ModifierCode>";
                    promoCodeEndTag     = "</ModifierCode>";
                    modTypeStartTag     = "<ModifierType>";
                    modTypeEndTag       = "</ModifierType>";
                    mrcIcbFlagInTag     = "";
                    mrcPromoCodeInTag   = "";
                    modTypeInTag        = "";
                    volDiscValInTag     = "";
                    promoValInTag       = "";
                    mrcListInTag = substring(dataInTag, find(dataInTag, mrcListStartTag) + len(mrcListStartTag), find(dataInTag, mrcListEndTag));
                    mrcFinalInTag = substring(dataInTag, find(dataInTag, mrcFinalStartTag) + len(mrcFinalStartTag), find(dataInTag, mrcFinalEndTag));
                    // [JGSmith: /4/05/13]  Price response may not contain an ICB flag so search for it first
                    if (find(dataInTag, icbFlagStartTag) <> -1) {
                        mrcIcbFlagInTag = substring(dataInTag, find(dataInTag, icbFlagStartTag) + len(icbFlagStartTag), find(dataInTag, icbFlagEndTag)); 
                    }
                    if (find(dataInTag, promoCodeStartTag) <> -1) {//US 605: Get the EZ Promo codes
                        mrcPromoCodeInTag = substring(dataInTag, find(dataInTag, promoCodeStartTag) + len(promoCodeStartTag), find(dataInTag, promoCodeEndTag)); 
                    }
                    if (find(dataInTag, modTypeStartTag) <> -1) {
                        modTypeInTag = substring(dataInTag, find(dataInTag, modTypeStartTag) + len(modTypeStartTag), find(dataInTag, modTypeEndTag)); 
                    }
                    //US 1210 : Check for a Bundle Promo in the PriceModifier tags <TODO: Get the correct value for bundle promo modifier type from ESL response>
                    //US 2213 : Fix to allow reading the MRC bundle promo type [Initial Promotion 1] only once from each PriceItemResponse. 
                    if(modTypeInTag == "Initial Promotion 1" AND bundleMRCPromoCount < 2){
                        promoStartTag      = "<ModifierValue>";
                        promoFinalEndTag   = "</ModifierValue>";
                        promoValInTag = substring(dataInTag, find(dataInTag, promoStartTag) + len(promoStartTag), find(dataInTag, promoFinalEndTag));
                        put(docNumVsPriceResponseDict, configDocNum + ":MRCLIST", mrcListInTag);
                        put(docNumVsPriceResponseDict, configDocNum + ":MRCFINAL", promoValInTag);// Set the MRC net value to the promo value.
                        put(docNumVsPriceResponseDict, configDocNum + ":MRCICBFLAG", mrcIcbFlagInTag);
                        put(docNumVsPriceResponseDict, configDocNum + ":INBUNDLE", "true");//flag the part containing bundle promo
                        //US 1265: Append MRC promo name as a string
                        appliedPromoString = appliedPromoString + "MRC^-^" + modTypeInTag + "^=^";
                        // printconfigDocNum + ": Found promotion; setting MRC (list, final) prices to " + mrcListInTag + ", " + promoValInTag;
                        // print"MRC ICB flag is " + mrcIcbFlagInTag;
                        bundleMRCPromoCount = bundleMRCPromoCount + 1;
                    }
                    else {
                        // [US 1103] Always save both revenue discount price data (if available in the response) and regular list
                        //US 1257: volume discounted value as List MRC
                        if(modTypeInTag == "Revenue Discount"){
                            volDiscStartTag      = "<ModifierValue>";
                            volDiscFinalEndTag   = "</ModifierValue>";
                            volDiscValInTag = substring(dataInTag, find(dataInTag, volDiscStartTag) + len(volDiscStartTag), find(dataInTag, volDiscFinalEndTag));
                            // [US 1103] Added REVDISC_ prefix - don't store in MRCLIST as we don't yet know which source we should be using
                            put(docNumVsPriceResponseDict, configDocNum + ":REVDISC_MRCLIST", volDiscValInTag);
                            put(docNumVsPriceResponseDict, configDocNum + ":REVDISC_MRCFINAL", volDiscValInTag);
                            put(docNumVsPriceResponseDict, configDocNum + ":REVDISC_MRCICBFLAG", mrcIcbFlagInTag);
                        }
                        //US 1257- if we do not find a price modifier, just return ItemListPrice as List and Net.
                        if(modTypeInTag <> "EZPricing" AND modTypeInTag <> "Initial Promotion 1"){
                            // [US 1103] Added ACTUAL_ prefix; see above
                            put(docNumVsPriceResponseDict, configDocNum + ":ACTUAL_MRCLIST", mrcListInTag);
                            put(docNumVsPriceResponseDict, configDocNum + ":ACTUAL_MRCFINAL", mrcListInTag);
                            put(docNumVsPriceResponseDict, configDocNum + ":ACTUAL_MRCICBFLAG", mrcIcbFlagInTag);
                        }
                    }
                    // [US 1567] For aggregate billed parts just capture MRC
                    if (isAggregate) {
                        put(docNumVsAggBillInfoDict, configDocNum + ":MRC", mrcFinalInTag);
                    }
                }
                elif(searchTag == "NRCPrice" AND upper(dataInTag) <> "NULL") {
                    nrcListStartTag     = "<ItemListPrice>";
                    nrcListEndTag       = "</ItemListPrice>";
                    nrcFinalStartTag    = "<ItemFinalPrice>";
                    nrcFinalEndTag      = "</ItemFinalPrice>";
                    icbFlagStartTag     = "<ICBFlag>";
                    icbFlagEndTag       = "</ICBFlag>";
                    promoCodeStartTag   = "<ModifierCode>";
                    promoCodeEndTag     = "</ModifierCode>";
                    modTypeStartTag     = "<ModifierType>";
                    modTypeEndTag       = "</ModifierType>";
                    nrcIcbFlagInTag     = "";
                    nrcPromoCodeInTag   = "";
                    modTypeInTag        = "";
                    volDiscValInTag     = "";
                    promoValInTag       = "";
                    nrcListInTag = substring(dataInTag, find(dataInTag, nrcListStartTag) + len(nrcListStartTag), find(dataInTag, nrcListEndTag));
                    nrcFinalInTag = substring(dataInTag, find(dataInTag, nrcFinalStartTag) + len(nrcFinalStartTag), find(dataInTag, nrcFinalEndTag));
                    // [JGSmith: /4/05/13]  Price response may not contain an ICB flag so search for it first
                    if (find(dataInTag, icbFlagStartTag) <> -1) {
                        nrcIcbFlagInTag = substring(dataInTag, find(dataInTag, icbFlagStartTag) + len(icbFlagStartTag), find(dataInTag, icbFlagEndTag)); 
                    }
                    if (find(dataInTag, promoCodeStartTag) <> -1) {//US 605
                        nrcPromoCodeInTag = substring(dataInTag, find(dataInTag, promoCodeStartTag) + len(promoCodeStartTag), find(dataInTag, promoCodeEndTag)); 
                    }
                    if (find(dataInTag, modTypeStartTag) <> -1) {
                        modTypeInTag = substring(dataInTag, find(dataInTag, modTypeStartTag) + len(modTypeStartTag), find(dataInTag, modTypeEndTag)); 
                    }
                    //US 1210 : Check for a Bundle Promo in the PriceModifier tags <TODO: Get the correct value for bundle promo modifier type from ESL response>
                    //US 2213 : Fix to allow reading the NRC bundle promo type [Initial Promotion 1] only once from each PriceItemResponse.
                    if(modTypeInTag == "Initial Promotion 1" AND bundleNRCPromoCount < 2){
                        promoStartTag      = "<ModifierValue>";
                        promoFinalEndTag   = "</ModifierValue>";
                        promoValInTag = substring(dataInTag, find(dataInTag, promoStartTag) + len(promoStartTag), find(dataInTag, promoFinalEndTag));
                        put(docNumVsPriceResponseDict, configDocNum + ":NRCLIST", nrcListInTag);
                        put(docNumVsPriceResponseDict, configDocNum + ":NRCFINAL", promoValInTag);// Set the NRC net value to the promo value.
                        put(docNumVsPriceResponseDict, configDocNum + ":NRCICBFLAG", nrcIcbFlagInTag);
                        put(docNumVsPriceResponseDict, configDocNum + ":INBUNDLE", "true"); //flag the part containing bundle promo
                        //US 1265: Append NRC promo name as a string
                        appliedPromoString = appliedPromoString + "NRC^-^" + modTypeInTag + "^=^";
                        // printconfigDocNum + ": Found promotion; setting NRC (list, final) prices to " + nrcListInTag + ", " + promoValInTag;
                        bundleNRCPromoCount = bundleNRCPromoCount + 1;
                    }
                    else {
                        // [US 1103] Always save both revenue discount price data (if available in the response) and regular list
                        //US 1257: volume discounted value as List MRC
                        if(modTypeInTag == "Revenue Discount"){
                            volDiscStartTag      = "<ModifierValue>";
                            volDiscFinalEndTag   = "</ModifierValue>";
                            volDiscValInTag = substring(dataInTag, find(dataInTag, volDiscStartTag) + len(volDiscStartTag), find(dataInTag, volDiscFinalEndTag));
                            // [US 1103] Added REVDISC_ prefix; see above
                            put(docNumVsPriceResponseDict, configDocNum + ":REVDISC_NRCLIST", volDiscValInTag);
                            put(docNumVsPriceResponseDict, configDocNum + ":REVDISC_NRCFINAL", volDiscValInTag);
                            put(docNumVsPriceResponseDict, configDocNum + ":REVDISC_NRCICBFLAG", nrcIcbFlagInTag);
                        }
                        //US 1257- if we do not find a price modifier, just return ItemListPrice as List and Net.
                        if(modTypeInTag <> "EZPricing" AND modTypeInTag <> "Initial Promotion 1"){
                            // [US 1103] Added ACTUAL_ prefix; see above
                            // Added duplicate check since we get multiple NRCs with no modifiers for the EZ levels
                            if (NOT containskey(docNumVsPriceResponseDict, configDocNum + ":ACTUAL_NRCLIST")) {
                                put(docNumVsPriceResponseDict, configDocNum + ":ACTUAL_NRCLIST", nrcListInTag);
                                put(docNumVsPriceResponseDict, configDocNum + ":ACTUAL_NRCFINAL", nrcFinalInTag);
                                put(docNumVsPriceResponseDict, configDocNum + ":ACTUAL_NRCICBFLAG", nrcIcbFlagInTag);
                            }
                        }
                    }
                }
                elif(searchTag == "EZPricingInfo" AND upper(dataInTag) <> "NULL") {//US 605: parse the EZPricingInfo
                    ezLevelStartTag         = "<EZLevel>";
                    ezLevelEndTag           = "</EZLevel>";
                    ezEligibiltyStartTag    = "<EZEligibility>";
                    ezEligibiltyEndTag      = "</EZEligibility>";
                    ezEligibilty            = "";
                    ezLevel = substring(dataInTag, find(dataInTag, ezLevelStartTag) + len(ezLevelStartTag), find(dataInTag, ezLevelEndTag));
                    ezEligibilty = substring(dataInTag, find(dataInTag, ezEligibiltyStartTag) + len(ezEligibiltyStartTag), find(dataInTag, ezEligibiltyEndTag));
                    // [US 1567] For aggregate billed parts capture EZ level
                    if (isAggregate) {
                        put(docNumVsAggBillInfoDict, configDocNum + ":EZLevel", ezLevel);
                    }
                }
                elif(searchTag == "WaiverInfoList" AND upper(dataInTag) <> "NULL" AND NOT(hasWaiverInfoList)) {//US 1350: NRC Waivers
                    waiversList       = replace(dataInTag, "</WaiverInfo><WaiverInfo>","</WaiverInfo>#@#<WaiverInfo>");
                    allwaiverInfoTags = split(waiversList, "#@#");
                    for waiver in allwaiverInfoTags{
                        if(find(waiver, "<NRCPrice>") <> -1 AND find(waiver, "</NRCPrice>") <> -1){
                            waiverCodeStartTag          = "<ModifierCode>";
                            waiverCodeEndTag            = "</ModifierCode>";
                            waiverTypeStartTag          = "<ModifierType>";
                            waiverTypeEndTag            = "</ModifierType>";
                            waiverPriceStartTag         = "<ModifierValue>";
                            waiverPriceEndTag           = "</ModifierValue>";
                            waiverEligibiltyStartTag    = "<NRCWaiverEligibility>";
                            waiverEligibiltyEndTag      = "</NRCWaiverEligibility>";
                            waiverCode                  = "";
                            waiverType                  = "";
                            waiverPrice                 = "";
                            waiverEligibility           = "";
                            
                            if (find(waiver, waiverCodeStartTag) <> -1) {
                                waiverCode = substring(waiver, find(waiver, waiverCodeStartTag) + len(waiverCodeStartTag), find(waiver, waiverCodeEndTag)); 
                            }
                            if (find(waiver, waiverTypeStartTag) <> -1) {
                                waiverType = substring(waiver, find(waiver, waiverTypeStartTag) + len(waiverTypeStartTag), find(waiver, waiverTypeEndTag)); 
                            }
                            if (find(waiver, waiverPriceStartTag) <> -1) {
                                waiverPrice = substring(waiver, find(waiver, waiverPriceStartTag) + len(waiverPriceStartTag), find(waiver, waiverPriceEndTag)); 
                            }
                            if (find(waiver, waiverEligibiltyStartTag) <> -1) {
                                waiverEligibility = substring(waiver, find(waiver, waiverEligibiltyStartTag) + len(waiverEligibiltyStartTag), find(waiver, waiverEligibiltyEndTag)); 
                            }
                            nrcWaiverString = nrcWaiverString + waiverPrice + "^-^" + waiverCode + "^-^" + waiverEligibility + "^=^";
                        }
                    }
                    hasWaiverInfoList = true;    
                }   
            }
            //US 605 : Create the EZPrice String to be used to apply the levels to each applicable line.
            if(ezLevel <> ""){
                //ezPriceString = ezPriceString + ezLevel + "^-^" + mrcPromoCodeInTag + "^-^" + ezEligibilty + "^-^" + mrcFinalInTag + "^-^" + nrcFinalInTag + "^=^";
                //US 1923 :  Appending EZ Levels to ezPrice String to be sorted later
                append (ezPriceStringArray, ezLevel + "^-^" + mrcPromoCodeInTag + "^-^" + ezEligibilty + "^-^" + mrcFinalInTag + "^-^" + nrcFinalInTag + "^=^");
            }
        }
        
        //US 1923 : Sort ezPriceStringArr Alphabetically and append to ezPriceString
        sortedEzPriceArray = sort ( ezPriceStringArray );       
        for each in sortedEzPriceArray{     
            ezPriceString = ezPriceString + each;       
        }   
        
        nrcWaiverString = substring(nrcWaiverString, 0, len(nrcWaiverString) - 3);
        ezPriceReturnStr    = ezPriceReturnStr + configDocNum + "~ctlEzPriceString_line~" + ezPriceString + "|";
        fdPriceReturnStr    = fdPriceReturnStr + configDocNum + "~ctlFdPriceString_line~" + fdPriceString + "|";    // [US 1212]
        promoNameReturnStr  = promoNameReturnStr + configDocNum + "~ctlPromotionsApplied_line~" + substring(appliedPromoString, 0, len(appliedPromoString)-3) + "|"; 
        nrcWaiverReturnStr  = nrcWaiverReturnStr + configDocNum + "~ctlNrcWaiverString_line~" + nrcWaiverString + "|"; //US 1350       
    }
    // [US 606] Count the parts so we can generate stubbed pricing messages for some parts
    nypPartCount = 0;


    for docNum in docNumArray {
        pricingSource       = "";
        eachPromo           = "";
        parentDoc           = "";           // [US 606]
        packageName         = "";           // [US 1266]
        newPricingSource    = "STD";
        messageText         = "";
        messageType         = "";           // [US 606]
        priceStatus         = "Valid";      // [US 606]
        msgStatus           = "";
        msgCode             = "";
        msgText             = "";
        missingPricingStatus= "";
        prettyDesc          = "";    
        if(containskey(docNumKeyVsLineValueDict, docNum+ ":PRICINGSRC")){
            pricingSource = get(docNumKeyVsLineValueDict, docNum+ ":PRICINGSRC");
        }
        if(containskey(docNumKeyVsLineValueDict, docNum + ":EZPROMO")){
            eachPromo = get(docNumKeyVsLineValueDict, docNum + ":EZPROMO");// TODO: Apply this promo to all applicable lines
        }
        if(containskey(docNumKeyVsLineValueDict, docNum + ":PARENTDOC")){  // [US 718]
            parentDoc = get(docNumKeyVsLineValueDict, docNum + ":PARENTDOC");
        }
        if(containskey(docNumKeyVsLineValueDict, docNum + ":PACKAGE")){    // [US 1266]
            packageName = get(docNumKeyVsLineValueDict, docNum + ":PACKAGE");
        }
        if(containskey(docNumKeyVsLineValueDict, docNum + ":PRICE_STATUS")){ //8-11 (SP - Bug Fix)
            missingPricingStatus = get(docNumKeyVsLineValueDict, docNum + ":PRICE_STATUS");
        }
        
        // print docNum + ": Processing " + packageName;
        // print"Existing source is " + pricingSource;
        if((pricingSource == "NYP") OR (pricingSource == "ERR" AND missingPricingStatus == "POM")){
            //Only perform the below for NYP parts - Swapnil P (and ERR parts - JGS)
            returnedMRC         = 0.0;
            returnedNetMRC      = 0.0;
            returnedNRC         = 0.0;
            returnedNetNRC      = 0.0;
            mrcIsICB            = false;
            nrcIsICB            = false;
            icbMsg              = "";
            icbAddnMsg          = "";
            foundPricingForPart = false;            // JGS 04/15/13: handle missing pricing
            InBundle            = false;
            sourceForListMRC    = "LIST";           // [US 1103] Default is to use the list price as list
            sourceForListNRC    = "LIST";
            
            // [US 1567] Only do the price code if the part is not aggregate; otherwise the defaults above will work
            if (containskey(docNumVsAggBillInfoDict, docNum + ":IsAggregate")) {
                foundPricingForPart = true;  // We will fix this later if necessary but for now assume we have pricing for agg billed parts
            }
            else {
                if (containsKey(docNumVsPriceResponseDict, docNum + ":SOURCEFORLIST")) {
                    // Which source value should be used as the list price for this part?  (Convert to upper case, just to be sure)
                    sourceForListMRC = upper(get(docNumVsPriceResponseDict, docNum + ":SOURCEFORLIST"));
                    sourceForListNRC = sourceForListMRC;
                }

                //Check if part has a bundle promo..
                if(containskey(docNumVsPriceResponseDict, docNum + ":INBUNDLE") AND get(docNumVsPriceResponseDict, docNum + ":INBUNDLE") == "true"){
                    InBundle = true;
                }
                // [US 1103] Determine which price to use, based on the configured value of sourceToUseForList
                // [JGS: 8/6/13] Bug fix - do not use indicated source if the part has the bundle flag set to true as it
                // will have bundle pricing and this should override the indicated source.
                if (not InBundle) {
                    // Copy the appropriate price into the "Docnum + :MRCLIST" and "Docnum + :NRCLIST" entries in the dictionary
                    // print docNum + ": Source to use is " + sourceForListMRC;
                    if (startswith(sourceForListMRC, "EZ ")) {
                        // If we have EZ levels, we will have a dollar MRC and NRC for the specified level
                        ezLevelToUseAsSource = substring(sourceForListMRC, 3, 4);
                        ezPriceReturnStrArray = split(ezPriceReturnStr, "|");
                        foundEzDataForThisDocuNum = false;
                        for item in ezPriceReturnStrArray{
                            if(startswith(item, docNum + "~")){
                                // print docNum + ": Found EZ data for doc: " + item;
                                ezPriceInfo   = split(item, "~ctlEzPriceString_line~");
                                ezPriceLevels = split(ezPriceInfo[1], "^=^");
                                ezListMrc = "Not Found";  // So we can tell if we didn't find the required level
                                ezListNrc = "Not Found";
                                for level in ezPriceLevels{
                                    if(startswith(level, ezLevelToUseAsSource + "^-^")){
                                        // print docNum + ": Found EZ level " + ezLevelToUseAsSource + " data: " + ezLevelToUseAsSource;
                                        ezElements = split(level, "^-^");
                                        if(NOT isnull(ezElements[3]) AND ezElements[3] <> ""){
                                            ezListMrc = ezElements[3];
                                        }
                                        if(NOT isnull(ezElements[4]) AND ezElements[4] <> ""){
                                            ezListNrc = ezElements[4];
                                        }
                                    }
                                }
                                if ((ezListMrc <> "Not Found") AND (ezListNrc <> "Not Found")) {
                                    foundEzDataForThisDocuNum = true;
                                    put(docNumVsPriceResponseDict, docNum + ":MRCLIST", ezListMrc);
                                    put(docNumVsPriceResponseDict, docNum + ":MRCFINAL", ezListMrc);
                                    put(docNumVsPriceResponseDict, docNum + ":MRCICBFLAG", "false");
                                    put(docNumVsPriceResponseDict, docNum + ":NRCLIST", ezListNrc);
                                    put(docNumVsPriceResponseDict, docNum + ":NRCFINAL", ezListNrc);
                                    put(docNumVsPriceResponseDict, docNum + ":NRCICBFLAG", "false");
                                    // print docNum + ": Stored prices; MRC: " + ezListMrc + "; NRC: " + ezListNrc;
                                    // Is a promo assigned to this line that comes before the one configured to be list source?
                                    allEzPromos = "ABCDEFGHIJKLMNO";
                                    if (find(allEzPromos, eachPromo) <= find(allEzPromos, ezLevelToUseAsSource)) {
                                        // Clear this promo
                                        eachPromo = "";
                                        otherAttributesString = otherAttributesString + docNum + "~ctlEzPromoCode_line~|";
                                    }
                                }
                                break;
                            }
                        }
                        if (NOT foundEzDataForThisDocuNum) {
                            // No EZ data for this line, so need to back out to try to use revenue/volume discount data
                            sourceForListMRC = "VOLUME DISCOUNT";
                            sourceForListNRC = "VOLUME DISCOUNT";
                            // print "EZ level data not found, reverting to volume discount";
                        }
                    }
                    // print docNum + ": Final source to use is " + sourceForListMRC;
                    if (sourceForListMRC == "VOLUME DISCOUNT") {
                        if (containsKey(docNumVsPriceResponseDict, docNum + ":REVDISC_MRCLIST")) {
                            put(docNumVsPriceResponseDict, docNum + ":MRCLIST", get(docNumVsPriceResponseDict, docNum + ":REVDISC_MRCLIST"));
                            put(docNumVsPriceResponseDict, docNum + ":MRCFINAL", get(docNumVsPriceResponseDict, docNum + ":REVDISC_MRCFINAL"));
                            put(docNumVsPriceResponseDict, docNum + ":MRCICBFLAG", get(docNumVsPriceResponseDict, docNum + ":REVDISC_MRCICBFLAG"));
                        }
                        else {
                            sourceToUseForListMRC = "LIST";
                        }
                    }
                    if (sourceForListMRC == "LIST") {
                        put(docNumVsPriceResponseDict, docNum + ":MRCLIST", get(docNumVsPriceResponseDict, docNum + ":ACTUAL_MRCLIST"));
                        put(docNumVsPriceResponseDict, docNum + ":MRCFINAL", get(docNumVsPriceResponseDict, docNum + ":ACTUAL_MRCFINAL"));
                        put(docNumVsPriceResponseDict, docNum + ":MRCICBFLAG", get(docNumVsPriceResponseDict, docNum + ":ACTUAL_MRCICBFLAG"));
                    }
                    if (sourceForListNRC == "VOLUME DISCOUNT") {
                        if (containsKey(docNumVsPriceResponseDict, docNum + ":REVDISC_NRCLIST")) {
                            put(docNumVsPriceResponseDict, docNum + ":NRCLIST", get(docNumVsPriceResponseDict, docNum + ":REVDISC_NRCLIST"));
                            put(docNumVsPriceResponseDict, docNum + ":NRCFINAL", get(docNumVsPriceResponseDict, docNum + ":REVDISC_NRCFINAL"));
                            put(docNumVsPriceResponseDict, docNum + ":NRCICBFLAG", get(docNumVsPriceResponseDict, docNum + ":REVDISC_NRCICBFLAG"));
                        }
                        else {
                            sourceForListNRC = "LIST";
                        }
                    }
                    if (sourceForListNRC == "LIST") {
                        put(docNumVsPriceResponseDict, docNum + ":NRCLIST", get(docNumVsPriceResponseDict, docNum + ":ACTUAL_NRCLIST"));
                        put(docNumVsPriceResponseDict, docNum + ":NRCFINAL", get(docNumVsPriceResponseDict, docNum + ":ACTUAL_NRCFINAL"));
                        put(docNumVsPriceResponseDict, docNum + ":NRCICBFLAG", get(docNumVsPriceResponseDict, docNum + ":ACTUAL_NRCICBFLAG"));
                    }
                }
                
                //US 698:Add response values from service to pricing string
                if(containskey(docNumVsPriceResponseDict, docNum +":MRCLIST") AND get(docNumVsPriceResponseDict, docNum +":MRCLIST") <> "" AND isnumber(get(docNumVsPriceResponseDict, docNum +":MRCLIST"))){
                    returnedMRC = atof(get(docNumVsPriceResponseDict, docNum +":MRCLIST"));
                    // print docNum + ": Found MRC pricing";
                    foundPricingForPart = true;
                }
                if(containskey(docNumVsPriceResponseDict, docNum +":MRCFINAL") AND get(docNumVsPriceResponseDict, docNum +":MRCFINAL") <> "" AND isnumber(get(docNumVsPriceResponseDict, docNum +":MRCFINAL"))){
                    returnedNetMRC = atof(get(docNumVsPriceResponseDict, docNum +":MRCFINAL"));
                }
                if(containskey(docNumVsPriceResponseDict, docNum +":NRCLIST") AND get(docNumVsPriceResponseDict, docNum +":NRCLIST") <> "" AND isnumber(get(docNumVsPriceResponseDict, docNum +":NRCLIST"))){
                    returnedNRC = atof(get(docNumVsPriceResponseDict, docNum +":NRCLIST"));
                    // print docNum + ": Found NRC pricing";
                    foundPricingForPart = true;
                }
                if(containskey(docNumVsPriceResponseDict, docNum +":NRCFINAL") AND get(docNumVsPriceResponseDict, docNum +":NRCFINAL") <> "" AND isnumber(get(docNumVsPriceResponseDict, docNum +":NRCFINAL"))){
                    returnedNetNRC = atof(get(docNumVsPriceResponseDict, docNum +":NRCFINAL"));
                }
                // [US 765] Check for ICB pricing on either MRC or NRC and generate an appropriate message
                overrideICB = false;
                // [US 1266] Override the ICB flag if in a bundle and DB identifies this part
                if (InBundle) {
                    rows = bmql("SELECT OverrideICBInBundle from ctlSvcPkgMaster WHERE SvcPkgName = $packageName");
                    for row in rows {
                        if (get(row, "OverrideICBInBundle") == "1") {
                            // print docNum + ": Overriding ICB pricing because of bundle";
                            overrideICB = true;
                        }
                    }
                }
                if(containskey(docNumVsPriceResponseDict, docNum +":MRCICBFLAG") AND (get(docNumVsPriceResponseDict, docNum +":MRCICBFLAG") == "true")){
                    // print"MRC is ICB";
                    // US 765    - get the non- zero ICB price returned in a message
                    if(returnedMRC <> 0.0 ){
                        icbAddnMsg = icbAddnMsg + "[" + string(returnedMRC) + "] ";
                        returnedMRC     = 0.0;
                    }
                    if(returnedNetMRC <> 0.0){
                        icbAddnMsg = icbAddnMsg + "[" + string(returnedNetMRC) + "] ";
                        returnedNetMRC  = 0.0;
                    }
                    if(NOT overrideICB){
                        mrcIsICB = true;
                    }
                }
                if(containskey(docNumVsPriceResponseDict, docNum +":NRCICBFLAG") AND (get(docNumVsPriceResponseDict, docNum +":NRCICBFLAG") == "true")){
                    // print"NRC is ICB";
                    // US 765 - get the non- zero ICB price returned in a message
                    if(returnedNRC <> 0.0 ){
                        icbAddnMsg = icbAddnMsg + "[" + string(returnedNRC) + "] ";
                        returnedNRC     = 0.0;
                    }
                    if(returnedNetNRC <> 0.0){
                        icbAddnMsg = icbAddnMsg + "[" + string(returnedNetNRC) + "] ";
                        returnedNetNRC  = 0.0;
                    }
                    if(NOT overrideICB){
                        nrcIsICB = true;
                    }
                }
                // [US 637] Add local loop tracking id if any to response string
                if (containskey(docNumVsPriceResponseDict, docNum + ":LL_TRACK_ID")
                        AND (get(docNumVsPriceResponseDict, docNum + ":LL_TRACK_ID") <> "")) {
                    newTrackingId = get(docNumVsPriceResponseDict, docNum + ":LL_TRACK_ID");
                    otherAttributesString = otherAttributesString
                        + docNum + "~ctlLoopTrackingId_line~" + newTrackingId + "|";
                    // [US 1344] Code to update/insert tracking id in pretty description.  Add before "!$!NEWLINE!$!A Site:"
                    // [US 2301] Updated Pretty Description label for loop tracking id
                    prettyDesc = "";
                    if(containskey(docNumKeyVsLineValueDict, docNum + ":PRETTYDESC")){
                        prettyDesc = get(docNumKeyVsLineValueDict, docNum + ":PRETTYDESC");
                    }
                    if (find(prettyDesc, "!$!NEWLINE!$!A Site:") <> -1) {
                        // Only add the tracking id if we have an A site.  Otherwise things are broken somehow.
                        if (find(prettyDesc, "!$!NEWLINE!$!Loop/CNDC ID: ") <> -1) {
                            // Description already contains tracking id, so replace the content
                            prettyDesc = 
                                substring(prettyDesc, 0, find(prettyDesc, "!$!NEWLINE!$!Loop/CNDC ID: ") + 27) +
                                newTrackingId + 
                                substring(prettyDesc, find(prettyDesc, "!$!NEWLINE!$!A Site:"));
                            }
                        else {
                            // Insert the tracking id right before the A site address
                            prettyDesc = 
                                substring(prettyDesc, 0, find(prettyDesc, "!$!NEWLINE!$!A Site:")) +
                                "!$!NEWLINE!$!Loop/CNDC ID: " +
                                newTrackingId + 
                                substring(prettyDesc, find(prettyDesc, "!$!NEWLINE!$!A Site:"));
                        }
                        otherAttributesString = otherAttributesString
                            + docNum + "~displayDescription_line~" + prettyDesc + "|";
                    }
                }
                //US2133: Add IQ Transition promocode, if any, to pretty description.
                //put(docNumVsPriceResponseDict, each + ":IQ_TRANS_PROMO", iQTransPromoStr);
                if (containskey(docNumVsPriceResponseDict, docNum + ":IQ_TRANS_PROMO")
                    AND (get(docNumVsPriceResponseDict, docNum + ":IQ_TRANS_PROMO") <> "")
                    AND NOT isnull(get(docNumVsPriceResponseDict, docNum + ":IQ_TRANS_PROMO"))){
                    if(prettyDesc == ""){
                        if(containskey(docNumKeyVsLineValueDict, docNum + ":PRETTYDESC")){
                            prettyDesc = get(docNumKeyVsLineValueDict, docNum + ":PRETTYDESC");
                        }
                    }
                    iQTransPrettyStr = get(docNumVsPriceResponseDict, docNum + ":IQ_TRANS_PROMO");
                    iQTransPrettyStr = substring(iQTransPrettyStr, 0, len(iQTransPrettyStr) - 13);
                    if (find(prettyDesc, "!$!NEWLINE!$!A Site") <> -1) {
                        // Insert the transition promocode right before the A site address/ A site tracking Id
                        if (find(prettyDesc, "!$!NEWLINE!$!MRCPromoCode: ") <> -1) {
                            // Description already contains MRCPromoCode, so replace the content
                             prettyDesc = 
                                substring(prettyDesc, 0, find(prettyDesc, "!$!NEWLINE!$!MRCPromoCode: ") + 27) +
                                iQTransPrettyStr + 
                                substring(prettyDesc, find(prettyDesc, "!$!NEWLINE!$!A Site"));
                        }
                        else{
                            //Add the MRCPromoCode before A site
                            prettyDesc = 
                                substring(prettyDesc, 0, find(prettyDesc, "!$!NEWLINE!$!A Site")) +
                                "!$!NEWLINE!$!MRCPromoCode: "+
                                iQTransPrettyStr + 
                                substring(prettyDesc, find(prettyDesc, "!$!NEWLINE!$!A Site"));
                        }
                    }
                    else{
                        //else append to existing pretty descrition.
                        prettyDesc = prettyDesc + "!$!NEWLINE!$!MRCPromoCode: " + iQTransPrettyStr;
                    }
                 
                otherAttributesString = otherAttributesString + docNum + "~displayDescription_line~" + prettyDesc + "|";   
                } 
                
                if (mrcIsICB OR nrcIsICB) {
                    // If either MRC or NRC is ICB, then pricing source is ICB and status is POM
                    // print docNum + ": Either MRC or NRC is ICB (or both)";
                    newPricingSource = "ICB";
                    priceStatus = "POM";
                   
                    // Generate a message which identifies which price was ICB
                    icbMsg = " ICB priced.";
                    if(icbAddnMsg <> ""){
                        icbAddnMsg = "Values of "+ icbAddnMsg + " were returned by the pricing service.";
                    }
                    if (mrcIsICB) {
                        if (nrcIsICB) {
                            icbMsg = "Both MRC and NRC are" + icbMsg + icbAddnMsg;
                        } else {
                            icbMsg = "MRC is" + icbMsg + icbAddnMsg;
                        }
                    } else {
                        icbMsg = "NRC is" + icbMsg + icbAddnMsg;
                    }
                }
                
                if (newPricingSource == "") {
                    // If we already have a new pricing source, don't change it
                    newPricingSource = "STD";
                }
                // print "Currently (line 821) source is " + newPricingSource;
                // Set MRC, NRC, and other values to return from the values extracted from the XML response

                if ((eachPromo <> "") AND (eachPromo <> "NONE") AND NOT(InBundle)){
                    //US 605    - EZ promo is already selected on priced part, apply the appropriate EZ pricing level to those parts
                    ezPriceReturnStrArray = split(ezPriceReturnStr, "|");
                    for item in ezPriceReturnStrArray{
                        if(startswith(item, docNum + "~")){
                            ezPriceInfo   = split(item, "~ctlEzPriceString_line~");
                            ezPriceLevels = split(ezPriceInfo[1], "^=^");
                            for level in ezPriceLevels{
                                if(startswith(level, eachPromo + "^-^")){
                                    newPricingSource = "EZ";
                                    ezElements = split(level, "^-^");
                                    if(NOT isnull(ezElements[3]) AND ezElements[3] <> ""){
                                        returnedNetMRC = atof(ezElements[3]);
                                    }
                                    if(NOT isnull(ezElements[4]) AND ezElements[4] <> ""){
                                        returnedNetNRC = atof(ezElements[4]);
                                    }
                                }
                            }
                            break;
                        }
                        else{// if promo was found but ctlPricingString_line is empty, do not apply EZ and set source to STD.
                            if (newPricingSource == "") {
                                // If we already have a new pricing source, don't change it
                                // print "On line 850 - setting to STD";
                                newPricingSource = "STD";
                            }
                        }
                   }
                }
            }
            
            //US 603 : Get Pricing Messages, if any, for Local Loops.
            if(containskey(docNumVsPriceResponseDict, docNum +":MSGSTATUS") AND get(docNumVsPriceResponseDict, docNum +":MSGSTATUS") <> ""){
                msgStatus = get(docNumVsPriceResponseDict, docNum +":MSGSTATUS");
                messageType = msgStatus;
                if(upper(messageType) == "ERROR"){
                    priceStatus = "POM";
                    newPricingSource = "ERR";
                }    
            }
            if(containskey(docNumVsPriceResponseDict, docNum +":MSGCODE") AND get(docNumVsPriceResponseDict, docNum +":MSGCODE") <> ""){
                msgCode = get(docNumVsPriceResponseDict, docNum +":MSGCODE");
            }
            if(containskey(docNumVsPriceResponseDict, docNum +":MSG") AND get(docNumVsPriceResponseDict, docNum +":MSG") <> ""){
                msgText = get(docNumVsPriceResponseDict, docNum +":MSG");
            }
            if (messageType <> "") {
                messageText = msgStatus + "^=^" + msgCode + "^=^" + msgText;
            }
            // [JGS 04/15/13] If no pricing returned, no message, and not ICB, add an error message here
            if (NOT foundPricingForPart AND (messageText == "") AND (icbMsg =="")) {
                // print docNum + ": In no pricing error block";
                messageText = "ERROR^=^No Pricing^=^No pricing returned; please contact support";
                priceStatus = "POM";
                newPricingSource = "ERR";
            }
            // [US 765] Add ICB message, if any
            if (icbMsg <> "") {
                if (messageText <> "") {
                    messageText = messageText + "^-^";
                }
                messageText = messageText + "WARNING^=^ICB Pricing Returned^=^" + icbMsg;
                if (upper(messageType) <> "ERROR") {
                    messageType = "WARNING";
                }
            }
            // print "After all logic complete, source is " + newPricingSource;
            
            pricingString = docNum 
                + "^12!%!"
                + "pricing"         + "!%!"
                + "estCapEx"        + "$ATTR$" + ""                             + "$ROW$"
                + "estOpExAnnual"   + "$ATTR$" + ""                             + "$ROW$"
                + "estOpExMonthly"  + "$ATTR$" + ""                             + "$ROW$"
                + "MRCList"         + "$ATTR$" + string(returnedMRC)            + "$ROW$"
                + "MRCNet"          + "$ATTR$" + string(returnedNetMRC)         + "$ROW$"
                + "NRCList"         + "$ATTR$" + string(returnedNRC)            + "$ROW$"
                + "NRCNet"          + "$ATTR$" + string(returnedNetNRC)         + "$ROW$"
                + "retained"        + "$ATTR$" + ""                             + "$ROW$"
                + "errorMessage"    + "$ATTR$" + messageText                    + "$ROW$"
                + "status"          + "$ATTR$" + priceStatus                    + "!$!";//Updated the returned value from PXP to Valid : Swapnil P
          
            totalsString = docNum 
                + "^12!%!"
                + "total"           + "!%!"
                + "contractType"    + "$ATTR$" + newPricingSource   + "$ROW$"
                + "MRCThreshold"    + "$ATTR$" + ""                 + "$ROW$"
                + "NRCThreshold"    + "$ATTR$" + ""                 + "$ROW$"
                + "status"          + "$ATTR$" + "Valid" + "!$!";
                                
            put(docNumVsPricingStringsDict, docNum, pricingString);                  
            put(docNumVsTotalStringsDict, docNum, totalsString);
            
            otherAttributesString = otherAttributesString
                + docNum + "~priceMessageType_line~"    + messageType       + "|";
            
            // [US 606] Roll the message type up in the parent document dictionary
            if (parentDoc <> "") {
                if (NOT containsKey(messageTypePartToModel, parentDoc)) {
                    put(messageTypePartToModel, parentDoc, messageType);
                    append(parentDocuments, parentDoc);
                } elif (upper(messageType) == "ERROR") { 
                    put(messageTypePartToModel, parentDoc, messageType);
                } else {
                    parentType = get(messageTypePartToModel, parentDoc);
                    if ((parentType == "" OR upper(parentType) == "INFORMATION") AND (upper(messageType) == "WARNING")) {
                        put(messageTypePartToModel, parentDoc, messageType);
                    } elif ((parentType == "") AND (upper(messageType) == "INFORMATION")) {
                        put(messageTypePartToModel, parentDoc, messageType);
                    }
                }
            }
        }
    }
    
    if (sizeofarray(aggBillModelDocNumArray) > 0) {
        // [US 1567] Processing of aggregate billing.  Move to a utility once we can make use of the new BMI capability
        // When refactoring to a utility, need to pass aggBillModelDocNumArray and docNumVsAggBillInfoDict.  The contents and 
        // keys for these are identified in the comments above, where they are defined in this method
        // For now assume that we have "Aggregate Billing", and go fetch the percent of max levels
        percentMaxLevels = float[];
        percentMaxVsDiscountPercentDict = dict("float");
        productName = "Aggregate Billing";
        retTbl = bmql("SELECT percentOfMaxLevel, discountPercentage FROM ctlVirtualPortTiers WHERE productName = $productName");
        for row in retTbl {
            percentOfMax = atof(get(row, "percentOfMaxLevel"));
            discountPercent = atof(get(row, "discountPercentage"));
            append(percentMaxLevels, percentOfMax);
            put(percentMaxVsDiscountPercentDict, percentOfMax, discountPercent);
        }
        percentMaxLevels = sort(percentMaxLevels);
        // print "Aggregate billed part information is:";
        // print docNumVsAggBillInfoDict;
        secondsPerMonth = 30 * 24 * 60 * 60;        // Save as a constant to reduce calculations
        megabitsPerGigabyte = 8 * 1024;             // Same as above
        for aggModel in aggBillModelDocNumArray{
            // Extract the port numbers
            portListString = get(docNumVsAggBillInfoDict, aggModel + ":PartDocnumList");
            // print "Aggregate Billed Model " + aggModel + " has parts " + portListString;
            portDocNumList = split(portListString, ",");
            // Now collect the circuit speed/bandwidth, quantity, and MRC for each port associated with this model
            totalMtu = 0;           // Total maximum theoretical usage
            totalPortRevenue = 0.0; // Total term revenue for ports
            totalTermRevenue = 0.0; // Total term revenue for ports and loops combined
            modelEzLevel = "";      // EZ level at the model - displayed as the discretion level
            contractTerm = atoi(get(docNumVsAggBillInfoDict, aggModel + ":ContractTerm"));
            for portDocNum in portDocNumList {
                bandwidth = 0.0;
                quantity = 0;
                mrc = 0.0;
                portType = "";
                ezLevel = "";
                // Use the wan_bandwidth for now, but DS-1 is an outlier
                docOption = "";
                if(containskey(docNumVsAggBillInfoDict, portDocNum + ":WAN_BANDWID")){
                    wanBandwidthStr = get(docNumVsAggBillInfoDict, portDocNum + ":WAN_BANDWID");
                    if (wanBandwidthStr == "1500") {
                        wanBandwidthStr = "1.5";
                    }
                    if (isnumber(wanBandwidthStr)) {
                        bandwidth = atof(wanBandwidthStr);
                    }
                }
                if(containskey(docNumVsAggBillInfoDict, portDocNum + ":PORT_TYPE")){
                    portType = get(docNumVsAggBillInfoDict, portDocNum + ":PORT_TYPE");
                }
                if(containskey(docNumVsAggBillInfoDict, portDocNum + ":MRC")){
                    mrcStr = get(docNumVsAggBillInfoDict, portDocNum + ":MRC");
                    if (isnumber(mrcStr)) {
                        mrc = atof(mrcStr);
                    }
                }
                if(containskey(docNumVsAggBillInfoDict, portDocNum + ":EZLevel")){
                    ezLevel = get(docNumVsAggBillInfoDict, portDocNum + ":EZLevel");
                    // TODO: error if parts of a model have different ones
                    modelEzLevel= ezLevel;
                }
                if (containskey(docNumVsAggBillInfoDict, portDocNum + ":QUANTITY")) {
                    quantityString = get(docNumVsAggBillInfoDict, portDocNum + ":QUANTITY");
                    if (isnumber(quantityString)) {
                        quantity = atoi(quantityString);
                    }
                }
                print "Port " + portDocNum + " inputs:";
                print "  Bandwidth: " + string(bandwidth);
                print "  Quantity:  " + string(quantity);
                print "  MRC:       " + string(mrc);
                print "  EZ Level:  " + ezLevel;
                // TODO: error if data is missing
                // Keep a running total of the maximum theoretical usage
                mtuThisPort = bandwidth * secondsPerMonth / megabitsPerGigabyte;
                print "Port " + portDocNum + " calculated values:";
                print "  MTU (per port):     " + string(mtuThisPort);
                print "  Total Port MTU:     " + string(mtuThisPort * quantity);
                print "  Total Term Revenue: " + string(mrc * quantity * contractTerm);
                
                // Calculate the running totals for total MTU and total term revenue
                totalMtu = totalMtu + (mtuThisPort * quantity);
                totalPortRevenue = totalPortRevenue + (mrc * quantity * contractTerm);
                
                // Construct the encoded string for the attribute ctlPortInfo_line
                otherAttributesString = otherAttributesString
                    + portDocNum + "~ctlPortInfo_line~"
                    + portType + "^-^" 
                    + string(bandwidth) + "^-^" 
                    + string(quantity) + "|";
            }
            // Add in the total loop mrc for this group
            totalLoopMrc = 0;
            if (containskey(docNumVsAggBillInfoDict, aggModel + ":TotalLoopMrc")) {
                totalLoopMrcStr = get(docNumVsAggBillInfoDict, aggModel + ":TotalLoopMrc");
                if (isnumber(totalLoopMrcStr)) {
                    totalLoopMrc = atoi(totalLoopMrcStr);
                }
            }
            totalTermRevenue = totalPortRevenue + totalLoopMrc;
            monthlyRevenue = totalTermRevenue / contractTerm;
            print "Total MTU is: " + string(totalMtu);
            print "Total Term Revenue is: " + string(totalTermRevenue);
            print "Total Monthly revenue (" + string(contractTerm) + " month term) is: " + string(monthlyRevenue);
            // Next steo now that we have the totals is to calculate the contents of the usage table.  We loop over the % levels
            previousUsageMax = -1;      // To calculate the usage minimum at each level
            encodedUsageResults = "";
            for percentMax in percentMaxLevels {
                percentDiscount = get(percentMaxVsDiscountPercentDict, percentMax);
                print "Calculating for % of max level " + string(percentMax * 100) + "%; discount: " + string(percentDiscount * 100) + "%";
                discountedPortRevenue = totalPortRevenue * (1 - percentDiscount);
                monthlyDiscountedPortRevenue = discountedPortRevenue / contractTerm;
                totalMonthlyRevenue = monthlyDiscountedPortRevenue + totalLoopMrc;
                print "  Discounted port revenue:         " + string(discountedPortRevenue);
                print "  Monthly discounted port revenue: " + string(monthlyDiscountedPortRevenue);
                print "  Total monthly revenue:           " + string(totalMonthlyRevenue);
                usageMin = previousUsageMax + 1;
                usageMax = totalMtu * percentMax;
                previousUsageMax = usageMax;
                pricePerGigabyte = totalMonthlyRevenue / (percentMax * totalMtu);
                totalMrc = pricePerGigabyte * usageMax;
                encodedStringThisLevel =
                    string(percentMax * 100) + "%^-^" +
                    string(usageMin) + "^-^ to ^-^" +
                    string(round(usageMax, 0)) + "^-^$" +
                    string(round(pricePerGigabyte, 2)) + "^-^$" +
                    string(round(totalMrc, 0));
                if (encodedUsageResults <> "") {
                    encodedUsageResults = encodedUsageResults + "^#^";
                }
                encodedUsageResults = encodedUsageResults + encodedStringThisLevel;
            }
            print "Aggregate Billing usage table: " + encodedUsageResults;
            otherAttributesString = otherAttributesString
                + aggModel + "~ctlAgrbUsageTableStr_line~" + encodedUsageResults + "|"
                + aggModel + "~ctlEzPromoCode_line~" + modelEzLevel + "|";
        }
    }

    // [US 606] Add the rolled up parent document message type strings
    for parentDoc in parentDocuments {
        otherAttributesString = otherAttributesString
            + parentDoc + "~priceMessageType_line~" + get(messageTypePartToModel, parentDoc)    + "|";
    }

    put(docNumVsGeneralInfoDict, "RETURN_STRING", otherAttributesString + ezPriceReturnStr + fdPriceReturnStr + promoNameReturnStr + nrcWaiverReturnStr);

    // [US 718] Use the DEBUG key in general info to return the XML request
    // Only use this when debugging as it will be very expensive
    // We cannot display XML strings in a text area with a "CDATA" so we need to modify the XML
    //  - modifying "<![CDATA[data&_cd;" to "*<*data*>*"
    if (pricedItemCount > 0) {
        InputXML = replace(InputXML, "<![CDATA[", "*CDATA*");
        InputXML = replace(InputXML, "&_cd;", "*END*");
        // [JGS: 12/2/13] Commented out return of XML to reduce performance impacts on test and production
        //Uncommented by Swapnil P
        put(docNumVsGeneralInfoDict, "DEBUG", InputXML);
    }
}   // End of "if (pricedItemCount <> 0) "
else {
    put(docNumVsGeneralInfoDict, "DEBUG", "No parts needed pricing");
}

put(retDict, "PRICING_STRING", docNumVsPricingStringsDict);
put(retDict, "TOTAL_STRING", docNumVsTotalStringsDict);

// Time immediately before returning from the utility.  Put no code between this next block and the return statement
msTimeOnUtilityExit = getcurrenttimeinmillis();
msUtilityDuration    = msTimeOnUtilityExit - msTimeOnUtilityEntry;
if (msTimeOnSvcCallout <> -1 AND msTimeOnSvcReturn <> -1) {
    msSvcCalloutDuration = msTimeOnSvcReturn - msTimeOnSvcCallout;
}
put(docNumVsGeneralInfoDict, "INSTRUMENTATION", 
    "Total Utility Time^=^" + 
    string(msUtilityDuration) +
    "^-^Total Callout Time^=^" +
    string(msSvcCalloutDuration));
// End of code to compute and record instrumentation (timing)

put(retDict, "GENERAL_INFO", docNumVsGeneralInfoDict);      // Moved here so the instrumentation results can be returned
return retDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_ctlGetPricing_392706741]]></java_class_name><child_class_names></child_class_names><date_modified>1390601783000</date_modified><guid><![CDATA[testsavvis_279240807]]></guid><_children></_children></bm_function><bm_lib_func_param><id>392706743</id><bm_lib_func_id>392706742</bm_lib_func_id><param_name><![CDATA[keyVsQuoteValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1390601783000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_279240810]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706744</id><bm_lib_func_id>392706742</bm_lib_func_id><param_name><![CDATA[docNumArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1390601783000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_279240811]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706745</id><bm_lib_func_id>392706742</bm_lib_func_id><param_name><![CDATA[docNumKeyVsLineValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1390601783000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_279240812]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>191391260</id><name><en><![CDATA[Populate Dict For Non Array]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[populateDictForNonArray]]></variable_name><description><en><![CDATA[Based on templateID either inserts isDeletable attribute or action in the input dictionary addonVsAddonDataDict and return the same dictionary]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>18</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>191391259</function_id><main_script_text></main_script_text><date_modified>1358564319000</date_modified><guid><![CDATA[testsavvis_161412417]]></guid><_children><bm_function><id>191391259</id><ref_type>16</ref_type><script_text><![CDATA[//*********************************************************************************************************************
//** Function:    Populate Dict For Non Array (populateDictForNonArray)                                      	     **
//** Type:        Utility Library Function                                                                    	     **
//**                                                                                                          	     **
//** Description: Based on templateID either inserts isDeletable attribute or action attribute in the input          **
//**		  dictionary addonVsAddonDataDict and returns the same dictionary                 	   	     **
//**                                                                                                                 **
//** Parameters:  templateID - special offer id, has a value if the addon is imported from a special offer           **
//**              addon - name of the addon for which the function is called   					     **
//**              isDeletable - isDeletable attribute   						             **
//**              aip - aip id								                             **
//**              addonsSelectedArray - array of all the selected addons                                             **
//**              addonVsAddonDataDict - dictionary with key as addon name and value of isDeletable array attribute  **
//**                                     or action array attribute and addonArray                                    **
//**                                                                                                                 **
//** Return Type: string[] Dictionary - returns dictionary addonVsAddonDataDict with updated information             **
//**                                                                                                                 **
//** History:     Date     Author       Comment                                                                      **
//**              09/07/12 SKharche     New implementation to support Special Offer Is Deletable and Change scenario **
//**                                    Supports VER 62770                                                           **
//*********************************************************************************************************************

//If the input addon is not selected then if the templateID is NOT blank add the isDeletable attribute
//else add action attribute to the return dictionary

if(findinarray(addonsSelectedArray, addon) == -1 AND aip == "") {
	addonArray = string[];
	if(containskey(addonVsAddonDataDict, "addonArray")) {
		addonArray = get(addonVsAddonDataDict, "addonArray");
	}
	append(addonArray, addon);
	put(addonVsAddonDataDict, "addonArray", addonArray);
	 
	if(templateID <> "") {
		//For non array addon if isDeletable is blank then it is considered as 'No' and added to the temporary array so that it can be added to the dictionaries
		tempIsDeletableArray = string[];
		if(isDeletable == "") { tempIsDeletableArray[0] = "No"; }
		else { tempIsDeletableArray[0] = isDeletable; }
		put(addonVsAddonDataDict, addon, tempIsDeletableArray);
	}
	else {
		//For non array addon if AIP is NOT blank then it is considered as 'Change' and added to the temporary array so that it can be added to the dictionaries
		tempActionArray = string[];
		if(aip == "") { tempActionArray[0] = ""; }
		else { tempActionArray[0] = "Change"; }
		put(addonVsAddonDataDict, addon, tempActionArray);
	}	
}

return addonVsAddonDataDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_populateDictForNonArray_191391259]]></java_class_name><child_class_names></child_class_names><date_modified>1358564319000</date_modified><guid><![CDATA[testsavvis_161412416]]></guid><_children></_children></bm_function><bm_lib_func_param><id>191391261</id><bm_lib_func_id>191391260</bm_lib_func_id><param_name><![CDATA[templateID]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564319000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_161412419]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391262</id><bm_lib_func_id>191391260</bm_lib_func_id><param_name><![CDATA[addon]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564319000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_161412420]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391263</id><bm_lib_func_id>191391260</bm_lib_func_id><param_name><![CDATA[isDeletable]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564319000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_161412421]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391264</id><bm_lib_func_id>191391260</bm_lib_func_id><param_name><![CDATA[aip]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564319000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_161412422]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391265</id><bm_lib_func_id>191391260</bm_lib_func_id><param_name><![CDATA[addonsSelectedArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564319000</date_modified><order_no>5</order_no><guid><![CDATA[testsavvis_161412423]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391266</id><bm_lib_func_id>191391260</bm_lib_func_id><param_name><![CDATA[addonVsAddonDataDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1358564319000</date_modified><order_no>6</order_no><guid><![CDATA[testsavvis_161412424]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>25541974</id><name><en><![CDATA[Get SOW Pricing Total Per Item]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getSOWPricingTotalPerItem]]></variable_name><description><en><![CDATA[Returns total for each item present in an array calculated as quantity * unit rate]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>9</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>25541972</function_id><main_script_text></main_script_text><date_modified>1358564316000</date_modified><guid><![CDATA[LEGACY_25541974]]></guid><_children><bm_function><id>25541972</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get SOW Pricing Total Per Item (getSOWPricingTotalPerItem)                                  **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Returns total for each item present in an array calculated as quantity * unit rate          **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

totals = float[];
indexes = range(arrayQuantity);

//Loops through all the array items and calculates the total for each item
for index in indexes {
	append(totals, quantity[index] * unitRate[index]);
}
return totals;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getSOWPricingTotalPerItem_25541972]]></java_class_name><child_class_names></child_class_names><date_modified>1358564316000</date_modified><guid><![CDATA[LEGACY_25541972]]></guid><_children></_children></bm_function><bm_lib_func_param><id>25541976</id><bm_lib_func_id>25541974</bm_lib_func_id><param_name><![CDATA[arrayQuantity]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1358564316000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_25541976]]></guid></bm_lib_func_param><bm_lib_func_param><id>25541977</id><bm_lib_func_id>25541974</bm_lib_func_id><param_name><![CDATA[quantity]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>7</datatype><date_modified>1358564316000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_25541977]]></guid></bm_lib_func_param><bm_lib_func_param><id>25541978</id><bm_lib_func_id>25541974</bm_lib_func_id><param_name><![CDATA[unitRate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>8</datatype><date_modified>1358564316000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_25541978]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>485337031</id><name><en><![CDATA[CTL Get Config Availability]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[ctlGetConfigAvailability]]></variable_name><description><en><![CDATA[BIGMACH-2001/US559: Makes availability call to CenturyLink ESL, and parses the resulting xml into a delimited string containing relevant attributes and their INCLUSIVE values.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>15</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>485337030</function_id><main_script_text></main_script_text><date_modified>1386687700000</date_modified><guid><![CDATA[testsavvis_338342732]]></guid><_children><bm_function><id>485337030</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    CTL Get Config Availability(ctlGetConfigAvailability)
//** Type:        Utility Library Function   
//**
//** Description: Generates the full XML of the availability integration piece, then sends it to the availability web   
//**              service to get back the correct availability strings. Used in Recommendation Rules.    
//** 
//** Param:       
//**          environmentName - current environment name (ie: sbcenturylink). Used for request xml lookup path              
//**          locationIDArray - String Array of SFDC Location IDs.
//**          targetAttrNamesArray - (DEPRECATED) - String Array, with each index being an attribute we want the availability of.
//**          attrVsValueDict - String Dict of name-value pairs (name is key)
//**
//** Return type: String Dict - Dictionary with keys of location IDs.
//**                            Values of delimited string of attributes and their inclusive values.
//**              Value Format: attribute1Name@value1~value2~...$$attribute2Name@value1...
//**
//** Return type: String Dict - Dictionary with keys of location IDs, as well as a key of "HEADER" for any system-level info/messages.
//**                            Values of delimited string of attributes and their inclusive values.
//**              Value Format: attribute1Name@value1~value2~...$$attribute2Name@value1...
//**
//** History:     Date     Author       Comment    
//**              03/20/13 RConaghan  US 559   Initial Implementation   
//**              04/05/13 RConaghan  US 827  RConaghan Edited function to allow for multiple addresses    
//**              04/26/13 RConaghan  US 736  RConaghan Edited function to make parameters location ID-based  
//**              05/16/13 RConaghan  US 736  RConaghan Added functionality for AdditionalParams section 
//**              05/17/13 RConaghan  US 729  RConaghan Added handling of error messages on both header and address level
//**              09/24/13 SKharche   BIGMACH-2710 - CTL code reconciliation
//**              09/06/13 RConaghan  US 1868 RConaghan Refactorization done to increase speed, add timing, and give standardized output format.
//**              10/04/13 RConaghan  US 1939 RConaghan Added new tags for Access Vendors calls
//**              11/18/13 SKharche   BIGMACH-3012 - CTL code reconciliation
//**              10/23/13 RConaghan  US 2037 RConaghan Added conversion of XML encoded ampersands
//**              11/06/13 RConaghan  US 1869 RConaghan Modified message parsing to take AdditionalMessage tag.
//************************************************************************************************************

/* List of Keys for attrVsValueDict. All keys are in the format of locationID!$!keyName
    AdditionalLocationReferenceID - SFDC Quote ID (pull in from crmQuoteId_quote in commerce)
    OpptyID - Opportunity ID (pull in from crmOpportunityId_quote in commerce)
    AccessCategory - llLocalAccessCategoryArrAtt
    AccessProtocol - llLocalAccessOptionsArrAtt
    AccessCLLI - NO ATTRIBUTE BUILT YET. Will be the user-entered CLLI for Special Access Protocol, CO Meetpoint Category combo.
    AccessHandoff - wanElacpHdnoffArrAtt
    ICSCCode - Vendor ICSC Code. Passed in via table lookup based on llVendorArrAtt
    AccessDetails - NO ATTRIBUTE BUILT YET. Will be the CLLI code for the address
    AdditionalParameters - This is a list of params not included in the XSD. Value in dict must be of format name~val$$name~val
*/

/*Path of tags we need to pull for each request
Request: ACCESS PROTOCOLS
    ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessProtocolList->AccessProtocol

Request: ACCESS SPEEDS
    ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed
    ESLAvailabilityResponse->AvailabilityResponse->Region

Request: ACCESS VENDORS
    ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessVendorList->AccessVendor->ICSCCode
    ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessVendorList->AccessVendor->MRCPrice
    ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessVendorList->AccessVendor->NRCPrice
    
Request: ESOWF DATA
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->BuildOutOptionInfoList->BuildOutOptionInfo->Option/
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->BuildOutOptionInfoList->BuildOutOptionInfo->RecommendedBuild
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->BuildOutOptionInfoList->BuildOutOptionInfo->BuildOutOptionErrMsg
        
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->BuildOutOptionInfoList->BuildOutOptionInfo->EquipmentInfo->Device->Clli
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->BuildOutOptionInfoList->BuildOutOptionInfo->EquipmentInfo->Device->RecommendedDevice
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->BuildOutOptionInfoList->BuildOutOptionInfo->EquipmentInfo->Device->SharingTypeCode
        
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->BuildOutOptionInfoList->BuildOutOptionInfo->EquipmentInfo->Device->AvailablePort->InterfaceCategory
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->BuildOutOptionInfoList->BuildOutOptionInfo->EquipmentInfo->Device->AvailablePort->NumberOfAvailablePorts
        
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->AqcbCheckInfo->AqcbRequired
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->AqcbCheckInfo->AqcbMessage
        
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->CopperCheckInfo->CopperChkStatus
        ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed->EthernetAvailabilityInfo->CopperCheckInfo->CopperChkMessage
*/

debugOn = false; //Add print statements
addTimers = true; //LOGGING FLAG - SET TO TRUE TO ADD REQUEST/RESPONSE TIMES TO OUTPUT
addFullResponse = true; //DEBUGGING FLAG - Output Full output XML with response
inputXMLFileName = "ctlAvailabilityRequest.xml"; //Filename of input XML file
systemRespMessage = ""; //If not blank, this message will go in the "SYSTEM" key of the returned dictionary.
retDict = dict("string");
locationRequestTypeDict = dict("string"); //Key = Location ID. Tracks the RequestType on a per-location basis.    
retStr = "";
URL = "";
Credential = "";
SysName = "";

parentOuterDelim = "$=$";
parentInnerDelim = "$-$";
parentValueDelim = "$*$";
childOuterDelim = "!=!";
childInnerDelim = "!-!";
childValueDelim = "!*!";

//List of all tags on the request that are either at the header level, or are always identical for all locations
requestStaticTagList = String[]{"SalesChannel", "CallingSystemName", "RequestId", "OpptyID", "VendorPriceRequired", "LocationSource","ServiceCategoryCode"};
//List of all tags in request that may change on a per-location basis.
requestDynamicTagList = String[]{"RequestType", "AccessProtocol", "AccessSpeed", "AccessVendor", "AdditionalParameters"};

//Get URL and Credentials
bmqlKey = String[]{"CXG_AVAILABILITY_URL","CXG_AVAILABILITY_CREDENTIAL_B64","CALLING_SYS_NAME"};
results= bmql("SELECT Value, Keyword FROM ctlGlobalVars WHERE Keyword IN $bmqlKey");
for record in results {
    if(get(record, "Keyword") == "CXG_AVAILABILITY_URL"){
        URL = get(record, "Value");
    }
    elif(get(record, "Keyword") == "CXG_AVAILABILITY_CREDENTIAL_B64"){
        Credential = get(record, "Value");
    }
    elif(get(record, "Keyword") == "CALLING_SYS_NAME"){
        SysName = get(record, "Value");
    }
}

put(attrVsValueDict, "CallingSystemName", SysName);


/*************************START INPUT ASSEMBLY*************************/
inputHeaders = dict("string");
put(inputHeaders, "Authorization", "Basic " + Credential);
put(inputHeaders, "Content-Type", "text/xml");
inputXML = urldatabypost("https://" + lower(environmentName) + 
                             ".bigmachines.com/bmfsweb/" + lower(environmentName) + 
                             "/image/WebServices/" + inputXMLFileName, "", "");    

                             
/***BEGIN REPLACE "Non-Repeating" TAGS ON INPUT**SalesChannel/CallingSystemName/RequestId/OpptyId/VendorPriceRequired*/
for tag in requestStaticTagList{
    if(containskey(attrVsValueDict, tag)){
        inputXML = replace(inputXML, "%"+tag+"%", get(attrVsValueDict, tag));
    }
    else{ //if tag not found in input dictionary, then clear out dummy tag
        inputXML = replace(inputXML, "<"+tag+">%"+tag+"%</"+tag+">", "");
    }
}

/***END REPLACE "Non-Repeating" TAGS ON INPUT***/
/***BEGIN REPLACE "Repeating" TAGS ON INPUT**/

rawLocationInfoSection = substring(inputXML, find(inputXML, "<ExternalLocationRef>"), find(inputXML, "</ExternalLocationRef>") + len("</ExternalLocationRef>"));
rawParamInfoSection = substring(inputXML, find(inputXML, "<ParameterInfo>"), find(inputXML, "</ParameterInfo>") + len("</ParameterInfo>"));
replacementLocationInfoSection = "";
replacementParamInfoSection = "";
for locationID in locationIDArray{
    //We have hardcoded the LocationReferenceID portion in for performance reasons, most notably that that is the only dynamic tag in the LocationInfo section
    if(rawLocationInfoSection <> ""){
        curIDLocationInfoSection = rawLocationInfoSection;
        curIDLocationInfoSection = replace(curIDLocationInfoSection, "%LocationReferenceID%", locationID);
        replacementLocationInfoSection = replacementLocationInfoSection + curIDLocationInfoSection;
    }
    if(rawParamInfoSection <> ""){
        curIDParamInfoSection = rawParamInfoSection;
        curIDParamInfoSection = replace(curIDParamInfoSection, "%LocationReferenceID%", locationID);
        for tag in requestDynamicTagList{
            if(containskey(attrVsValueDict, locationID+"!$!"+tag)){
                if(tag == "RequestType"){
                    put(locationRequestTypeDict, locationID, get(attrVsValueDict, locationID+"!$!"+tag));
                }
                if(tag == "AdditionalParameters"){
                    additionalParamSection = "";
                    keyVal = get(attrVsValueDict, locationID+"!$!"+tag);
                    if(keyVal <> ""){ //Value will be in format attrName~Val$$attrName~Val
                        paramSplit = split(keyVal, "$$");
                        for param in paramSplit{
                            if(param <> ""){
                                nameValSplit = split(param, "~");
                                additionalParamSection = additionalParamSection + "<AdditionalParameter><ParameterName>"+nameValSplit[0]+"</ParameterName><ParameterValue>"+nameValSplit[1]+"</ParameterValue></AdditionalParameter>";
                            }
                        }
                    }
                    curIDParamInfoSection = replace(curIDParamInfoSection, "%" + tag + "%", additionalParamSection);
                }
                else{ //tag <> "AdditionalParameters"
                    curIDParamInfoSection = replace(curIDParamInfoSection, "%"+tag+"%", get(attrVsValueDict, locationID+"!$!"+tag));
                }
            }
            else{ //if tag not found in input dictionary, then clear out dummy tag
                if(tag == "AccessSpeed"){
                    curIDParamInfoSection = replace(curIDParamInfoSection, "<Speed>"+"%"+tag+"%"+"</Speed>", "%"+tag+"%");
                }
                if(tag == "AccessVendor"){
                    curIDParamInfoSection = replace(curIDParamInfoSection, "<VendorName>"+"%"+tag+"%"+"</VendorName>", "%"+tag+"%");
                }
                curIDParamInfoSection = replace(curIDParamInfoSection, "<"+tag+">%"+tag+"%</"+tag+">", "");
            }
        }
        replacementParamInfoSection = replacementParamInfoSection + curIDParamInfoSection;
    }
}
inputXML = replace(inputXML, rawLocationInfoSection, replacementLocationInfoSection, 1);
inputXML = replace(inputXML, rawParamInfoSection, replacementParamInfoSection, 1);
/***END REPLACE "Repeating" TAGS ON INPUT**/
/*************************END INPUT ASSEMBLY*************************/

//**Make Web Service Call
urlPrefix = "http://www.centurylink.com/XMLSchema/ESL/";
//Invoke the CXG webservice
outputDefault = "Configuration currently unavailable. Please try again later";
requestTime = getcurrenttimeinmillis();
calloutTime = getstrdate();
outputXML = urldatabypost(URL, inputXML, outputDefault, inputHeaders);

//Success Sample
//outputXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><ESLAvailabilityResponse xmlns=\"http://www.centurylink.com/XMLSchema/ESL\" xmlns:e=\"http://www.centurylink.com/XMLSchema/ESL\" xmlns:geow=\"GeoWS\"><ProcessStatus>FAILURE</ProcessStatus><AvailabilityResponse><LocationIdentifier><LocationReferenceID>2983677</LocationReferenceID></LocationIdentifier><LocationValidationInfo><SFAValidationStatus>Validated</SFAValidationStatus></LocationValidationInfo><Region>IR</Region><GeneralLocationAvailabilityInfo><GeneralAvailabilityInfo><DistanceData><DataParamKey>MANHOLE_FT</DataParamKey><DataParamValue>491</DataParamValue></DistanceData><DistanceData><DataParamKey>QCC_FT</DataParamKey><DataParamValue>101</DataParamValue></DistanceData></GeneralAvailabilityInfo></GeneralLocationAvailabilityInfo><AccessAvailabilityResponse><LocationValidationStatus><SFAValidationStatus>Validated</SFAValidationStatus></LocationValidationStatus><AccessSpeedList><AccessSpeed>1</AccessSpeed><AccessSpeed>2</AccessSpeed><AccessSpeed>3</AccessSpeed></AccessSpeedList><AccessVendorList><AccessVendor><VendorName>QWEST CORPORATION - CO</VendorName><VendorType>ILEC</VendorType><VendorCode/><ICSCCode>MS02</ICSCCode><ExpediteInd>false</ExpediteInd><MRCPrice>150</MRCPrice><NRCPrice>0</NRCPrice><AccessSpeedList><AccessSpeed><Speed>DS-1</Speed></AccessSpeed></AccessSpeedList></AccessVendor></AccessVendorList><AccessProtocolList><AccessProtocol>ELA OVER SONET</AccessProtocol><AccessProtocol>ELA PREMIER ALIGNMENT</AccessProtocol><AccessProtocol>SPECIAL ACCESS</AccessProtocol><AccessProtocol>WAVELENGTH</AccessProtocol><AccessProtocol>ELA BASIC</AccessProtocol></AccessProtocolList><AccessAvailabilityMessages><AvailabilityException><Status>ERROR</Status><Code>1</Code><Message>Not a exact match</Message><AdditionalMessage/></AvailabilityException><AvailabilityException><Status>ERROR</Status><Code>10</Code><Message>Not a exact match</Message><AdditionalMessage/></AvailabilityException></AccessAvailabilityMessages></AccessAvailabilityResponse><AvailabilityExceptionList><AvailabilityException/></AvailabilityExceptionList></AvailabilityResponse></ESLAvailabilityResponse>";

//Failure Sample
//outputXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><ESLAvailabilityResponse xmlns=\"http://www.centurylink.com/XMLSchema/ESL\" xmlns:e=\"http://www.centurylink.com/XMLSchema/ESL\" xmlns:geow=\"GeoWS\"><ProcessStatus>FAILURE</ProcessStatus><AvailabilityResponse><AvailabilityExceptionList><AvailabilityException><Message>This is a test message</Message><Code>911</Code><Status>ERROR</Status></AvailabilityException><AvailabilityException><Message>Another message here</Message><Code>123</Code><Status>INFO</Status></AvailabilityException></AvailabilityExceptionList></AvailabilityResponse></ESLAvailabilityResponse>";
//outputXML = outputDefault;

//ESOWF Sample
//outputXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><ESLAvailabilityResponse xmlns=\"http://www.centurylink.com/XMLSchema/ESL\"><ProcessStatus>SUCCESS</ProcessStatus><AvailabilityResponse><LocationIdentifier><LocationReferenceID>2983677</LocationReferenceID></LocationIdentifier><LocationValidationInfo><SFAValidationStatus>VALIDATED</SFAValidationStatus><IsAvailabilityByTN>false</IsAvailabilityByTN></LocationValidationInfo><Region>IR</Region><GeneralAvailabilityInfo><DistanceData><DataParamKey>QCC_FT</DataParamKey><DataParamValue>326.08</DataParamValue></DistanceData></GeneralAvailabilityInfo><AccessAvailabilityResponse><AccessProtocolList><AccessProtocol>ELA Basic</AccessProtocol><AccessProtocol>ELA Premier Identical</AccessProtocol><AccessProtocol>ELA Premier Alignment</AccessProtocol></AccessProtocolList><AccessSpeedList><AccessSpeed><Speed>10</Speed><EthernetAvailabilityInfo><TransactionID>1234</TransactionID><BuildOutOptionInfoList><BuildOutOptionInfo><Option>TA5000</Option><RecommendedBuild>true</RecommendedBuild><EquipmentInfo><EQChkStatus>REQUEST SUCCESSFUL</EQChkStatus><Device><DeviceType>MoeAggDevice</DeviceType><Clli>BOISIDMAH27</Clli><SharingTypeCode>SHARED</SharingTypeCode><RecommendedDevice>Yes</RecommendedDevice></Device></EquipmentInfo></BuildOutOptionInfo><BuildOutOptionInfo><Option>Flowthrough</Option><RecommendedBuild>false</RecommendedBuild><EquipmentInfo><EQChkStatus>REQUEST SUCCESSFUL</EQChkStatus><Device><DeviceType>CustomerLocationDevice</DeviceType><Clli>BOISIDRE00W</Clli><SharingTypeCode>SHARED</SharingTypeCode><RecommendedDevice>No</RecommendedDevice><AvailablePortList><AvailablePort><InterfaceCategory>Optical</InterfaceCategory><NumberOfAvailablePorts>1</NumberOfAvailablePorts></AvailablePort><AvailablePort><InterfaceCategory>Electrical</InterfaceCategory><NumberOfAvailablePorts>7</NumberOfAvailablePorts></AvailablePort></AvailablePortList></Device></EquipmentInfo></BuildOutOptionInfo></BuildOutOptionInfoList><CopperCheckInfo><CopperChkStatus>SUCCESS</CopperChkStatus><WireCenterInfo><SWCNPA>208</SWCNPA><SWCNXX>336</SWCNXX><SWCCLLI>BOISIDMA</SWCCLLI></WireCenterInfo><MaxQualifiedBandwidth>10</MaxQualifiedBandwidth><CopperChkMessage/></CopperCheckInfo><AqcbCheckInfo><AqcbRequired>No</AqcbRequired><AqcbMessage>Requested bandwidth available for sale.</AqcbMessage></AqcbCheckInfo></EthernetAvailabilityInfo></AccessSpeed></AccessSpeedList></AccessAvailabilityResponse></AvailabilityResponse></ESLAvailabilityResponse>";

responseTime = getcurrenttimeinmillis() - requestTime;

//@RC - 10/23/13 - US2037 - Handle Special Characters converted in XML
outputXML = replace(outputXML, "&amp;", "&");

//DEBUGGING
if(debugOn){
    print "URL: " + URL;
    print "INPUT XML:";
    print inputXML;
    print "";
    print "OUTPUT XML:";
    print outputXML;
}
//@RC - 11/26/13 - Replacing CDATA Tag with a blank as BMI chokes on the CDATA on the layout.
outputXML = replace(outputXML, "[CDATA[", "");

// End web service call.
//***************BEGIN RESPONSE ASSEMBLY******************//
//Put a default message in for all locations being requested - this will be overwritten for any address that gives a response
defaultMessage =  "No Data Returned for location id: %location% on oppty: "+ get(attrVsValueDict, "OpptyID") + ".";
defaultRespStr = "AvailabilityException" + parentInnerDelim + "Type" + childInnerDelim + "ERROR" + childOuterDelim 
                                                            + "Code" + childInnerDelim + "SYSTEM" + childOuterDelim
                                                            + "Message" + childInnerDelim + defaultMessage + childOuterDelim
                                                            + parentOuterDelim;
for location in locationIDArray{
    put(retDict, location, replace(defaultRespStr, "%location%", location));
}

//Add timing info to systemRespMessage
if(addTimers){
    systemRespMessage = systemRespMessage + "TimingInfo" + parentInnerDelim + "TimeOfRequest" + childInnerDelim + calloutTime + childOuterDelim + "ResponseTime" + childInnerDelim + string(responseTime) + "ms" + parentOuterDelim;
}
if(addFullResponse){
	systemRespMessage = systemRespMessage + "OutputXML" + parentInnerDelim + "Response" + childInnerDelim +  outputXML + parentOuterDelim;
	systemRespMessage = systemRespMessage + "InputXML" + parentInnerDelim + "Request" + childInnerDelim +  inputXML + parentOuterDelim;
}

//set ESL Prefix
ESLPrefix = ""; //Variable put in as ESL cannot guarantee a consistent format and some calls may come back prefixed with "<e:"
//if(find(outputXML, "<e:ProcessStatus") <> -1){
if(find(outputXML, "<e:") <> -1){
    outputXML = replace(outputXML, "<e:","<");
    outputXML = replace(outputXML, "</e:","</");
    //ESLPrefix = "e:";
}

//Parse through XML.
//Check that it was successful at the call level (not the per-address level). If not, then add relevant messages to systemRespMessage
if(find(outputXML, ">SUCCESS</"+ESLPrefix+"ProcessStatus>") == -1){
    outerSystemErrorResp = "SystemExceptions" + parentInnerDelim;
    innerSystemErrorResp = "";
    //Start CXG/ESL down response
    if(outputXML == outputDefault){
        innerSystemErrorResp = innerSystemErrorResp + "Type" + childInnerDelim + "ERROR" + childOuterDelim 
                                            + "Code" + childInnerDelim + "SYSTEM" + childOuterDelim
                                            + "Message" + childInnerDelim + outputXML + childOuterDelim;
    }
    else{ //Else we hit a FAILURE, but not a no reponse/HTTP error
        //Need to grab ESLAvailabilityResponse->AvailabilityExceptionList->AvailabilityException->Message/Code/Status
        exceptionListStartPos = find(outputXML, ">", find(outputXML, "<"+ESLPrefix+"AvailabilityExceptionList"))+1;
        exceptionListEndPos = find(outputXML, "</"+ESLPrefix+"AvailabilityExceptionList>");
        exceptionList = split(substring(outputXML, exceptionListStartPos, exceptionListEndPos), "</"+ESLPrefix+"AvailabilityException"+">");
        for exception in exceptionList{
            if(exception <> "" AND exception <> "<AvailabilityException/>"){
                status = "ERROR";
                code = "-1";
                dispMessage = "No message specified";
                status = substring(exception, find(exception,"<"+ESLPrefix+"Status"+">")+len("<"+ESLPrefix+"Status"+">"), find(exception, "</"+ESLPrefix+"Status>"));
                code = substring(exception, find(exception,"<"+ESLPrefix+"Code"+">")+len("<"+ESLPrefix+"Code"+">"), find(exception, "</"+ESLPrefix+"Code>"));
                dispMessage = substring(exception, find(exception,"<"+ESLPrefix+"Message"+">")+len("<"+ESLPrefix+"Message"+">"), find(exception, "</"+ESLPrefix+"Message>"));
                innerSystemErrorResp = innerSystemErrorResp + "Type" + childInnerDelim + status + childOuterDelim 
                                              + "Code" + childInnerDelim + code + childOuterDelim
                                              + "Message" + childInnerDelim + dispMessage + childOuterDelim
                                              + parentValueDelim;
                
            }
        }
    }
    if(innerSystemErrorResp <> ""){
        systemRespMessage = systemRespMessage + outerSystemErrorResp + innerSystemErrorResp + parentOuterDelim;
    }
}

//Trim response to just get the list of <AvailabilityResponse> and <AvailabilityExceptionList>
outputXML = substring(outputXML, find(outputXML, ">", find(outputXML, "<"+ESLPrefix+"ESLAvailabilityResponse"))+1); //Remove leading data
outputXML = substring(outputXML, 0, find(outputXML, "</"+ESLPrefix+"ESLAvailabilityResponse")); //Remove trailing data
availabilityResp = split(outputXML, "</"+ESLPrefix+"AvailabilityResponse>");
//AvailabiltiyResp should be an array where the last index contains AvailabilityExceptionList (if present), and all other indexes will contain an availabilityResponse
for fullResponse in availabilityResp{
    if(debugOn){
        print "RESP:";
        print fullResponse;
    }
    locationResponseString = "";
    locationErrorsString = "";
    requestType = "";
    if(find(fullResponse, "<"+ESLPrefix+"AvailabilityResponse") <> -1){ //Make sure this is a valid response
        parsedResponse = fullResponse; //Use this response to parse through the AvailabilityResponse without actually modifying it.
        tagPathsRequired = String[]; //String array containing the paths of all different values we want to pull from the response
        //Get location ID of the response
        startPos = find(fullResponse, ">", find(fullResponse,"<"+ESLPrefix+"LocationReferenceID"))+1;
        endPos = find(fullResponse, "</"+ESLPrefix+"LocationReferenceID");
        parsedResponse = substring(parsedResponse, startPos, endPos);
        //at end of loop, parsedResponse should = locationID
        locID = parsedResponse;
        if(locID <> ""){
            requestType = get(locationRequestTypeDict, locID);        
        }
        
        //**BEGIN PULLING ATTRIBUTES FROM AvailabilityResponse**//
        //For ACCESS PROTOCOLS, we need the DistanceData MANHOLE_FT tag: IE: ESLAvailabilityResponse->AvailabilityResponse->GeneralAvailabilityInfo->DistanceData->DataParamKey/DataParamValue
        if(requestType == "ACCESS PROTOCOLS"){
            distanceDataStr = "";
            GenAvailInfoStart = find(fullResponse, ">", find(fullResponse, "<"+ESLPrefix+"GeneralAvailabilityInfo"))+1;
            GenAvailInfoEnd = find(fullResponse, "</"+ESLPrefix+"GeneralAvailabilityInfo>");
            if(GenAvailInfoStart -1 <> -1 AND GenAvailInfoEnd <> -1){
                distanceDataList = split(substring(fullResponse, GenAvailInfoStart, GenAvailInfoEnd), "</"+ESLPrefix+"DistanceData>");
                for distanceData in distanceDataList{
                    if(distanceData <> ""){
                        //Get DataParamkey
                        paramKeyStart = find(distanceData, ">", find(distanceData, "<"+ESLPrefix+"DataParamKey"))+1;
                        paramKeyEnd = find(distanceData, "</"+ESLPrefix+"DataParamKey>");
                        if(paramKeyStart - 1 <> -1 AND paramKeyEnd <> -1){
                            paramKey = substring(distanceData, paramKeyStart, paramKeyEnd);
                            paramValStart = find(distanceData, ">", find(distanceData, "<"+ESLPrefix+"DataParamValue"))+1;
                            paramValEnd = find(distanceData, "</"+ESLPrefix+"DataParamValue>");
                            if(paramValStart -1 <> -1 AND paramValEnd <> -1){
                                paramValue = substring(distanceData, paramValStart, paramValEnd);
                                if(paramValue <> ""){
                                    distanceDataStr = distanceDataStr + paramKey + childInnerDelim + paramValue + childOuterDelim;
                                }
                            }
                        }
                        //Look for MANHOLE_FT
                        /*
                        if(find(distanceData, ">"+"MANHOLE_FT"+"</"+ESLPrefix+"DataParamKey>") <> -1){
                            manholeFtStart = find(distanceData, ">", find(distanceData, "<"+ESLPrefix+"DataParamValue"))+1;
                            manholeFtEnd = find(distanceData, "</"+ESLPrefix+"DataParamValue>");
                            if(manholeFtStart -1 <> -1 AND manholeFtEnd <> -1){
                                manholeValue = substring(distanceData, manholeFtStart, manholeFtEnd);
                                manholeStr = "MANHOLE_FT" + childInnerDelim + manholeValue;
                            }
                        }
                        */
                    }
                }
            }
            if(distanceDataStr <> ""){
                genAvailInfoStr = "GeneralAvailabilityInfo" + parentInnerDelim;
                locationResponseString = locationResponseString + genAvailInfoStr + distanceDataStr + parentOuterDelim;
            }
        }
        //For ACCESS SPEEDS, we need the Region tag. We know this will have at most one iteration, so no loop is needed
        if(requestType == "ACCESS SPEEDS"){ //ESLAvailabilityResponse->AvailabilityResponse->Region
            regionStartPos = find(fullResponse, ">", find(fullResponse, "<"+ESLPrefix+"Region"))+1;
            regionEndPos = find(fullResponse, "</"+ESLPrefix+"Region>");
            regionValue = "";
            if(regionStartPos -1 <> -1 AND regionEndPos <> -1){
                regionValue = substring(fullResponse, regionStartPos, regionEndPos);
                outerRegionStr = "Region" + parentInnerDelim;
                innerRegionStr = "Region" + childInnerDelim + regionValue;
                locationResponseString = locationResponseString + outerRegionStr + innerRegionStr + parentOuterDelim;
            }
        }
        
        
        //**BEGIN PULLING ATTRIBUTES FROM AvailabilityResponse->AccessAvailabilityResponse**//
        accessAvailabilityResp = split(fullResponse, "</"+ESLPrefix+"AccessAvailabilityResponse>");
        for availabilityResponse in accessAvailabilityResp{
            if(find(availabilityResponse, "<"+ESLPrefix+"AccessAvailabilityResponse") <> -1){ //If a proper response exists
                if(requestType == "ACCESS PROTOCOLS" AND find(availabilityResponse, "<"+ESLPrefix+"AccessProtocolList"+"/>") == -1){ //AccessAvailabilityResponse->AccessProtocolList->AccessProtocol
                    startPos = find(availabilityResponse, ">", find(availabilityResponse, "<"+ESLPrefix+"AccessProtocolList"))+1;
                    endPos = find(availabilityResponse, "</"+ESLPrefix+"AccessProtocolList>");
                    protocolList = split(substring(availabilityResponse, startPos, endPos), "</"+ESLPrefix+"AccessProtocol"+">");
                    outerProtocolStr = "AccessProtocol" + parentInnerDelim;
                    innerProtocolStr = "Protocol" + childInnerDelim;
                    for protocol in protocolList{
                        if(protocol <> ""){
                            innerProtocolStr = innerProtocolStr + substring(protocol, find(protocol,">")+1, len(protocol)) + childValueDelim;
                        }
                    }
                    innerProtocolStr = innerProtocolStr + childOuterDelim;
                    protocolRetStr = outerProtocolStr + innerProtocolStr;
                    locationResponseString = locationResponseString + protocolRetStr + parentOuterDelim;
                }
                if(requestType == "ACCESS SPEEDS" AND find(availabilityResponse, "<"+ESLPrefix+"AccessSpeedList"+"/>") == -1){ //ESLAvailabilityResponse->AvailabilityResponse->AccessAvailabilityResponse->AccessSpeedList->AccessSpeed
                    outerSpeedStr = "AccessSpeed" + parentInnerDelim;
                    innerSpeedStr = "Speed" + childInnerDelim;
                    startPos = find(availabilityResponse, ">", find(availabilityResponse, "<"+ESLPrefix+"AccessSpeedList"))+1;
                    endPos = find(availabilityResponse, "</"+ESLPrefix+"AccessSpeedList>");
                    speedList = split(substring(availabilityResponse, startPos, endPos), "</"+ESLPrefix+"AccessSpeed"+">");
                    for speed in speedList{
                        if(speed <> ""){
                            speedStartPos = find(speed, ">", find(speed, "<"+ESLPrefix+"Speed"))+1;
                            speedEndPos = find(speed, "</"+ESLPrefix+"Speed>");
                            innerSpeedStr = innerSpeedStr + substring(speed, speedStartPos, speedEndPos) + childValueDelim;
                        }
                    }
                    innerSpeedStr = innerSpeedStr + childOuterDelim;
                    speedRetStr = outerSpeedStr + innerSpeedStr;
                    locationResponseString = locationResponseString + speedRetStr + parentOuterDelim;
                }
                if(requestType == "ACCESS VENDORS" AND find(availabilityResponse, "<"+ESLPrefix+"AccessVendorList"+"/>") == -1){ //AccessAvailabilityResponse->AccessVendorList->AccessVendor->ICSCCode/MRCPrice/NRCPrice/VendorName
                    outerVendorStr = "AccessVendor" + parentInnerDelim;
                    innerVendorStr = "";
                    startPos = find(availabilityResponse, ">", find(availabilityResponse, "<"+ESLPrefix+"AccessVendorList"))+1;
                    endPos = find(availabilityResponse, "</"+ESLPrefix+"AccessVendorList>");
                    vendorList = split(substring(availabilityResponse, startPos, endPos), "</"+ESLPrefix+"AccessVendor"+">");
                    for vendor in vendorList{ //Parsing through AccessAvailabilityResponse->AccessVendorList->AccessVendor
                        if(vendor <> ""){
                            //Since ICSCCode, MRCPrice, and NRCPrice can only happen a max of 1 time, no extra loop needed.
                            ICSCStartPos = find(fullResponse, ">", find(fullResponse, "<"+ESLPrefix+"ICSCCode"))+1;
                            ICSCSEndPos = find(fullResponse, "</"+ESLPrefix+"ICSCCode>");
                            innerICSCStr = "";
                            ICSCValue = "";
                            if(ICSCStartPos <> -1 AND ICSCSEndPos <> -1){
                                ICSCValue = substring(fullResponse, ICSCStartPos, ICSCSEndPos);
                                innerICSCStr = "ICSCCode" + childInnerDelim + ICSCValue + childOuterDelim;
                            }
                            
                            MRCStartPos = find(fullResponse, ">", find(fullResponse, "<"+ESLPrefix+"MRCPrice"))+1;
                            MRCEndPos = find(fullResponse, "</"+ESLPrefix+"MRCPrice>");
                            MRCValue = "0.0";
                            innerMRCStr = "MRCPrice" + childInnerDelim;
                            if(MRCStartPos <> -1 AND MRCEndPos <> -1){
                                MRCValue = substring(fullResponse, MRCStartPos, MRCEndPos);
                                innerMRCStr = innerMRCStr + MRCValue + childOuterDelim;
                            }
                            
                            NRCStartPos = find(fullResponse, ">", find(fullResponse, "<"+ESLPrefix+"NRCPrice"))+1;
                            NRCEndPos = find(fullResponse, "</"+ESLPrefix+"NRCPrice>");
                            NRCValue = "0.0";
                            innerNRCStr = "NRCPrice" + childInnerDelim;
                            if(NRCStartPos <> -1 AND NRCEndPos <> -1){
                                NRCValue = substring(fullResponse, NRCStartPos, NRCEndPos);
                                innerNRCStr = innerNRCStr + NRCValue + childOuterDelim;
                            }
                            VendorNameStartPos = find(fullResponse, ">", find(fullResponse, "<"+ESLPrefix+"VendorName"))+1;
                            VendorNameEndPos = find(fullResponse, "</"+ESLPrefix+"VendorName>");
                            innerVendorNameStr = "";
                            VendorNameValue = "";
                            if(VendorNameStartPos <> -1 AND VendorNameEndPos <> -1){
                                VendorNameValue = substring(fullResponse, VendorNameStartPos, VendorNameEndPos);
                                innerVendorNameStr = "VendorName" + childInnerDelim + VendorNameValue + childOuterDelim;
                            }
                            
                            outerRegionStr = "AccessVendor" + parentInnerDelim;
                            locationResponseString = locationResponseString + outerRegionStr + innerICSCStr + innerMRCStr + innerNRCStr + innerVendorNameStr + parentOuterDelim;
                        }
                    }
                }
                if(requestType == "ESOWF DATA" AND find(availabilityResponse, "<"+ESLPrefix+"AccessSpeedList"+"/>") == -1){
                    outerESOWFStr = "ESOWFData" + parentInnerDelim;
                    speedsStartPos = find(availabilityResponse, ">", find(availabilityResponse, "<"+ESLPrefix+"AccessSpeedList"))+1;
                    speedsEndPos = find(availabilityResponse, "</"+ESLPrefix+"AccessSpeedList>");
                    speedList = split(substring(availabilityResponse, speedsStartPos, speedsEndPos), "</"+ESLPrefix+"AccessSpeed"+">");
                    speedStrArr = String[];
                    for speed in speedList{
                        if(speed <> ""){
                            //EthernetAvailabilityInfo->BuildOutOptionInfoList
                            ethernetInfoStartPos = find(speed, ">", find(speed, "<"+ESLPrefix+"EthernetAvailabilityInfo"))+1;
                            ethernetInfoEndPos = find(speed, "</"+ESLPrefix+"EthernetAvailabilityInfo>");
                            ethernetInfoXML = substring(speed, ethernetInfoStartPos, ethernetInfoEndPos); //Everything under the EthernetAvailabilityInfo tag
                            
                            //Begin Getting BuildOutOptinInfoList items
                            buildOutInfoStartPos = find(ethernetInfoXML, ">", find(ethernetInfoXML, "<"+ESLPrefix+"BuildOutOptionInfoList"))+1;
                            buildOutInfoEndPos = find(ethernetInfoXML, "</"+ESLPrefix+"BuildOutOptionInfoList>");
                            buildOutList = split(substring(ethernetInfoXML, buildOutInfoStartPos, buildOutInfoEndPos), "</"+ESLPrefix+"BuildOutOptionInfo"+">");
                            buildOutStrArr = String[];
                            for buildOut in buildOutList{
                                if(buildOut <> ""){
                                    //Get Option
                                    optionStartPos = find(buildOut, ">", find(buildOut, "<"+ESLPrefix+"Option"))+1;
                                    optionEndPos = find(buildOut, "</"+ESLPrefix+"Option>");
                                    value = "";
                                    if(optionStartPos <> -1 AND optionEndPos <> -1){
                                        value = substring(buildOut, optionStartPos, optionEndPos);
                                    }
                                    optionStr = "Option" + childInnerDelim + value + childOuterDelim;    
                                    //Get RecommendedBuild
                                    value = "";
                                    recBuildStartPos = find(buildOut, ">", find(buildOut, "<"+ESLPrefix+"RecommendedBuild"))+1;
                                    recBuildEndPos = find(buildOut, "</"+ESLPrefix+"RecommendedBuild>");
                                    if(recBuildStartPos <> -1 AND recBuildEndPos <> -1){
                                        value = substring(buildOut, recBuildStartPos, recBuildEndPos);
                                    }
                                    recommendedBuildStr = "RecommendedBuild" + childInnerDelim + value + childOuterDelim;
                                    //Get BuildOutOptionErrMsg
                                    value = "";
                                    buildOutOptionStartPos = find(buildOut, ">", find(buildOut, "<"+ESLPrefix+"BuildOutOptionErrMsg"))+1;
                                    buildOutOptionEndPos = find(buildOut, "</"+ESLPrefix+"BuildOutOptionErrMsg>");
                                    if(buildOutOptionStartPos <> -1 AND buildOutOptionEndPos <> -1){
                                        value = substring(buildOut, buildOutOptionStartPos, buildOutOptionEndPos);
                                    }
                                    buildOutOptionStr = "BuildOutOptionErrMsg" + childInnerDelim + value + childOuterDelim;
                                    
                                    //Get EquipmentInfo->Device->Clli/RecommendedDevice/SharingTypeCode
                                    //Device can happen multiple times
                                    deviceStartPos = find(buildOut, ">", find(buildOut, "<"+ESLPrefix+"Device"))+1;
                                    deviceEndPos = find(buildOut, "</"+ESLPrefix+"EquipmentInfo>");
                                    deviceList = split(substring(buildOut, deviceStartPos, deviceEndPos), "</"+ESLPrefix+"Device"+">");
                                    deviceStr = "";
                                    deviceArr = String[];
                                    clliString = ""; //Clli
                                    clliArr = String[];
                                    recommendedDeviceString = ""; //RecommendedDevice
                                    recommendedDeviceArr = String[];
                                    sharingTypeCodeString = ""; //SharingTypeCode
                                    sharingTypeCodeArr = String[];
                                    deviceListStrArr = String[]; //string array of all the iterations from the Device tag and its children
                                    for device in deviceList{
                                        //Note that CLLI/RecommendedDevice/SharingTypeCode are all corresponding, so if one exists put a blank for others if they do not also exist
                                        if(device <> ""){
                                            //Get Clli
                                            clliStartPos = find(device, ">", find(device, "<"+ESLPrefix+"Clli"))+1;
                                            clliEndPos = find(device, "</"+ESLPrefix+"Clli>");
                                            clliVal = "";
                                            if(clliStartPos <> -1 AND clliEndPos <> -1){
                                                clliVal = substring(device, clliStartPos, clliEndPos);
                                            }
                                            clliString = "Clli" + childInnerDelim + clliVal + childOuterDelim;    
                                            append(clliArr, clliVal);

                                            //Get RecommendedDevice
                                            recommendedDeviceStartPos = find(device, ">", find(device, "<"+ESLPrefix+"RecommendedDevice"))+1;
                                            recommendedDeviceEndPos = find(device, "</"+ESLPrefix+"RecommendedDevice>");
                                            recommendedDeviceVal = "";
                                            if(recommendedDeviceStartPos <> -1 AND recommendedDeviceEndPos <> -1){
                                                recommendedDeviceVal = substring(device, recommendedDeviceStartPos, recommendedDeviceEndPos);
                                            }
                                            recommendedDeviceString = "RecommendedDevice" + childInnerDelim + recommendedDeviceVal + childOuterDelim;
                                            append(recommendedDeviceArr, recommendedDeviceVal);
                                            //Get SharingTypeCode
                                            sharingTypeCodeStartPos = find(device, ">", find(device, "<"+ESLPrefix+"SharingTypeCode"))+1;
                                            sharingTypeCodeEndPos = find(device, "</"+ESLPrefix+"SharingTypeCode>");
                                            sharingTypeCodeVal = "";
                                            if(sharingTypeCodeStartPos <> -1 AND sharingTypeCodeEndPos <> -1){
                                                sharingTypeCodeVal = substring(device, sharingTypeCodeStartPos, sharingTypeCodeEndPos);    
                                            }
                                            sharingTypeCodeString = "SharingTypeCode" + childInnerDelim + sharingTypeCodeVal + childOuterDelim;
                                            append(sharingTypeCodeArr, sharingTypeCodeVal);
                                            
                                            //Get AvailablePortList->AvailablePort->InterfaceCategory/NumberOfAvailablePorts
                                            portListStartPos = find(device, ">", find(device, "<"+ESLPrefix+"AvailablePortList"))+1;
                                            portListEndPos = find(device, "</"+ESLPrefix+"AvailablePortList>");
                                            portList = split(substring(device, portListStartPos, portListEndPos), "</"+ESLPrefix+"AvailablePort"+">");
                                            InterfaceCategoryString = "";
                                            InterfaceCategoryArr = String[];
                                            NumberOfAvailablePortsString = "";
                                            NumberOfAvailablePortsArr = String[];
                                            portListStrArr = String[];
                                            for availablePort in portList{
                                                if(availablePort <> ""){
                                                    //Get InterfaceCategory
                                                    interfaceCatStartPos = find(availablePort, ">", find(availablePort, "<"+ESLPrefix+"InterfaceCategory"))+1;
                                                    interfaceCatEndPos = find(availablePort, "</"+ESLPrefix+"InterfaceCategory>");
                                                    interfaceVal = "";
                                                    if(interfaceCatStartPos <> -1 AND interfaceCatEndPos <> -1){
                                                        interfaceVal = substring(availablePort, interfaceCatStartPos, interfaceCatEndPos);    
                                                    }
                                                    InterfaceCategoryString = InterfaceCategoryString + interfaceVal + childValueDelim;
                                                    
                                                    //Get NumberOfAvailablePorts
                                                    numAvailPortsStartPos = find(availablePort, ">", find(availablePort, "<"+ESLPrefix+"NumberOfAvailablePorts"))+1;
                                                    numAvailPortsEndPos = find(availablePort, "</"+ESLPrefix+"NumberOfAvailablePorts>");
                                                    numAvailPortsVal = "";
                                                    if(numAvailPortsStartPos <> -1 AND numAvailPortsEndPos <> -1){
                                                        numAvailPortsVal = substring(availablePort, numAvailPortsStartPos, numAvailPortsEndPos);    
                                                    }
                                                    NumberOfAvailablePortsString = NumberOfAvailablePortsString + numAvailPortsVal + childValueDelim;
                                                    
                                                    temp = "InterfaceCategory" + childInnerDelim + interfaceVal + childOuterDelim + "NumberOfAvailablePorts" + childInnerDelim + numAvailPortsVal + childOuterDelim;
                                                    append(portListStrArr, temp);
                                                }
                                            }
                                            
                                            //Put together all possible combos from the AvailablePortList
                                            if(NOT isempty(portListStrArr)){
                                                for val in portListStrArr{
                                                    temp = clliString + recommendedDeviceString + sharingTypeCodeString + val;
                                                    append(deviceListStrArr, temp);
                                                }
                                            }
                                            else{
                                                append(deviceListStrArr, clliString + recommendedDeviceString + sharingTypeCodeString);
                                            }
                                        }
                                    }
                                    //Put together all possible combos from the Device List (also contains all combos of AvailabilePortList)
                                    if(NOT isempty(deviceListStrArr)){
                                        for val in deviceListStrArr{
                                            temp = optionStr + recommendedBuildStr + buildOutOptionStr + val;
                                            append(buildOutStrArr, temp);
                                        }
                                    }
                                    else{
                                        append(buildOutStrArr, optionStr + recommendedBuildStr + buildOutOptionStr);
                                    }
                                }
                            }
                            
                            //Begin Getting AqcbCheckInfo items AqcbRequired, AqcbMessage
                            aqcbCheckInfoStartPos = find(ethernetInfoXML, ">", find(ethernetInfoXML, "<"+ESLPrefix+"AqcbCheckInfo"))+1;
                            aqcbCheckInfoEndPos = find(ethernetInfoXML, "</"+ESLPrefix+"AqcbCheckInfo>");
                            aqcbXML = substring(ethernetInfoXML, aqcbCheckInfoStartPos, aqcbCheckInfoEndPos);
                            //Get AqcbRequired
                            AqcbRequiredStartPos = find(aqcbXML, ">", find(aqcbXML, "<"+ESLPrefix+"AqcbRequired"))+1;
                            AqcbRequiredEndPos = find(aqcbXML, "</"+ESLPrefix+"AqcbRequired>");
                            aqcbRequiredVal = substring(aqcbXML, AqcbRequiredStartPos, AqcbRequiredEndPos);
                            aqcbRequiredStr = "AqcbRequired" + childInnerDelim + aqcbRequiredVal + childOuterDelim;
                            //Get AqcbRequired
                            AqcbMessageStartPos = find(aqcbXML, ">", find(aqcbXML, "<"+ESLPrefix+"AqcbMessage"))+1;
                            AqcbMessageEndPos = find(aqcbXML, "</"+ESLPrefix+"AqcbMessage>");
                            aqcbMessageVal = substring(aqcbXML, AqcbMessageStartPos, AqcbMessageEndPos);
                            aqcbMessageStr = "AqcbMessage" + childInnerDelim + aqcbMessageVal + childOuterDelim;
                            
                            //Begin getting CopperCheckInfo items CopperChkStatus, CopperChkMessage
                            copperCheckInfoStartPos = find(ethernetInfoXML, ">", find(ethernetInfoXML, "<"+ESLPrefix+"CopperCheckInfo"))+1;
                            copperCheckInfoEndPos = find(ethernetInfoXML, "</"+ESLPrefix+"CopperCheckInfo>");
                            copperCheckInfoXML = substring(ethernetInfoXML, copperCheckInfoStartPos, copperCheckInfoEndPos);
                            //Get CopperChkStatus
							CopperChkStatusVal = "";
							if(find(copperCheckInfoXML, "<"+ESLPrefix+"CopperChkStatus/>") == -1){
								CopperChkStatusStartPos = find(copperCheckInfoXML, ">", find(copperCheckInfoXML, "<"+ESLPrefix+"CopperChkStatus"))+1;
								CopperChkStatusEndPos = find(copperCheckInfoXML, "</"+ESLPrefix+"CopperChkStatus>");
								CopperChkStatusVal = substring(copperCheckInfoXML, CopperChkStatusStartPos, CopperChkStatusEndPos);
							}
                            CopperChkStatusStr = "CopperChkStatus" + childInnerDelim + CopperChkStatusVal + childOuterDelim;
                            //Get CopperChkMessage
							CopperChkMessageVal = "";
							if(find(copperCheckInfoXML, "<"+ESLPrefix+"CopperChkMessage/>") == -1){
								CopperChkMessageStartPos = find(copperCheckInfoXML, ">", find(copperCheckInfoXML, "<"+ESLPrefix+"CopperChkMessage"))+1;
								CopperChkMessageEndPos = find(copperCheckInfoXML, "</"+ESLPrefix+"CopperChkMessage>");
								CopperChkMessageVal = substring(copperCheckInfoXML, CopperChkMessageStartPos, CopperChkMessageEndPos);
							}
							CopperChkMessageStr = "CopperChkMessage" + childInnerDelim + CopperChkMessageVal + childOuterDelim;
							print CopperChkMessageStr;
                            
                            if(NOT isempty(buildOutStrArr)){
                                for val in buildOutStrArr{
                                    temp = aqcbRequiredStr + aqcbMessageStr + CopperChkStatusStr + CopperChkMessageStr + val;
                                    append(speedStrArr, temp);
                                }
                            }
                            else{
                                append(speedStrArr, aqcbRequiredStr + aqcbMessageStr + CopperChkStatusStr + CopperChkMessageStr);
                            }
                        }
                    }
                    outerESOWFStr = "ESOWF DATA" + parentInnerDelim;
                    locationResponseString = locationResponseString + outerESOWFStr;
                    if(NOT isempty(speedStrArr)){
                        for val in speedStrArr{
                            locationResponseString = locationResponseString + val + parentValueDelim;
                        }
                        locationResponseString = locationResponseString + parentOuterDelim;
                    }
                }
                
                
                //PULL ERRORS & INFO MESSAGES
                //Errors/Info messages locations
                //AvailabilityResponse->AccessAvailabilityResponse->AccessAvailabilityMessages->AvailabilityException->Status/Code/Message/AdditionalMessage
                outerRespMessage = "AvailabilityException" + parentInnerDelim;
                totalRespMessage = outerRespMessage;
                if(find(availabilityResponse, "<"+ESLPrefix+"AccessAvailabilityMessages") <> -1 AND find(availabilityResponse, "<"+ESLPrefix+"AccessAvailabilityMessages/>") == -1){ //If messages exist
                    startPos = find(availabilityResponse, ">", find(availabilityResponse, "<"+ESLPrefix+"AccessAvailabilityMessages"))+1;
                    endPos = find(availabilityResponse, "</"+ESLPrefix+"AccessAvailabilityMessages>"); 
                    AccessAvailabilityMessagesList = split(substring(availabilityResponse, startPos, endPos), "</"+ESLPrefix+"AvailabilityException"+">");
                    for message in AccessAvailabilityMessagesList{
                        innerRespMessage = "";
                        if(message <> ""){ //If a message exists
                            status = "ERROR";
                            code = "-1";
                            dispMessage = "No message specified";
                            additionalMessages = "";
                            if(find(message, "<"+ESLPrefix+"Status") <> -1 AND find(message, "<"+ESLPrefix+"Status/>") == -1){
                                status = substring(message, find(message,"<"+ESLPrefix+"Status"+">")+len("<"+ESLPrefix+"Status"+">"), find(message, "</"+ESLPrefix+"Status>"));
                            }
                            if(find(message, "<"+ESLPrefix+"Code") <> -1 AND find(message, "<"+ESLPrefix+"Code/>") == -1){
                                code = substring(message, find(message,"<"+ESLPrefix+"Code"+">")+len("<"+ESLPrefix+"Code"+">"), find(message, "</"+ESLPrefix+"Code>"));
                            }
                            if(find(message, "<"+ESLPrefix+"Message") <> -1 AND find(message, "<"+ESLPrefix+"Message/>") == -1){
                                dispMessage = substring(message, find(message,"<"+ESLPrefix+"Message"+">")+len("<"+ESLPrefix+"Message"+">"), find(message, "</"+ESLPrefix+"Message>"));
                            }
                            //Pull out any additional messages if present
                            if(find(message, "<"+ESLPrefix+"AdditionalMessage") <> -1 AND find(message, "<"+ESLPrefix+"AdditionalMessage/>") == -1){
                                //startPos = find(message, ">", find(message, "<"+ESLPrefix+"AdditionalMessage"))+1;
                                startPos = find(message, "<"+ESLPrefix+"AdditionalMessage");
                                endPos = find(message, "</"+ESLPrefix+"AvailabilityException>");
                                if(endPos == -1){
                                    endPos = len(message);
                                }
                                addtlMessageList = split(substring(message, startPos, endPos), "</"+ESLPrefix+"AdditionalMessage"+">");
                                for addtlMessage in addtlMessageList{
                                    if(find(addtlMessage, "<"+ESLPrefix+"AdditionalMessage>") <> -1){ //If a valid message
                                        additionalMessages = additionalMessages + childValueDelim + substring(addtlMessage, find(addtlMessage, ">") +1);
                                    }
                                }
                            }
                            
                            
                            innerRespMessage = "Type" + childInnerDelim + status + childOuterDelim + "Code" + childInnerDelim + code + childOuterDelim + "Message" + childInnerDelim + dispMessage + additionalMessages + childOuterDelim;
                            totalRespMessage = totalRespMessage + innerRespMessage + parentValueDelim;
                        }
                    }
                }
                if(totalRespMessage == outerRespMessage){
                    totalRespMessage = "";
                }
                else{
                    totalRespMessage = totalRespMessage + parentOuterDelim;
                }
                if(locationResponseString <> "" OR totalRespMessage <> ""){
                    put(retDict, locId, locationResponseString + totalRespMessage);
                }
            }
        }
        //**END PULLING ATTRIBUTES FROM AvailabilityResponse->AccessAvailabilityResponse**//    
        //**END PULLING ATTRIBUTES FROM AvailabilityResponse**//
    }
}

//Add systemRespMessage to dictionary if not blank
if(systemRespMessage <> ""){
    put(retDict, "SYSTEM", systemRespMessage);
}
else{
	put(retDict, "SYSTEM", "");
}
//***************END RESPONSE ASSEMBLY******************//

return retDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_ctlGetConfigAvailability_485337030]]></java_class_name><child_class_names></child_class_names><date_modified>1386687699000</date_modified><guid><![CDATA[testsavvis_338342731]]></guid><_children></_children></bm_function><bm_lib_func_param><id>485337032</id><bm_lib_func_id>485337031</bm_lib_func_id><param_name><![CDATA[environmentName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1386687700000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_338342734]]></guid></bm_lib_func_param><bm_lib_func_param><id>485337033</id><bm_lib_func_id>485337031</bm_lib_func_id><param_name><![CDATA[locationIDArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1386687700000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_338342735]]></guid></bm_lib_func_param><bm_lib_func_param><id>485337034</id><bm_lib_func_id>485337031</bm_lib_func_id><param_name><![CDATA[targetAttrNamesArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1386687700000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_338342736]]></guid></bm_lib_func_param><bm_lib_func_param><id>485337035</id><bm_lib_func_id>485337031</bm_lib_func_id><param_name><![CDATA[attrVsValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1386687700000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_338342737]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>128488105</id><name><en><![CDATA[Is Address Still Valid]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[isAddressStillValid]]></variable_name><description><en><![CDATA[returns true if the Address has been Validated and NOT Changed, and false otherwise ... If this occurs then the address needs to be re-validated before completing the quoting process !]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>128488104</function_id><main_script_text></main_script_text><date_modified>1358564318000</date_modified><guid><![CDATA[testsavvis_127545875]]></guid><_children><bm_function><id>128488104</id><ref_type>16</ref_type><script_text><![CDATA[//*****************************************************************************************************
//** Function:    Address Still Valids (addressStillValid)                                                             **
//** Type:        Commerce Library function                                                          **
//**                                                                                                 **
//** Description: returns true if the Address has been Validated and NOT Changed, false otherwise .. **
//**                                                                                                 **
//** History:     Date     Author     Comment                                                        **
//**              06/05/12 MBelin     VER 63274 - Initial Implementation                             **
//**              06/06/12 MBelin     VER 63307 - Added Logic to allow 'Valid Address Not Found'     **
//*****************************************************************************************************

retVal = false;

// First Case : New Address
if (bANNumber == "New") {

	// For New Addresses, we need to check that the flag is true, AND 
	// that the user has NOT updated any part of the address without
	// Re-Validating the address ... 
	
	if(validatedAddressFlag AND find(validatedAddressString, "!$!") <> -1){
	   
		validatedArray = split(validatedAddressString, "!$!");
		if ( ( (validatedArray[0] == "Use Original Address") AND // VER 63307
		       (validatedArray[1] == "true") ) OR                // VER 63307
		     ( (validatedArray[0] == addressLine1) AND
		       (validatedArray[1] == addressLine2) AND 
		       (validatedArray[2] == city)         AND 
		       (validatedArray[3] == state)        AND 
		       (validatedArray[4] == zip)          AND 
		       (validatedArray[5] == country) ) ){

		    retval = true;
		}
	}

} else { // Second Case : Address comes from BAN

	// This Case is Easy since there are no editable fields - We simply return 
	// the validAddress_quote setting ... 
	retVal = validatedAddressFlag;
}

return retVal;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_isAddressStillValid_128488104]]></java_class_name><child_class_names></child_class_names><date_modified>1358564318000</date_modified><guid><![CDATA[testsavvis_127545874]]></guid><_children></_children></bm_function><bm_lib_func_param><id>128488106</id><bm_lib_func_id>128488105</bm_lib_func_id><param_name><![CDATA[bANNumber]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_127545877]]></guid></bm_lib_func_param><bm_lib_func_param><id>128488107</id><bm_lib_func_id>128488105</bm_lib_func_id><param_name><![CDATA[validatedAddressFlag]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>0</datatype><date_modified>1358564318000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_127545878]]></guid></bm_lib_func_param><bm_lib_func_param><id>128488108</id><bm_lib_func_id>128488105</bm_lib_func_id><param_name><![CDATA[validatedAddressString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_127545879]]></guid></bm_lib_func_param><bm_lib_func_param><id>128488109</id><bm_lib_func_id>128488105</bm_lib_func_id><param_name><![CDATA[addressLine1]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_127545880]]></guid></bm_lib_func_param><bm_lib_func_param><id>128488110</id><bm_lib_func_id>128488105</bm_lib_func_id><param_name><![CDATA[addressLine2]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>5</order_no><guid><![CDATA[testsavvis_127545881]]></guid></bm_lib_func_param><bm_lib_func_param><id>128488111</id><bm_lib_func_id>128488105</bm_lib_func_id><param_name><![CDATA[city]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>6</order_no><guid><![CDATA[testsavvis_127545882]]></guid></bm_lib_func_param><bm_lib_func_param><id>128488112</id><bm_lib_func_id>128488105</bm_lib_func_id><param_name><![CDATA[state]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>7</order_no><guid><![CDATA[testsavvis_127545883]]></guid></bm_lib_func_param><bm_lib_func_param><id>128488113</id><bm_lib_func_id>128488105</bm_lib_func_id><param_name><![CDATA[zip]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>8</order_no><guid><![CDATA[testsavvis_127545884]]></guid></bm_lib_func_param><bm_lib_func_param><id>128488114</id><bm_lib_func_id>128488105</bm_lib_func_id><param_name><![CDATA[country]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>9</order_no><guid><![CDATA[testsavvis_127545885]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>263833300</id><name><en><![CDATA[Encode Address Info]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[encodeAddressInfo]]></variable_name><description><en><![CDATA[VER 56432: Returns Z address info in delimited string. (uses "!$!" delimiter) This will be used in the getRecommendedItemsString2 function and returned in the part comment.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>263833299</function_id><main_script_text></main_script_text><date_modified>1358564313000</date_modified><guid><![CDATA[testsavvis_199194038]]></guid><_children><bm_function><id>263833299</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Address Info String (getAddressInfoString)                       
//** Type:        Utility Library Function                                                                   
//**                                                                                                          
//** Description: Returns the Z/A address info in a delimited string with delimiter of "!$!".  This will
//** 		be used in the getRecommendedItemsString2 function to go into the part comment
//**
//** Parameters:address - pretty address
//**		        addressTech - technical address desc
//**		        addressCountry - country of address
//**		        addressName - ID of address
//**	Return: String
//**                                               
//**                                                                                                          
//** History:     Date     Author       Comment                                                               
//**              11/30/12 STillett     VER 56432 - Extend algorithm to get part hierarchy
//**************************************************************************************************************


return address + "!$!" + addressTech + "!$!" + addressCountry + "!$!" + addressName;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_encodeAddressInfo_263833299]]></java_class_name><child_class_names></child_class_names><date_modified>1358564313000</date_modified><guid><![CDATA[testsavvis_199194037]]></guid><_children></_children></bm_function><bm_lib_func_param><id>263833301</id><bm_lib_func_id>263833300</bm_lib_func_id><param_name><![CDATA[address]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_199194040]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833302</id><bm_lib_func_id>263833300</bm_lib_func_id><param_name><![CDATA[addressTech]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_199194041]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833303</id><bm_lib_func_id>263833300</bm_lib_func_id><param_name><![CDATA[addressCountry]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_199194042]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833304</id><bm_lib_func_id>263833300</bm_lib_func_id><param_name><![CDATA[addressName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_199194043]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>23425746</id><name><en><![CDATA[Get Addon Filter]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getAddonFilter]]></variable_name><description><en><![CDATA[Returns the SvcPkgName of one of the merged products]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>23425745</function_id><main_script_text><![CDATA[products = dict("string");
attrValues = dict("string");

put(products, "baseProduct", "Managed Firewall 2.0 IDC");
put(products, "mergedProduct1", "Managed Firewall CPE");
put(products, "mergedProduct2", "Custom Managed Firewall 1.0");

put(attrValues, "dataCenter", "Other");
put(attrValues, "extraQue1", "Customer Premises");

return util.getAddonFilter(products, attrValues);]]></main_script_text><date_modified>1358564312000</date_modified><guid><![CDATA[LEGACY_23425746]]></guid><_children><bm_function><id>23425745</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Addon Filter (getAddonFilter)                                                           **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Returns the SvcPkgName of one of the merged products                                        **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

canadaProduct = "";
mergedProduct1 = "";
mergedProduct2 = "";
baseProduct = "";
dataCenter = "";
extraQue1 = "";
extraQue2 = "";
extraQue3 = "";
extraQue4 = "";
extraQue5 = "";
extraQue6 = "";
extraQue7 = "";
extraQueAnswered = false;

if(containskey(attrValues, "modelAIP")) { 
	modelAIPInt = 0;
	modelAIP = get(attrValues, "modelAIP"); 
	//Typecast the modelAIP to integer as the data table column is integer
	if(isnumber(modelAIP)) { modelAIPInt = atoi(modelAIP); }
	
	//Lookup the table AcctProd to see if you get any SvcPkgName for the given AIP
	retTbl = bmql("SELECT SvcPkgName FROM AcctProd WHERE AcctProdId=$modelAIPInt");
	for row in retTbl {
		return get(row, "SvcPkgName");
	}
}

if(containskey(products, "canadaProduct")) { canadaProduct = get(products, "canadaProduct"); }
if(containskey(attrValues, "dataCenter")) { dataCenter = get(attrValues, "dataCenter"); }
 
//If canada product is specified then checks data table to see if the combination of that product is
//present with the data center. If returned the canada SvcPkgName will be returned 
if(canadaProduct <> "") {
	retTbl = bmql("SELECT DISTINCT SvcPkgName FROM SvcPkgLocAvailable WHERE SvcPkgName=$canadaProduct AND DataCenter=$dataCenter");
	if(NOT isnull(retTbl)) {
		for row in retTbl {
			return get(row, "SvcPkgName");
		}
	}	
}

if(containskey(products, "mergedProduct1")) { mergedProduct1 = get(products, "mergedProduct1"); }
if(containskey(products, "mergedProduct2")) { mergedProduct2 = get(products, "mergedProduct2"); }

if(containskey(attrValues, "extraQue1")) { extraQue1 = get(attrValues, "extraQue1"); }
if(containskey(attrValues, "extraQue2")) { extraQue2 = get(attrValues, "extraQue2"); }
if(containskey(attrValues, "extraQue3")) { extraQue3 = get(attrValues, "extraQue3"); }
if(containskey(attrValues, "extraQue4")) { extraQue4 = get(attrValues, "extraQue4"); }
if(containskey(attrValues, "extraQue5")) { extraQue5 = get(attrValues, "extraQue5"); }
if(containskey(attrValues, "extraQue6")) { extraQue6 = get(attrValues, "extraQue6"); }
if(containskey(attrValues, "extraQue7")) { extraQue7 = get(attrValues, "extraQue7"); }

//The below if condition checks if any of the extra question is answered
if(upper(extraQue1) == "YES" OR
   upper(extraQue1) == "INTERNAL" OR 
   upper(extraQue1) == "CUSTOMER PREMISES" OR 
   upper(extraQue1) == "OTHER" OR upper(extraQue2) == "OTHER" OR upper(extraQue3) == "OTHER" OR upper(extraQue4) == "OTHER" OR 
   upper(extraQue5) == "OTHER" OR upper(extraQue6) == "OTHER" OR upper(extraQue7) == "OTHER" OR 
   upper(extraQue1) == "CORE" OR
   upper(dataCenter) == "OTHER") {
		extraQueAnswered = true;
}

if((mergedProduct1 <> "" OR mergedProduct2 <> "") AND extraQueAnswered) {
	//If merged product is specified then checks data table to see if the combination of that product is
	//present with the data center. If returned the merged product SvcPkgName will be returned 
	retTbl = bmql("SELECT DISTINCT SvcPkgName FROM SvcPkgLocAvailable WHERE SvcPkgName=$mergedProduct1 AND DataCenter=$dataCenter");
	if(NOT isnull(retTbl)) {
		for row in retTbl {
			if(extraQueAnswered) {
				return get(row, "SvcPkgName");
			}
		}
	}
	
	if(dataCenter == "Other" AND extraQue1 <> "Customer Premises") {
		retTbl = bmql("SELECT DISTINCT SvcPkgName FROM SvcPkgMaster WHERE SvcPkgName=$mergedProduct2");
		if(NOT isnull(retTbl)) {
			for row in retTbl {
				if(extraQueAnswered) {
					return get(row, "SvcPkgName");
				}
			}
		}
	}
	
	//If merged product is specified and it do not have data center then it checks a different data table.
	//If returned the merged product SvcPkgName will be returned 
	retTbl = bmql("SELECT DISTINCT SvcPkgName FROM SvcPkgMaster WHERE SvcPkgName=$mergedProduct1");
	if(NOT isnull(retTbl)) {
		for row in retTbl {
			if(extraQueAnswered) {
				return get(row, "SvcPkgName");
			}
		}
	}
}

//If the product is not merged nor canada then surely it is the base product
if(containskey(products, "baseProduct")) { baseProduct = get(products, "baseProduct"); }
return baseProduct;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getAddonFilter_23425745]]></java_class_name><child_class_names></child_class_names><date_modified>1358564312000</date_modified><guid><![CDATA[LEGACY_23425745]]></guid><_children></_children></bm_function><bm_lib_func_param><id>23425748</id><bm_lib_func_id>23425746</bm_lib_func_id><param_name><![CDATA[products]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1358564312000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_23425748]]></guid></bm_lib_func_param><bm_lib_func_param><id>23425749</id><bm_lib_func_id>23425746</bm_lib_func_id><param_name><![CDATA[attrValues]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1358564312000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_23425749]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>169022517</id><name><en><![CDATA[Get From Email Address]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getFromEmailAddress]]></variable_name><description><en><![CDATA[Returns the from email address that should be used when sending email to users. VER 64123]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>169022516</function_id><main_script_text></main_script_text><date_modified>1358564319000</date_modified><guid><![CDATA[testsavvis_150032438]]></guid><_children><bm_function><id>169022516</id><ref_type>16</ref_type><script_text><![CDATA[return lower(systemName) + "@ma.bigmachines.com";]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getFromEmailAddress_169022516]]></java_class_name><child_class_names></child_class_names><date_modified>1358564319000</date_modified><guid><![CDATA[testsavvis_150032437]]></guid><_children></_children></bm_function><bm_lib_func_param><id>169022518</id><bm_lib_func_id>169022517</bm_lib_func_id><param_name><![CDATA[systemName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564319000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_150032440]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>224741287</id><name><en><![CDATA[Check If Primary Attribute Has Other Value For Array 2]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[checkIfPrimaryAttributeHasOtherValueForArray2]]></variable_name><description><en><![CDATA[For a edit+single select use case for array attribute - check if the other attribute has a value]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>224741286</function_id><main_script_text></main_script_text><date_modified>1366470379000</date_modified><guid><![CDATA[testsavvis_182581671]]></guid><_children><bm_function><id>224741286</id><ref_type>16</ref_type><script_text><![CDATA[//*********************************************************************************************************************
//** Function:    Check If Primary Attribute Has Other Value For Array 2 (checkIfPrimaryAttributeHasOtherValueForArray2)
//** Type:        Utility Library Function                                                                    	     
//**                                                                                                          	     
//** Description: For a edit+single select use case - check if the other attribute has a value                       
//**                                                                                                                 
//** Parameters:  arrayQuantity         - quantity of the array
//**              primaryAttributeArray - primary array attribute                                                    
//**              otherAttributeArray   - other array attribute                                                        
//**                                                                                                                 
//** Return Type: boolean - returns true if at least one instance of otherAttributeArray has value else return false 
//**                                                                                                                 
//** History:     Date     Author       Comment                                                                      
//**              10/01/12 SKharche     VER 64794 - New implementation to support edit+single select scenario       
//**              10/30/12 SKharche     VER 65162 - Created a V2 util to add a new parameter
//**              04/08/13 SKharche     VER 66700 - Check to make sure user do not get null error
//*********************************************************************************************************************

/*
Check if primary attribute and other attribtue are not equal AND other attribute is NOT blank
Use cases - 
	1. For new services if a user selects 'Other' as a option for primary attribute and enter some value in the other attribute
	2. For existing services the system pushes value into the other attribute
*/

primaryAttrSize = sizeofarray(primaryAttributeArray);
otherAttrSize   = sizeofarray(primaryAttributeArray);

indexes = range(arrayQuantity);
for index in indexes {
    // If the index is less than the primaryAttrSize and otherAttrSize then it is safe to run the logic
    // The problem we encountered related to case 3779585 was on importing AIP for Custom Software user was getting null error
    // Adding the condition is a safe way to make sure we have actual indexes present as per indicated by array quantity
    if(index < primaryAttrSize AND index < otherAttrSize) {
        if( primaryAttributeArray[index] <> otherAttributeArray[index] AND otherAttributeArray[index] <> "" ) { 
            return true;	
        }
    }
}

return false;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_checkIfPrimaryAttributeHasOtherValueForArray2_224741286]]></java_class_name><child_class_names></child_class_names><date_modified>1366470380000</date_modified><guid><![CDATA[testsavvis_182581670]]></guid><_children></_children></bm_function><bm_lib_func_param><id>224741288</id><bm_lib_func_id>224741287</bm_lib_func_id><param_name><![CDATA[arrayQuantity]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1366470379000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_182581673]]></guid></bm_lib_func_param><bm_lib_func_param><id>224741289</id><bm_lib_func_id>224741287</bm_lib_func_id><param_name><![CDATA[primaryAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1366470379000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_182581674]]></guid></bm_lib_func_param><bm_lib_func_param><id>224741290</id><bm_lib_func_id>224741287</bm_lib_func_id><param_name><![CDATA[otherAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1366470379000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_182581675]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>191391238</id><name><en><![CDATA[Get Count Of Value In Array]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getCountOfValueInArray]]></variable_name><description><en><![CDATA[Return the number of times value is found in input array. For eg: if value is 'No' and array has the value 'No' present in it 4 times then return 4]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>3</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>191391237</function_id><main_script_text></main_script_text><date_modified>1358564315000</date_modified><guid><![CDATA[testsavvis_162910696]]></guid><_children><bm_function><id>191391237</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Get Count Of Value In Array (getCountOfValueInArray)                                      **
//** Type:        Utility Library Function                                                                  **
//**                                                                                                        **
//** Description: Return the number of times the value is found in input array                              **
//**              For eg: if value is 'No' and array has the value 'No' present in it 4 times then return 4 **
//**                                                                                                        **
//** History:     Date     Author       Comment                                                             **
//**              08/23/12 SKharche     Implementation to support Special Offers                            **
//************************************************************************************************************

count = 0;

//Count the number of entries inside the array that equals value
for currentValue in inputArray {
	if(currentValue == value) {
		count = count + 1;
	}
}

return count;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getCountOfValueInArray_191391237]]></java_class_name><child_class_names></child_class_names><date_modified>1358564316000</date_modified><guid><![CDATA[testsavvis_162910695]]></guid><_children></_children></bm_function><bm_lib_func_param><id>191391239</id><bm_lib_func_id>191391238</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564315000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_162910698]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391240</id><bm_lib_func_id>191391238</bm_lib_func_id><param_name><![CDATA[inputArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564315000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_162910699]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>177279314</id><name><en><![CDATA[Get Retained Status]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getRetainedStatus]]></variable_name><description><en><![CDATA[Returns retained Status of line item.  Input: optionsString_line, pricingString_line, term value in months.  Output: "F" = fully retained, "P" = partially retained, "N" = not retained]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>177279313</function_id><main_script_text></main_script_text><date_modified>1368886222000</date_modified><guid><![CDATA[testsavvis_154222315]]></guid><_children><bm_function><id>177279313</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Get Retained Status(getRetainedStatus)
//** Type:        Utility Library Function   
//**
//** Description: Returns retained Status of line item. 
//** 
//** Param:       OptionsString - line level attribute optionsString_line
//**              pricingString - line level attribute pricingString_line
//**              termValue - number of months specified for chosen term (display term)
//**
//** Return Type: string value that indicates the retained status of the line item.
//**                "F" = fully retained (all retained values for the options/line item are true)
//**                "P" = partially retained (more than one, but not all of the values for the options/line item is true)
//**                "N" = not retained (no values for the options/line item are true)
//**
//** History:     Date     Author       Comment 
//**	          08/14/12 STillett    VER 64097 - Created in order to assess negative discount abilities
//**              04/10/13 Skharche    VER 66620 - Decodes a hash map and get value for the specified key
//**              04/24/13 Skharche    VER 66601 - Update retainedPriceStatus correctly
//************************************************************************************************************

//Holds the total number of retains we step across
totalRetains = 0;

//Holds only the number of "true" retains we step across
trueRetains = 0;

//search the options string to find out how many items are retained/not retained
optionsArray = split(OptionsString, "!$!");
for option in optionsArray {
	if(find(option, "^" + termValue + "!%!") <> -1) {
		if(find(option, "retained$ATTR$true") <> -1){
			totalRetains = totalRetains + 1;
			trueRetains = trueRetains + 1;
		}
		else {
			totalRetains = totalRetains + 1;
		}
	}
}

//Now look at the pricing string to find the retains
pricesArray = split(pricingString, "!$!");
prices = range(sizeofarray(pricesArray));
for price in prices {
	if(find(pricesArray[price], "^" + termValue + "!%!") <> -1) {
		if(find(pricesArray[price], "retained$ATTR$true") <> -1){
			totalRetains = totalRetains + 1;
			trueRetains = trueRetains + 1;
		}
		else {
			totalRetains = totalRetains + 1;
		}
	}
}

//Now, if the total Retains value is greater than zero, and the true retains value is the same, then
//the status is Fully Retained, "F"
if((totalRetains > 0) AND (totalRetains == trueRetains)) {
	return "F";
}
// If there are retains in the price point and there is at least 1 true retain then the status is P
elif((totalRetains > 0) AND (trueRetains > 0)) {
    return "P";
} 
// Default use case: the status should be N
else {
	return "N";
}]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getRetainedStatus_177279313]]></java_class_name><child_class_names></child_class_names><date_modified>1368886222000</date_modified><guid><![CDATA[testsavvis_154222314]]></guid><_children></_children></bm_function><bm_lib_func_param><id>177279315</id><bm_lib_func_id>177279314</bm_lib_func_id><param_name><![CDATA[optionsString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1368886222000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_154222317]]></guid></bm_lib_func_param><bm_lib_func_param><id>177279316</id><bm_lib_func_id>177279314</bm_lib_func_id><param_name><![CDATA[pricingString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1368886222000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_154222318]]></guid></bm_lib_func_param><bm_lib_func_param><id>177279317</id><bm_lib_func_id>177279314</bm_lib_func_id><param_name><![CDATA[termValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1368886222000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_154222319]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>392706733</id><name><en><![CDATA[Decode Name Value Pair]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[decodeNameValuePair]]></variable_name><description><en><![CDATA[VER 66539: Decodes name value pair and returns a dictionary]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>15</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>392706732</function_id><main_script_text></main_script_text><date_modified>1366470381000</date_modified><guid><![CDATA[testsavvis_283732636]]></guid><_children><bm_function><id>392706732</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Decode Name Value Pair(decodeNameValuePair)
//** Type:        Utility Library Function   
//**
//** Description: Decodes name value pair and returns a dictionary
//** 
//** Param:       encodedNameValuePairs - delimited string containing encoded name-value pairs
//**              nameValueDelimiter    - delimiter between name and value
//**              pairDelimiter         - delimiter between multiple nameValuePairs
//**
//** Return type: String dictionary - key=name, value=value for that name
//**
//** History:     Date     Author       Comment 
//**              03/25/13 Skharche    VER 66539 - CTL Code Reconciliation    
//************************************************************************************************************

nameValDelim = nameValueDelimiter;
pairDelim    = pairDelimiter;

index = 0;

retDict = dict("string");

// If the delimiters are blank then use default delimiters
if(nameValDelim == "") { nameValDelim = "="; } 
if(pairDelim == "") { pairDelim = "^"; }

nameValuePairsArray = split(encodedNameValuePairs, pairDelim);
for nameValuePair in nameValuePairsArray {
    tempData = split(nameValuePair, nameValDelim);
    if(tempData[0] <> "") {
        put(retDict, tempData[0], tempData[1]);
    }
}

return retDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_decodeNameValuePair_392706732]]></java_class_name><child_class_names></child_class_names><date_modified>1366470381000</date_modified><guid><![CDATA[testsavvis_283732635]]></guid><_children></_children></bm_function><bm_lib_func_param><id>392706734</id><bm_lib_func_id>392706733</bm_lib_func_id><param_name><![CDATA[encodedNameValuePairs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1366470381000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_283732638]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706735</id><bm_lib_func_id>392706733</bm_lib_func_id><param_name><![CDATA[nameValueDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1366470381000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_283732639]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706736</id><bm_lib_func_id>392706733</bm_lib_func_id><param_name><![CDATA[pairDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1366470381000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_283732640]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>353423705</id><name><en><![CDATA[Convert Number to String]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[convertNumberToString]]></variable_name><description><en><![CDATA[Takes a regular or scientific number and converts it to string.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>353423704</function_id><main_script_text></main_script_text><date_modified>1364429269000</date_modified><guid><![CDATA[testsavvis_261049888]]></guid><_children><bm_function><id>353423704</id><ref_type>16</ref_type><script_text><![CDATA[//*****************************************************************************************************
//** Function:    Convert Number to String (convertNumberToString)                                              
//** Type:        Util                                                                 
//**                                                                                                 
//** Description: Regular or scientific number is converted to string.
//**                 
//** Parameters:  number: number that needs to be converted into string
//**                                                                                            
//** History:     Date     Author     Comment                                                        
//**              02/28/13 SKharche   VER 66352 - Pass MRC/NRC as a String for divisible Products 
//**              03/26/13 SKharche   VER 66598 - Fixed bug with negative numbers
//*****************************************************************************************************

inputStr = string(number);

if(find(inputStr, "E") <> -1 AND find(inputStr, ".") <> -1) {
    exponentPos = 0;
    
    mantissa = "";
    exponent = "";
    
    // Find the position of the exponent namely E
    exponentPos = find(inputStr, "E");
    
    // Get the mantissa of the number eg: 5.012E8 then mantissa will be 5012
    mantissa = replace(substring(inputStr, 0, exponentPos), ".", "");
    
    // Get the exponent of the number eg: 5.012E8 then exponent will be 8
    exponent = substring(inputStr, exponentPos+1);
    
    newExponent = 0;
    if(isnumber(exponent)) {
        newExponent = atoi(exponent);
    }
        
    // VER 66598 - Fixed bug with negative numbers
    // If the number starts with - meaning its a negative number then the exponent is also negative
    if(startswith(exponent, "-")) {
        newExponent = newExponent * -1;
        
        // Decimal point should be moved exponent-1 places to the left
        indexes = range(newExponent-1); 
        mantissa = replace(mantissa, "-", "");
        
        // Below code will add 0 at the start of the mantissa. eg: -5.012E-8 with mantissa 5012 and exponent -8 then resulting number is -0.00000005012
        for index in indexes {
            mantissa = "0" + mantissa;
        }
        mantissa = "0." + mantissa;
    }
    else {
        // Calculate the number of zeros to be added to the mantissa to convert it into flat string
        numOfDigitsToAdd = newExponent - len(mantissa) + 1;
      
        // If numOfDigitsToAdd is negative then we need to handle it differently
        // for eg: 1.2345315229999999E7 should become 12345315.229999999
        if(numOfDigitsToAdd < 0) {
            decimalPos = newExponent + 1;
            mantissa = substring(mantissa, 0, decimalPos) + "." + substring(mantissa, decimalPos);
        }
        else {
            // eg: 5.012E8 with mantissa as 5012 and exponent as 8 then number of zeros to be added are 5
            indexes = range(numOfDigitsToAdd); 
            for index in indexes {
                mantissa = mantissa + "0";
            }
        }
    }
    
    inputStr = mantissa;
}
    
return inputStr;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_convertNumberToString_353423704]]></java_class_name><child_class_names></child_class_names><date_modified>1364429270000</date_modified><guid><![CDATA[testsavvis_261049887]]></guid><_children></_children></bm_function><bm_lib_func_param><id>353423706</id><bm_lib_func_id>353423705</bm_lib_func_id><param_name><![CDATA[number]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>4</datatype><date_modified>1364429269000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_261049890]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>304182767</id><name><en><![CDATA[Get Web Service Response]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getWebServiceResponse]]></variable_name><description><en><![CDATA[This util can be called to return the output of the specified webservice.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>304182766</function_id><main_script_text></main_script_text><date_modified>1385055370000</date_modified><guid><![CDATA[sbsavvis_234665165]]></guid><_children><bm_function><id>304182766</id><ref_type>16</ref_type><script_text><![CDATA[//*****************************************************************************************************
//** Function:    Get Web Service Response (getWebServiceResponse)                                              
//** Type:        Util                                                                 
//**                                                                                                 
//** Description: Calls the specified web service and returns XML output
//**                 
//** Parameters:  serviceName: holds the URL extension for the service to be called
//**              inputXMLFileName: holds the file name of the XML file to use (this is not the path,
//**                 just the file name) EG: postQuoteEvent.xml
//**              keywordsArray: holds the keywords to replace in the XML file (SESSIONID, TRANSACTIONID)
//**              keywordsVsValuesDict: holds the values of the keywords that need to be replaced
//**                 in the inputXML
//**              environmentName: the system variable: _system_supplier_company_name must be passed 
//**                 into this util
//**                                                                                            
//** History:     Date     Author     Comment                                                        
//**              01/15/13 STillett   VER 65834: Create util to call webservices
//**              11/19/13 SKharche   BIGMACH-3023 - Change URL prefix to support layer 7
//*****************************************************************************************************
inputXML = "";
inputHeaders = dict("string");

inputXML = urldatabypost("https://" + lower(environmentName) + 
                         ".bigmachines.com/bmfsweb/" + lower(environmentName) + 
                         "/image/WebServices/" + inputXMLFileName, "", "");

for each in keywordsArray {
    inputXML = replace(inputXML, each, get(keywordsVsValuesDict, each));
}

put(inputHeaders, "Content-Type", "text/xml");

urlPrefix = "";
// BIGMACH-3023 - Update URL prefix to support Layer 7. If this is not present then use the regular prefix. This 
// is to ensure backward compability and to provide flexibility to turn ON/OFF layer 7
urlPrefixSet = bmql("SELECT Value FROM GlobalVars WHERE Keyword='SVVS_URL_PREFIX_BMIWS'"); 
for record in urlPrefixSet {
    urlPrefix = get(record, "Value");
}

if(urlPrefix == "") {
    urlPrefixSet = bmql("SELECT Value FROM GlobalVars WHERE Keyword='SVVS_URL_PREFIX'"); 
    for record in urlPrefixSet {
        urlPrefix = get(record, "Value");
    }
}

inputURL = urlPrefix + "BMWebServices/" + serviceName;

outputXML = urldatabypost(inputURL, inputXML, "Not Available", inputHeaders);
return outputXML;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getWebServiceResponse_304182766]]></java_class_name><child_class_names></child_class_names><date_modified>1385055370000</date_modified><guid><![CDATA[sbsavvis_234665164]]></guid><_children></_children></bm_function><bm_lib_func_param><id>304182768</id><bm_lib_func_id>304182767</bm_lib_func_id><param_name><![CDATA[serviceName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1385055370000</date_modified><order_no>1</order_no><guid><![CDATA[sbsavvis_234665167]]></guid></bm_lib_func_param><bm_lib_func_param><id>304182769</id><bm_lib_func_id>304182767</bm_lib_func_id><param_name><![CDATA[environmentName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1385055370000</date_modified><order_no>2</order_no><guid><![CDATA[sbsavvis_234665168]]></guid></bm_lib_func_param><bm_lib_func_param><id>304182770</id><bm_lib_func_id>304182767</bm_lib_func_id><param_name><![CDATA[inputXMLFileName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1385055370000</date_modified><order_no>3</order_no><guid><![CDATA[sbsavvis_234665169]]></guid></bm_lib_func_param><bm_lib_func_param><id>304182771</id><bm_lib_func_id>304182767</bm_lib_func_id><param_name><![CDATA[keywordsArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1385055370000</date_modified><order_no>4</order_no><guid><![CDATA[sbsavvis_234665170]]></guid></bm_lib_func_param><bm_lib_func_param><id>304182772</id><bm_lib_func_id>304182767</bm_lib_func_id><param_name><![CDATA[keywordsVsValuesDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1385055370000</date_modified><order_no>5</order_no><guid><![CDATA[sbsavvis_234665171]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>623982863</id><name><en><![CDATA[Create HTML Menu]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[createHTMLMenu]]></variable_name><description><en><![CDATA[BIGMACH-2551 - Creates a HTML menu based on the key and values specified]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>623982862</function_id><main_script_text></main_script_text><date_modified>1379768472000</date_modified><guid><![CDATA[testsavvis_438204769]]></guid><_children><bm_function><id>623982862</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Create HTML Menu(createHTMLMenu)
//** Type:        Utility Library Function   
//**
//** Description: Creates a HTML menu based on the key and values specified
//** 
//** Param:       keyArray      - internal values or ids of the menu option
//**              valuesArray   - display values of the menu option
//**              selectedKey   - key of current user selection
//**              attributeName - name of the target attribtue that needs to be set with the selected option
//**              extraInfoDict - hash map containing any extra information needed for this function
//**                              added as a protection to allow future scalability 
//**                              Valid key: callingProcess, values: config or commerce
//**
//** Return type: string
//**
//** History:     Date     Author       Comment 
//**              08/15/13 Skharche     BIGMACH-2551 - Create a HTML menu based on the key and values specified
//**              09/13/13 RConaghan    US1885       - Add extraInfoDict param. Currentl checking for key of
//**                                                   "calling process". Values of "config", "commerce".
//************************************************************************************************************

// NOTE: This code is duplicate to the util Create HTML Dynmaic Menu. Once we get function calling functions
//       then we will consolidate these 2 utils

// Both key and value array should be of same size for us to procede
if(sizeofarray(keyArray) <> sizeofarray(valuesArray)) {
    return "";
}

//@RConaghan - US1885: Set the jQuery call for the menu to handle differences between commerce & config
onChangeQuery = "$(\"input[name=" + attributeName + "]\")"; //Default in value for commerce calls. Only change if user explicityly calls from config.
if(containskey(extraInfoDict, "callingProcess")) {
    if(lower(get(extraInfoDict, "callingProcess")) == "config"){
		onChangeQuery = "jQuery(\"#" + attributeName + "\")";
	}
}

ret = "<select id=\"" + selectedKey + "\" onchange='"+onChangeQuery+".val($(this).val());' style=\"width: 100%\">";

// Create the blank option string.
ret = ret + "<option value=\"\"></option>";

index = 0;
for value in valuesArray {
	dispVal = value;
	intVal  = keyArray[index];
	index   = index + 1;
    
	// Check to see if the option is the current selected value. If so, make option the default selected value.
	// Also, set hasCurrentValue to true;
	if(intVal == selectedKey){
		ret = ret + "<option value=\"" + intVal + "\" selected=\"selected\">" + dispVal + "</option>";
	}
	// Create a normal option otherwise
	else {
		ret = ret + "<option value=\"" + intVal + "\">" + dispVal + "</option>";
	}
}

// Close out the menu tags
ret = ret + "</select>";

return ret;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_createHTMLMenu_623982862]]></java_class_name><child_class_names></child_class_names><date_modified>1379768473000</date_modified><guid><![CDATA[testsavvis_438204768]]></guid><_children></_children></bm_function><bm_lib_func_param><id>623982864</id><bm_lib_func_id>623982863</bm_lib_func_id><param_name><![CDATA[keyArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1379768472000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_438204771]]></guid></bm_lib_func_param><bm_lib_func_param><id>623982865</id><bm_lib_func_id>623982863</bm_lib_func_id><param_name><![CDATA[valuesArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1379768472000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_438204772]]></guid></bm_lib_func_param><bm_lib_func_param><id>623982866</id><bm_lib_func_id>623982863</bm_lib_func_id><param_name><![CDATA[selectedKey]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1379768472000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_438204773]]></guid></bm_lib_func_param><bm_lib_func_param><id>623982867</id><bm_lib_func_id>623982863</bm_lib_func_id><param_name><![CDATA[attributeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1379768472000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_438204774]]></guid></bm_lib_func_param><bm_lib_func_param><id>623982868</id><bm_lib_func_id>623982863</bm_lib_func_id><param_name><![CDATA[extraInfoDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1379768472000</date_modified><order_no>5</order_no><guid><![CDATA[testsavvis_468669103]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>485337045</id><name><en><![CDATA[CTL Bundle Promo]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[ctlBundlePromo]]></variable_name><description><en><![CDATA[BIGMACH-2001/US1051: This will return a Bundle Promo code from the ctlBundlePromos data table.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>485337044</function_id><main_script_text></main_script_text><date_modified>1371905638000</date_modified><guid><![CDATA[testsavvis_338381694]]></guid><_children><bm_function><id>485337044</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Data Bundle Promos                                    								
//** Type:        Config Library Function                                                                   
//**                                                                                                        
//** Description: Used to query the ctlBundlePromos table, to return promo which will be grabed by			
//**        rec. item rules and added to the Tech Desc. string in config. Return: promo code.               
//**       
//** Parameters:  bundle: This is the dbnDataBundleArrAtt attribute
//**              equipment: This is the dbnEquipmentArrAtt attribute
//**              maintenance: This is the dbnMaintenanceArrAtt attribute
//**                                                                                                
//** History:     Date     Author       Comment   
//**              05/20/13 SKharche     BIGMACH-2001 CTL code reconciliation                                                         
//**                       BBarnhart    US1051 Initial implementation                    											
//**************************************************************************************************************

promoArray = string[];

// Grab the Promo for this configuration
qryRes = bmql("SELECT PromoCode FROM ctlBundlePromos WHERE Bundle = $bundle AND Equipment = $equipment AND Maintenance = $maintenance");
for res in qryRes {
    append(promoArray, get(res,"PromoCode"));
}
return promoArray;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_ctlBundlePromo_485337044]]></java_class_name><child_class_names></child_class_names><date_modified>1371905638000</date_modified><guid><![CDATA[testsavvis_338381693]]></guid><_children></_children></bm_function><bm_lib_func_param><id>485337046</id><bm_lib_func_id>485337045</bm_lib_func_id><param_name><![CDATA[bundle]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905638000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_338381696]]></guid></bm_lib_func_param><bm_lib_func_param><id>485337047</id><bm_lib_func_id>485337045</bm_lib_func_id><param_name><![CDATA[equipment]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905638000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_338381697]]></guid></bm_lib_func_param><bm_lib_func_param><id>485337048</id><bm_lib_func_id>485337045</bm_lib_func_id><param_name><![CDATA[maintenance]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905638000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_338381698]]></guid></bm_lib_func_param><bm_lib_func_param><id>485337049</id><bm_lib_func_id>485337045</bm_lib_func_id><param_name><![CDATA[extraInfoDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1371905638000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_338381699]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>224741294</id><name><en><![CDATA[Get Values For Primary Attribute For Array 2]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getValuesForPrimaryAttributeForArray2]]></variable_name><description><en><![CDATA[For a edit+single select use case for array attribute - get valid values for primary attribute based on other attribute]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>224741293</function_id><main_script_text></main_script_text><date_modified>1358564317000</date_modified><guid><![CDATA[testsavvis_182581761]]></guid><_children><bm_function><id>224741293</id><ref_type>16</ref_type><script_text><![CDATA[//*********************************************************************************************************************
//** Function:    Get Values For Primary Attribute For Array 2 (getValuesForPrimaryAttributeForArray2)                  
//** Type:        Utility Library Function                                                                    	     
//**                                                                                                          	     
//** Description: For a edit+single select use case - get valid values for primary attribute based on other attribute
//**                                                                                                                 
//** Parameters:  attributeVariableName - variable name of the primary attribute                                     
//**              arrayQuantity         - quantity of the array
//**   	          primaryAttributeArray - primary array attribute                                                    
//**              otherAttributeArray   - other array attribute                                                        
//**                                                                                                                 
//** Return Type: string[] - return array of valid values for primary attribute                                      
//**                                                                                                                 
//** History:     Date     Author       Comment                                                                      
//**              10/01/12 SKharche     VER 64794 - New implementation to support edit+single select scenario        
//**              10/30/12 SKharche     VER 65162 - Created a V2 util to add a new parameter
//*********************************************************************************************************************

/*
Get valid values for primary attribute 
Use cases - 
	1. For new services if a user selects 'Other' as a option for primary attribute and enters some value in the other attribute
	   If the newly entered value in the other attribute is a valid option for primary attribute add it to the return array
	2. For existing services the system pushes value into the other attribute
	   If the newly entered value in the other attribute is a valid option for primary attribute add it to the return array else add 'Other' to the return array
*/

retArr = string[];
indexes = range(arrayQuantity);
for index in indexes {
	found = false;
	
	//Legacy values are identified as * in their display value
	//Checks the data table to get the display values for the combination of attribute and either display value or value of the other attribute
	legacyValue = otherAttributeArray[index] + "*";
	otherAttributeValue = otherAttributeArray[index];
	retTbl = bmql("SELECT DisplayValue FROM AttributeValues WHERE AttributeVarName=$attributeVariableName AND (DisplayValue=$otherAttributeValue OR DisplayValue=$legacyValue)");
	for row in retTbl {
		result = get(row, "DisplayValue");
		found = true;
	}
	
	//If the other attribute's value is not a valid option for the primary attribute and it is not blank then set the primary attribute to 'Other'
	if(NOT found AND otherAttributeArray[index] <> "") { 
		append(retArr, "Other"); 
	}
	//If the other attribute's value is a valid option for the primary attribute then set the other attribute to primary attribute
	elif(otherAttributeArray[index] <> "") { 
		append(retArr, otherAttributeArray[index]); 
	}
	//Default case - set the primary attribtue to itself
	else {
		append(retArr, primaryAttributeArray[index]);
	}
}

return retArr;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getValuesForPrimaryAttributeForArray2_224741293]]></java_class_name><child_class_names></child_class_names><date_modified>1358564317000</date_modified><guid><![CDATA[testsavvis_182581760]]></guid><_children></_children></bm_function><bm_lib_func_param><id>224741295</id><bm_lib_func_id>224741294</bm_lib_func_id><param_name><![CDATA[attributeVariableName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564317000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_182581763]]></guid></bm_lib_func_param><bm_lib_func_param><id>224741296</id><bm_lib_func_id>224741294</bm_lib_func_id><param_name><![CDATA[arrayQuantity]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1358564317000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_182581764]]></guid></bm_lib_func_param><bm_lib_func_param><id>224741297</id><bm_lib_func_id>224741294</bm_lib_func_id><param_name><![CDATA[primaryAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564317000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_182581765]]></guid></bm_lib_func_param><bm_lib_func_param><id>224741298</id><bm_lib_func_id>224741294</bm_lib_func_id><param_name><![CDATA[otherAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564317000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_182581766]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>392706727</id><name><en><![CDATA[Get Event 2]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getEvent2]]></variable_name><description><en><![CDATA[VER 66620 - Decodes a hash map and get value for the specified key]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>15</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>392706726</function_id><main_script_text></main_script_text><date_modified>1366470380000</date_modified><guid><![CDATA[testsavvis_298653626]]></guid><_children><bm_function><id>392706726</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Get Event 2(getEvent2)
//** Type:        Utility Library Function   
//**
//** Description: Decodes a hash map and get value for the specified key
//** 
//** Param:       eventString - String containing the data that becomes value in the hash map
//**              eventKey    - String containing key that becomes key in the hash map
//**                            valid keys: CREDIT, CAPACITY, DA, SE, SOW
//**
//** Return type: String dictionary - returns data for a specified key
//**              NOTE: if the event is NOT present in the eventString then hand back 0 as TIMESTAMP
//**
//** History:     Date     Author       Comment 
//**              04/10/13 Skharche    VER 66620 - Decodes a hash map and get value for the specified key
//************************************************************************************************************

/* LIST of valid INPUT keys
    CREDIT
    CAPACITY
    DA
    SE
    SOW
*/

/* LIST of valid OUTPUT keys
    TIMESTAMP
    MRC
    LAST_APPROVAL_DATE
*/

nameValDelim = "=";
pairDelim    = "!^!";

keyVsEventDict = dict("string");

// The internal key representation is the pretty key + 3 underscore bars
internalEventKey = eventKey + "___";

eventNameValuePairs = split(eventString, pairDelim);
for eventNameValuePair in eventNameValuePairs {
    if(startswith(eventNameValuePair, internalEventKey)) {
        // Seperate name and the value
        nameValueData = split(eventNameValuePair, nameValDelim);
        
        // replace the internal key with the pretty key and then add it to the return dictionary
        // eg: CREDIT__MRC will become MRC
        put(keyVsEventDict, replace(nameValueData[0], internalEventKey, ""), nameValueData[1]);
    }
}

// If the eventKey is not present in the eventString then populate the timestamp as 0
// This is important, otherwise checkReapprovalNeeded util will not function correctly
if(find(eventString, internalEventKey) == -1) {
    put(keyVsEventDict, "TIMESTAMP", "0");
}

return keyVsEventDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getEvent2_392706726]]></java_class_name><child_class_names></child_class_names><date_modified>1366470380000</date_modified><guid><![CDATA[testsavvis_298653625]]></guid><_children></_children></bm_function><bm_lib_func_param><id>392706728</id><bm_lib_func_id>392706727</bm_lib_func_id><param_name><![CDATA[eventString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1366470380000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_298653628]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706729</id><bm_lib_func_id>392706727</bm_lib_func_id><param_name><![CDATA[eventKey]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1366470380000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_298653629]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>191391244</id><name><en><![CDATA[Get AddOns If NOT Deletable]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getAddOnsIfNOTDeletable]]></variable_name><description><en><![CDATA[Used to get list of all the add-ons to constrain if they are not deletable]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>191391243</function_id><main_script_text></main_script_text><date_modified>1358564309000</date_modified><guid><![CDATA[testsavvis_154222430]]></guid><_children><bm_function><id>191391243</id><ref_type>16</ref_type><script_text><![CDATA[//*********************************************************************************************************************
//** Function:    Get AddOns If NOT Deletable (getAddOnsIfNOTDeletable)                                      	     **
//** Type:        Utility Library Function                                                                    	     **
//**                                                                                                          	     **
//** Description: Used to get list of all the add-ons to constrain if they are not deletable                 	     **
//**                                                                                                                 **
//** Parameters:  templateID - special offer id, has a value if the addon is imported from a special offer           **
//**              addonVsAddonDataDict - dictionary with key as addon name and value of isDeletable array attribute  **
//**                                     or action array attribute                                                   **
//**                                                                                                                 **
//** Return Type: string - if addon that is not deletable or changeable is found then delimited string of addons     **
//**                        to be constrained else returns empty string                                              **
//**                                                                                                                 **
//** History:     Date     Author       Comment                                                                      **
//**              08/14/12 SKharche     New implementation to support Special Offer Is Deletable and Change scenario **
//**                                    Supports VER 62770                                                           **
//*********************************************************************************************************************

listOfAddons = string[];

if(containskey(addonVsAddonDataDict, "addonArray")) {
	addonArray = string[];
	addonArray = get(addonVsAddonDataDict, "addonArray");
	for addon in addonArray {
		if(containskey(addonVsAddonDataDict, addon)) {
			if(findinarray(get(addonVsAddonDataDict, addon), "No") > -1 OR
			   findinarray(get(addonVsAddonDataDict, addon), "Change") > -1 OR 
			   findinarray(get(addonVsAddonDataDict, addon), "Delete") > -1) {
				append(listOfAddons, addon);
			}
		}
	}
}

if(isempty(listOfAddons)) {
	return "";
}

return join(listOfAddons, "|^|");]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getAddOnsIfNOTDeletable_191391243]]></java_class_name><child_class_names></child_class_names><date_modified>1358564309000</date_modified><guid><![CDATA[testsavvis_154222429]]></guid><_children></_children></bm_function><bm_lib_func_param><id>191391245</id><bm_lib_func_id>191391244</bm_lib_func_id><param_name><![CDATA[templateID]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564309000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_154222432]]></guid></bm_lib_func_param><bm_lib_func_param><id>191391246</id><bm_lib_func_id>191391244</bm_lib_func_id><param_name><![CDATA[addonVsAddonDataDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1358564309000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_160403227]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>25542011</id><name><en><![CDATA[Get SOW Pricing Total]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getSOWPricingTotal]]></variable_name><description><en><![CDATA[Returns the summation of all the total per item in an array]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>2</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>25542010</function_id><main_script_text></main_script_text><date_modified>1358564312000</date_modified><guid><![CDATA[LEGACY_25542011]]></guid><_children><bm_function><id>25542010</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get SOW Pricing Total (getSOWPricingTotal)                                                  **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Returns the summation of all the total per item in an array                                 **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

total = 0.0;
indexes = range(arrayQuantity);

//Loops through the array and adds all the total per item to get the summation
for index in indexes {
	total = total + totalPerItem[index];
}
return total;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getSOWPricingTotal_25542010]]></java_class_name><child_class_names></child_class_names><date_modified>1358564312000</date_modified><guid><![CDATA[LEGACY_25542010]]></guid><_children></_children></bm_function><bm_lib_func_param><id>25542013</id><bm_lib_func_id>25542011</bm_lib_func_id><param_name><![CDATA[arrayQuantity]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1358564312000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_25542013]]></guid></bm_lib_func_param><bm_lib_func_param><id>25542014</id><bm_lib_func_id>25542011</bm_lib_func_id><param_name><![CDATA[totalPerItem]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>8</datatype><date_modified>1358564312000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_25542014]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>353423720</id><name><en><![CDATA[Reset Pricing]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[resetPricing]]></variable_name><description><en><![CDATA[Takes a line's document number and wipes all the pricing for it.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>353423719</function_id><main_script_text></main_script_text><date_modified>1376745602000</date_modified><guid><![CDATA[testsavvis_261046349]]></guid><_children><bm_function><id>353423719</id><ref_type>16</ref_type><script_text><![CDATA[//*******************************************************************************************************
//**	Util: Reset Pricing
//**
//**    Input: docNumArr - array of document numbers to wipe pricing
//**	       resetTotals - do we reset the quote level totals (
//**    Return type: String: string that clears all pricing attributes
//**
//**    History:
//**    02/28/13 STillett     VER 66296 - creation
//**    04/23/13 STillett     VER 66895 - remove reference to deprecated attributes
//**    07/22/13 SKharche     BIGMACH-2285 - remove reference to deprecated attributes
//*******************************************************************************************************
totalGroupsArr = range(25);
ret = "";
for docNum in docNumArr{
    ret = ret + docNum + "~capExTerm1_line~0.00|" 
    + docNum + "~capExTerm2_line~0.00|" 
    + docNum + "~capExTerm3_line~0.00|"
    + docNum + "~opExMonthlyTerm1_line~0.00|" 
    + docNum + "~opExMonthlyTerm2_line~0.00|" 
    + docNum + "~opExMonthlyTerm3_line~0.00|"
    + docNum + "~opExAnnualTerm1_line~0.00|" 
    + docNum + "~opExAnnualTerm2_line~0.00|" 
    + docNum + "~opExAnnualTerm3_line~0.00|"
    + docNum + "~term1NewNet_line~0.00|" 
    + docNum + "~term2NewNet_line~0.00|"
    + docNum + "~term3NewNet_line~0.00|"
    + docNum + "~term1ExtNewNet_line~0.00|"
    + docNum + "~term2ExtNewNet_line~0.00|"
    + docNum + "~term3ExtNewNet_line~0.00|"
    + docNum + "~term1OldNet_line~0.00|"
    + docNum + "~term2OldNet_line~0.00|"
    + docNum + "~term3OldNet_line~0.00|"
    + docNum + "~term1QuoteValue_line~0.00|"
    + docNum + "~term2QuoteValue_line~0.00|"
    + docNum + "~term3QuoteValue_line~0.00|"
    + docNum + "~term1PriceStatus_line~|"
    + docNum + "~term2PriceStatus_line~|"
    + docNum + "~term3PriceStatus_line~|"
    + docNum + "~term1ContractType_line~NYP|"
    + docNum + "~term2ContractType_line~NYP|"
    + docNum + "~term3ContractType_line~NYP|"
    + docNum + "~term1ExtListMRC_line~0.00|"
    + docNum + "~term2ExtListMRC_line~0.00|"
    + docNum + "~term3ExtListMRC_line~0.00|"
    + docNum + "~term1ExtListNRC_line~0.00|"
    + docNum + "~term2ExtListNRC_line~0.00|"
    + docNum + "~term3ExtListNRC_line~0.00|"
    + docNum + "~term1ExtNetMRC_line~0.00|"
    + docNum + "~term2ExtNetMRC_line~0.00|"
    + docNum + "~term3ExtNetMRC_line~0.00|"
    + docNum + "~term1ExtNetNRC_line~0.00|"
    + docNum + "~term2ExtNetNRC_line~0.00|"
    + docNum + "~term3ExtNetNRC_line~0.00|"
    + docNum + "~term1MonthlyList_line~0.00|"
    + docNum + "~term2MonthlyList_line~0.00|"
    + docNum + "~term3MonthlyList_line~0.00|"
    + docNum + "~term1MonthlyNet_line~0.00|"
    + docNum + "~term2MonthlyNet_line~0.00|"
    + docNum + "~term3MonthlyNet_line~0.00|"
    + docNum + "~term1MRRRetainedPrice_line~0.00|" 
    + docNum + "~term2MRRRetainedPrice_line~0.00|" 
    + docNum + "~term3MRRRetainedPrice_line~0.00|"
    + docNum + "~term1InstallationList_line~0.00|" 
    + docNum + "~term2InstallationList_line~0.00|" 
    + docNum + "~term3InstallationList_line~0.00|"
    + docNum + "~term1InstallationNet_line~0.00|" 
    + docNum + "~term2InstallationNet_line~0.00|" 
    + docNum + "~term3InstallationNet_line~0.00|"
    + docNum + "~deltaSubtotal_line~0.00|" 
    + docNum + "~term2DeltaSubtotal_line~0.00|" 
    + docNum + "~term3DeltaSubtotal_line~0.00|"
    + docNum + "~term2MonthlyListSubtotal_line~0.00|" 
    + docNum + "~term3MonthlyListSubtotal_line~0.00|"
    + docNum + "~term2MonthlyNetSubtotal_line~0.00|" 
    + docNum + "~term3MonthlyNetSubtotal_line~0.00|"
    + docNum + "~installationListPriceSubtotal_line~0.00|" 
    + docNum + "~term2InstallListSubtotal_line~0.00|" 
    + docNum + "~term3InstallListSubtotal_line~0.00|"
    + docNum + "~installationNetPriceSubtotal_line~0.00|" 
    + docNum + "~term2InstallNetSubtotal_line~0.00|" 
    + docNum + "~term3InstallNetSubtotal_line~0.00|"
    + docNum + "~term1MRRNetPriceFromService_line~0.00|" 
    + docNum + "~term2MRRNetPriceFromService_line~0.00|" 
    + docNum + "~term3MRRNetPriceFromService_line~0.00|"
    + docNum + "~term1ExtQuoteValue_line~0.00|" 
    + docNum + "~term2ExtQuoteValue_line~0.00|" 
    + docNum + "~term3ExtQuoteValue_line~0.00|"
    + docNum + "~term1ExtNewList_line~0.00|" 
    + docNum + "~term2ExtNewList_line~0.00|" 
    + docNum + "~term3ExtNewList_line~0.00|"
    + docNum + "~term1InstallationNet_line~0.00|" 
    + docNum + "~term2InstallationNet_line~0.00|" 
    + docNum + "~term3InstallationNet_line~0.00|"
    + docNum + "~displayMRRDiscountType_line~%|" 
    + docNum + "~displayContractMonthlyDisc_line~0.00|"
    + docNum + "~displayNRCDiscountType_line~%|" 
    + docNum + "~displayContractInstallationDisc_line~0.00|"
    + docNum + "~contractTerm1MonthlyDisc~0.00|" 
    + docNum + "~contractTerm2MonthlyDisc~0.00|"
    + docNum + "~contractTerm3MonthlyDisc~0.00|" 
    + docNum + "~term1MRRDiscountType_line~%|"
    + docNum + "~term2MRRDiscountType_line~%|" 
    + docNum + "~term3MRRDiscountType_line~%|"
    + docNum + "~contractTerm1InstallationDisc~0.00|" 
    + docNum + "~contractTerm3InstallationDisc~0.00|"
    + docNum + "~contractTerm2InstallationDisc~0.00|" 
    + docNum + "~term1NRCDiscountType_line~%|"
    + docNum + "~term2NRCDiscountType_line~%|" 
    + docNum + "~term3NRCDiscountType_line~%|"
    + docNum + "~totalsString_line~|"
    + docNum + "~pricingString_line~|"
    + docNum + "~retainedValue_line~0.00|"
    + docNum + "~displayMRRRetainedPrice_line~0.00|"
    + docNum + "~displayNewNet_line~0.00|"
    //VER 66895: remove deprecated attributes 
    //+ docNum + "~oldNetPrice_line~0.00|"   
    + docNum + "~displayOldNet_line~0.00|" 
    //+ docNum + "~quoteValue_line~0.00|"
    + docNum + "~displayQuoteValue_line~0.00|"
    + docNum + "~carrierOptions_line~|"
    + docNum + "~missingPricingTable_line~|"
    + docNum + "~proposalUsageString_line~|"
    + docNum + "~printSubtotal_line~|" 
    + docNum + "~listPriceSubtotal_line~0.00|"
    + docNum + "~netPriceSubtotal_line~0.00|"
    + docNum + "~priceStatus_line~|"
    + docNum + "~printTotals_line~|" 
    + docNum + "~dAReviewCode_line~|"
    + docNum + "~optionsString_line~|" 
    + docNum + "~tierString_line~|"
    + docNum + "~vendorString_line~|"
    + docNum + "~termNRCNet_list~0.00|"
    + docNum + "~deltaSubtotal_line~0.00|"
    + docNum + "~displayMonthlyNet_line~0.00|"
    + docNum + "~displayContractType_line~NYP|"
    + docNum + "~displayMonthlyList_line~0.00|"
    + docNum + "~termMRRList_line~0.00|" 
    + docNum + "~termMRRNet_line~0.00|"
    + docNum + "~displayInstallationNet_line~0.00|"
    + docNum + "~displayInstallationList_line~0.00|"
    + docNum + "~termNRCList_line~0.00|" 
    + docNum + "~installationListPriceSubtotal_line~0.00|"
    + docNum + "~installationNetPriceSubtotal_line~0.00|";
}
if (resetTotals) {
    ret = ret + "1~termMRCDiscPerc_quote~0|"
          + "1~termNRCDiscPerc_quote~0|"
          + "1~termMRCStandardNet_quote~0.00|"
          + "1~termNRCStandardNetStandard_quote~0.00|"
          + "1~oldTermMRCStandardNet_quote~0.00|"
          + "1~oldTermNRCStandardNet_quote~0.00|"
          // The below 2 attribtues are removed
          //+ "1~quoteTotalMRC_quote~0.00|"
          //+ "1~quoteTotalNRC_quote~0.00|"
          + "1~crmTotalContractValue_quote~0.00|"
          + "1~term1NonStandardPartMRCList_quote~0.00|"
          + "1~term1NonStandardPartNRCList_quote~0.00|"
          + "1~term2NonStandardPartMRCList_quote~0.00|"
          + "1~term2NonStandardPartNRCList_quote~0.00|"
          + "1~term3NonStandardPartMRCList_quote~0.00|"
          + "1~term3NonStandardPartNRCList_quote~0.00|"
          + "1~term1TotalMonthlyList_quote~0.00|"
          + "1~term1TotalInstallList_quote~0.00|"
          + "1~term1TotalMonthlyNet_quote~0.00|"
          + "1~term1TotalInstallNet_quote~0.00|"
          + "1~term2TotalMonthlyList_quote~0.00|"
          + "1~term2TotalInstallList_quote~0.00|"
          + "1~term2TotalMonthlyNet_quote~0.00|"
          + "1~term2TotalInstallNet_quote~0.00|"
          + "1~term3TotalMonthlyList_quote~0.00|"
          + "1~term3TotalInstallList_quote~0.00|"
          + "1~term3TotalMonthlyNet_quote~0.00|"
          + "1~term3TotalInstallNet_quote~0.00|"
          + "1~term1TotalMonthlyNetDelta_quote~0.00|"
          + "1~term2TotalMonthlyNetDelta_quote~0.00|"
          + "1~term3TotalMonthlyNetDelta_quote~0.00|"
          + "1~term1TotalMonthlyListDelta_quote~0.00|"
          + "1~term2TotalMonthlyListDelta_quote~0.00|"
          + "1~term3TotalMonthlyListDelta_quote~0.00|"
          + "1~term1TotalExistingMonthlyNet_quote~0.00|"
          + "1~term2TotalExistingMonthlyNet_quote~0.00|"
          + "1~term3TotalExistingMonthlyNet_quote~0.00|"
          + "1~totalMRCListLineGrid_quote~0.00|"
          + "1~totalNRCListLineGrid_quote~0.00|"
          + "1~totalMRCNetLineGrid_quote~0.00|"
          + "1~totalNRCNetLineGrid_quote~0.00|"
          + "1~priceSource_quote~NYP|";
    for each in totalGroupsArr {
        if (each == 0) {
            ret = ret + "1~ungroupedMRCSubtotal_quote~0.00|"
                    + "1~ungroupedNRCSubtotal_quote~0.00|";
        } else {
            ret = ret + "1~mRCSubtotalGroup" + string(each) + "_quote~0.00|"
                  + "1~nRCSubtotalGroup" + string(each) + "_quote~0.00|";
        }
    }
}

return ret;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_resetPricing_353423719]]></java_class_name><child_class_names></child_class_names><date_modified>1376745602000</date_modified><guid><![CDATA[testsavvis_261046348]]></guid><_children></_children></bm_function><bm_lib_func_param><id>353423721</id><bm_lib_func_id>353423720</bm_lib_func_id><param_name><![CDATA[docNumArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1376745602000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_261046351]]></guid></bm_lib_func_param><bm_lib_func_param><id>353423722</id><bm_lib_func_id>353423720</bm_lib_func_id><param_name><![CDATA[resetTotals]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>0</datatype><date_modified>1376745602000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_261944911]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>206743627</id><name><en><![CDATA[Get Quantities For SO Array]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getQuantitiesForSOArray]]></variable_name><description><en><![CDATA[Return quantity to be used for installBase qty and additional qty for special offers]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>3</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>206743626</function_id><main_script_text><![CDATA[inputArray = string[]{"No", "No", "Yes", "Yes", "Yes"};

return util.getQuantitiesForSOArray("Yes", inputArray);]]></main_script_text><date_modified>1358564317000</date_modified><guid><![CDATA[testsavvis_174288715]]></guid><_children><bm_function><id>206743626</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Get Quantities For SO Array (getQuantitiesForSOArray)                                    
//** Type:        Utility Library Function                                                                  
//**                                                                                                        
//** Description: Return quantity to be used for installBase qty and additional qty for special offers      
//**                                                                                                        
//** Parameters:  value - any keyword that needs to be counted in the array                                 
//**              inpuArray - array in which the value needs to be counted                                  
//**                                                                                                        
//** Return Type: integer                                                                                   
//**                                                                                                        
//** History:     Date     Author       Comment                                                             
//**              10/17/12 SKharche     Implementation to support Special Offers                            
//**              10/17/12 SKharche     VER 64982: Special Offer Bug - Array Quantity Attributes Not        
//**                                               Functioning Properly  
//**              11/08/12 SKharche     VER 65215: Special Offer Additional Quantities Not Set Correctly                                   
//************************************************************************************************************

/*
    The functions is used for 2 uses cases.
    1. SO array has at least 1 NON deletable instance
        Eg: isDeletable = [No, Yes, Yes] then the quantity is returned as 1 for installBase (count of No)
            and 2 for additionalQuantity (count of Yes)
    2. SO array has 0 NON deletable instance
        Eg: isDeletable = [Yes, Yes, Yes] then the quantity is returned as 1 for installBase and 2 for additionalQuantity
	    This hack is done since all the config rules are based of installBaseQuantity and if this is 0 
	    then the rules do not work as expected
*/

count = 0;
countOfNo = 0;

//Count the number of entries inside the array that equals value
for currentValue in inputArray {
	if(currentValue == value) {
		count = count + 1;
	}
	
	// VER 65215: Special Offer Additional Quantities Not Set Correctly
	// There was a bug in the below line where instead of currentValue the actual parameter 'value' was used
	if(currentValue == "No") {
		countOfNo = countOfNo + 1;
	}
}

// VER 64982: Special Offer Bug - Array Quantity Attributes Not Functioning Properly
// The use case is - the array addon do not have a NON deletable instance
// Eg: array addon has 2 entries both as deletable 
// Since all our rules are based on intallBaseQuantity and if this is 0 then the rules won't work correctly
// Hence in this case we want installBaseQuantity set to 1 and additionalArrayQuantity set to 1

// If the value is 'No' and it's count is 0 then return 1
if(count == 0 AND value == "No") {
	return 1;
}
// If the value is 'Yes' and it's count of 'No' is 0 then the count for 'Yes' should be 1 less than the actual count
elif(count > 0 AND value == "Yes" AND countOfNo == 0) {
	return count-1;
}

return count;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getQuantitiesForSOArray_206743626]]></java_class_name><child_class_names></child_class_names><date_modified>1358564317000</date_modified><guid><![CDATA[testsavvis_174288714]]></guid><_children></_children></bm_function><bm_lib_func_param><id>206743628</id><bm_lib_func_id>206743627</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564317000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_174288717]]></guid></bm_lib_func_param><bm_lib_func_param><id>206743629</id><bm_lib_func_id>206743627</bm_lib_func_id><param_name><![CDATA[inputArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564317000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_174288718]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>263833324</id><name><en><![CDATA[Parse Address Tech Description]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[parseAddressTechDescription]]></variable_name><description><en><![CDATA[VER 65645: used for vendor table in commerce, returns dictionary with keywords about description parameter]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>15</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>263833323</function_id><main_script_text></main_script_text><date_modified>1358564316000</date_modified><guid><![CDATA[testsavvis_201765944]]></guid><_children><bm_function><id>263833323</id><ref_type>16</ref_type><script_text><![CDATA[//***************************************************************************************************
//** Util:   Parse Address Tech Description - 
//**                                                                                                 
//** Description: Parses the address tech description that is passed in and returns a hash map of
//**              keywords and values
//**
//** Input:       techDesc - the network z address tech description of a line item
//**                example:id=764$^$siteId=66900.0$^$name=Capital Group Companies, Inc.$^$
//**                logicalName=00062A$^$addr1=3500 Wiseman Blvd$^$city=San Antonio$^$stateCode=
//**                TX$^$zip=78251$^$countryName=USA$^$npa=210$^$nxx=474$^$latitude=29.0$^$
//**                longitude=-99.0
//**
//** Output:      dictionary containing the following keywords:
//**                Lat/Long
//**                NPA/NXX
//**                                                                                                 
//** History:     Date     Author     Comment                                                        
//**              12/26/12 STillett   VER 65645 - Initial Implementation                                         
//***************************************************************************************************

retValDict = dict("string");
latLong = string[2];
npaNXX = string[2];

techOptions = split(techDesc, "$^$");

for option in techOptions {
    optionArray = split(option, "=");
    if(optionArray[0] == "latitude") {
        latLong[0] = optionArray[1];
    } elif (optionArray[0] == "longitude") {
        latLong[1] = optionArray[1];
    } elif (optionArray[0] == "npa") {
        npaNXX[0] = optionArray[1];
    } elif (optionArray[0] == "nxx") {
        npaNXX[1] = optionArray[1];
    }
}
if(NOT isnull(latLong[0]) OR NOT isnull(latLong[1])) {
    put(retValDict, "Lat/Long", join(latLong, "/"));
}
if(NOT isnull(npaNXX[0]) OR NOT isnull(npaNXX[1])) {
    put(retValDict, "NPA/NXX", join(npaNXX, ""));
}

return retValDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_parseAddressTechDescription_263833323]]></java_class_name><child_class_names></child_class_names><date_modified>1358564316000</date_modified><guid><![CDATA[testsavvis_201765943]]></guid><_children></_children></bm_function><bm_lib_func_param><id>263833325</id><bm_lib_func_id>263833324</bm_lib_func_id><param_name><![CDATA[techDesc]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564316000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_201765946]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>206743620</id><name><en><![CDATA[Get Values For Other Attribute For Array]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getValuesForOtherAttributeForArray]]></variable_name><description><en><![CDATA[For a edit+single select use case for array attribute - get the values for other attribute]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>206743619</function_id><main_script_text></main_script_text><date_modified>1358564312000</date_modified><guid><![CDATA[testsavvis_169127965]]></guid><_children><bm_function><id>206743619</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************************** 
//** Function:    Get Values For Other Attribute For Array (getValuesForOtherAttributeForArray)                           
//** Type:        Utility Library Function                                                                                
//**                                                                                                                      
//** Description: For a edit+single select use case - get the values for other attribute                                  
//**                                                                                                                      
//** Parameters:  primaryAttributeArray - primary array attribute                                                         
//**              otherAttributeArray   - other array attribute                                                             
//**                                                                                                                      
//** Return Type: string[] - returns a array for other attribtue                                                          
//**                                                                                                                      
//** History:     Date     Author       Comment                                                                           
//**              10/01/12 SKharche     VER 64794 - New implementation to support edit+single select scenario             
//**              10/30/12 SKharche     VER 65162 - Updated to get the range based on primaryAttribute
//**************************************************************************************************************************


//If priamry attribute is not equal to the option 'Other' then blank out other attribute
//Else return the other attribute

retArr = string[];

//VER 65162 - Updated to get the range based on primaryAttribute
indexes = range(sizeofarray(primaryAttributeArray));

for index in indexes {
    if( primaryAttributeArray[index] <> "Other" ) {
        append(retArr, "");
    }
    else {
        append(retArr, otherAttributeArray[index]);
    }
}

return retArr;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getValuesForOtherAttributeForArray_206743619]]></java_class_name><child_class_names></child_class_names><date_modified>1358564312000</date_modified><guid><![CDATA[testsavvis_169127964]]></guid><_children></_children></bm_function><bm_lib_func_param><id>206743621</id><bm_lib_func_id>206743620</bm_lib_func_id><param_name><![CDATA[primaryAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564312000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_169127967]]></guid></bm_lib_func_param><bm_lib_func_param><id>206743622</id><bm_lib_func_id>206743620</bm_lib_func_id><param_name><![CDATA[otherAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564312000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_169127968]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4872912</id><name><en><![CDATA[Get Tag Inner XML]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getTagInnerXML]]></variable_name><description><en><![CDATA[Returns all text inside a specified tag for a given block of XML code]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>4872911</function_id><main_script_text></main_script_text><date_modified>1358564311000</date_modified><guid><![CDATA[LEGACY_4872912]]></guid><_children><bm_function><id>4872911</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Tag Inner XML (getTagInnerXML)                                                          **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Returns all text inside a specified tag for a given block of XML code                       **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**              08/30/12 STillett     VER 64445 - added functionality for tags with extra "stuff" in them   **
//**************************************************************************************************************

ret = "";
blankTag = "<" + searchTag + "/>";
startTag = "<" + searchTag + ">";
startTagWithExtra = "<" + searchTag + " ";
endTag   = "</" + searchTag + ">";
startLen = len(startTag);
endLen   = len(endTag);

if(find(XMLText, blankTag) <> -1){
	ret = "";
}
elif((find(XMLText, startTag) <> -1) AND (find(XMLText, endTag) <> -1)){
	ret = substring(XMLText, find(XMLText, startTag) + startLen, find(XMLText, endTag));
}
//VER 64445: added check for tags with extra information in them
elif((find(XMLText, startTagWithExtra) <> -1) AND (find(XMLText, endTag) <> -1)){
    temp = substring(XMLText, find(XMLText, startTagWithExtra) +  startLen, find(XMLText, endTag)); 
    pos = find(temp,">");
    ret = substring(temp, pos + 1, len(temp));
}
else{
	ret = "NULL";
}

return ret;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getTagInnerXML_4872911]]></java_class_name><child_class_names></child_class_names><date_modified>1358564311000</date_modified><guid><![CDATA[LEGACY_4872911]]></guid><_children></_children></bm_function><bm_lib_func_param><id>4872914</id><bm_lib_func_id>4872912</bm_lib_func_id><param_name><![CDATA[XMLText]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564311000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_4872914]]></guid></bm_lib_func_param><bm_lib_func_param><id>4872915</id><bm_lib_func_id>4872912</bm_lib_func_id><param_name><![CDATA[searchTag]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564311000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_4872915]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>77249778</id><name><en><![CDATA[Generate New Pricing String Arrays]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[generateNewPricingStringsArrays]]></variable_name><description><en><![CDATA[Returns the updated array from the pricing strings based on whether or not PXP has been accounted for.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>77249777</function_id><main_script_text></main_script_text><date_modified>1376745601000</date_modified><guid><![CDATA[testsavvis_77249778]]></guid><_children><bm_function><id>77249777</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Generate New Pricing String Arrays (generateNewPricingStringsArrays)                        
//** Type:        Utility Library Function                                                                    
//**                                                                                                          
//** Description: Returns the updated pricing string array from the pricing strings based on                                 
//**              whether or not PXP has been accounted for.
//** Inputs:      oldString - the previous pricing string
//**              newString - the new pricing string that we compare the old one to
//**
//**              the inputs will be in the form: 7^NGB_Subscription^12!%!option!%!name$ATTR$NGB Subscription
//**              $ROW$estCapEx$ATTR$10.0$ROW$estOpExAnnual$ATTR$270.0$ROW$estOpExMonthly$ATTR$22.5$
//**              ROW$MRCList$ATTR$402.5$ROW$MRCNet$ATTR$402.5$ROW$NRCList$ATTR$0.0$ROW$NRCNet$ATTR$0.0$ROW$
//**              retained$ATTR$false$ROW$status$ATTR$Valid$ROW$optionTierStructure$ATTR$Tiered$ROW$
//**              errorMessage$ATTR$(!$!7^NGB_Subscription^24!%!...)
//**                                                                                                          
//** History:     Date     Author       Comment                                                               
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                
//**              02/21/13 STillett     VER 66136: Keep old discounts if "Get Pricing" action called
//**              07/25/13 STillett     BIGMACH-2408: Keep track of discount types for usage
//************************************************************************************************************

retArray    = string[];
oldTermsArray    = string[];
newTermsArray    = string[];
termVsPricingDict = dict("string");
termVsStatusDict  = dict("string");
termVsDiscountDict = dict("string");
termVsDiscountTypeDict = dict("string");
termVsNetDict = dict("string");

oldStringUpdate = oldString;
newStringUpdate = newString;

//remove trailing delimiter so we don't try to access an empty array index
if(endswith(oldString, "!$!") ){
    oldStringUpdate = substring(oldString, 0, -3);
}
if(endswith(newString, "!$!") ){
    newStringUpdate = substring(newString, 0, -3);
}
//split the strings into arrays with indices containing info for each term
oldTermsArray = split(oldStringUpdate, "!$!");
newTermsArray = split(newStringUpdate, "!$!");

//for each term...
for entry in oldTermsArray {
    //find the actual pricing options
    keys = split(entry, "!%!");
    put(termVsPricingDict, keys[0], entry);
    if(find(entry, "tierStatus$ATTR$PXP") <> -1){
        put(termVsStatusDict, keys[0], "PXP");
    }
    elif(find(entry, "status$ATTR$PXP") <> -1){
        put(termVsStatusDict, keys[0], "PXP");
    }
    else {
        put(termVsStatusDict, keys[0], "Standard");
    }
    //if this is a usage string, keep track of disc and net values
    if(sizeofarray(keys) > 1 AND keys[1] == "usage") {
        optionsArr = split(keys[2], "$ROW$");
        for option in optionsArr {
            if(startswith(option, "tierPriceDiscount")) {
                values = split(option, "$ATTR$");
                put(termVsDiscountDict, keys[0], values[1]);
            }
            //BIGMACH-2408 : keep track of disc type too!
            if(startswith(option, "tierPriceDiscType")) {
                values = split(option, "$ATTR$");
                put(termVsDiscountTypeDict, keys[0], values[1]);
            }
            if(startswith(option, "tierPriceNet")) {
                values = split(option, "$ATTR$");
                put(termVsNetDict, keys[0], values[1]);
            }
        }
    }
}
// VER 66136: replace new discounts with old ones if they exist, and pxp overrides
// new (generic) pricing
//for each term...
for each in newTermsArray {
    keys = split(each, "!%!");
    oldStatus = "";
    oldPricing = "";
    oldTierDiscount = "";
    oldTierNet = "";
    replaceValuesFlag = false;
    if(containskey(termVsStatusDict, keys[0])){
        oldStatus = get(termVsStatusDict, keys[0]);
    }
    if(containskey(termVsPricingDict, keys[0])){
        oldPricing = get(termVsPricingDict, keys[0]);
    }
    if((oldStatus == "PXP") AND (oldPricing <> "")){
        append(retArray, oldPricing);
    }
    //if this is a usage string, insert old PXP pricing into new string
    elif (sizeofarray(keys) > 1 AND keys[1] == "usage") {
        if(containskey(termVsDiscountDict, keys[0])) {
            replaceValuesFlag = true;
            oldTierDiscount = get(termVsDiscountDict, keys[0]);
        }
        if(containskey(termVsNetDict, keys[0])) {
            replaceValuesFlag = true;
            oldTierNet = get(termVsNetDict, keys[0]);
        }
        if(replaceValuesFlag){
            optionsArr = split(keys[2], "$ROW$");
            for option in optionsArr {
                if(startswith(option, "tierPriceDiscount")) {
                    each = replace(each, option, "tierPriceDiscount$ATTR$" + oldTierDiscount);

                    //BIGMACH-2408: if disc type exists in string, add it as well.
                    if(containskey(termVsDiscountTypeDict, keys[0])) {
                        oldTierDiscType = get(termVsDiscountTypeDict, keys[0]);
                        each = each +  "$ROW$tierPriceDiscType$ATTR$" + oldTierDiscType;
                    }   
                }
                if(startswith(option, "tierPriceNet")) {
                    each = replace(each, option, "tierPriceNet$ATTR$" + oldTierNet);
                }
            }
        }
        append(retArray, each);
    }
    else {
        append(retArray, each);
    }
}

return retArray;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_generateNewPricingStringsArrays_77249777]]></java_class_name><child_class_names></child_class_names><date_modified>1376745601000</date_modified><guid><![CDATA[testsavvis_77249777]]></guid><_children></_children></bm_function><bm_lib_func_param><id>77249780</id><bm_lib_func_id>77249778</bm_lib_func_id><param_name><![CDATA[oldString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1376745601000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_77249780]]></guid></bm_lib_func_param><bm_lib_func_param><id>77249781</id><bm_lib_func_id>77249778</bm_lib_func_id><param_name><![CDATA[newString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1376745601000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_77249781]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4895849</id><name><en><![CDATA[Get Global Addon Constraints]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getGlobalAddonConstraints]]></variable_name><description><en><![CDATA[Used to query the SvcPkgValidAddons table, to filter which add-on products are available for any given model. Input: servicepackage. Return: constraint string.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>4895848</function_id><main_script_text></main_script_text><date_modified>1358564319000</date_modified><guid><![CDATA[LEGACY_4895849]]></guid><_children><bm_function><id>4895848</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Global Addon Constraints (getGlobalAddonConstraints)                                    **
//** Type:        Commerce Library Function                                                                   **
//**                                                                                                          **
//** Description: Used to query the SvcPkgValidAddons table, to filter which add-on products are available    **
//**              for any given model. Input: servicepackage. Return: constraint string.                      **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

results = string[];
append(results, "");
addOnNames = string[];
strSvcPkg = string[];
BAN = "";
BPId = "";
svcPkgSalRestrict = dict("string");
svcPkgAddAllow = dict("string");

// Lets grab all the valid addons for this model
qryRes = bmql("SELECT AddOnName FROM SvcPkgValidAddons WHERE Keyword = $modelName OR SvcPkgName = $modelName");
for res in qryRes {
	append(addOnNames, get(res,"AddOnName"));
}

// lets grab the BAN and BPId for the quote we're on. we use it later for salability checks
idResults = bmql("SELECT bANNumber_quote, bPID_quote FROM commerce.quote_process");
for idRes in idResults {
	BAN = get(idRes, "bANNumber_quote");
	BPId = get(idRes, "bPID_quote");
}

//PRE-12.0 FIX.
append(addOnNames, "");

querySvcPkgMaster = bmql("SELECT SvcPkgName, AddAllowed, SalabilityRestricted FROM SvcPkgMaster WHERE SvcPkgName IN $addOnNames");
for res in querySvcPkgMaster {
	if( get(res,"SvcPkgName") <> "" AND get(res,"AddAllowed") <> "" ) {
		if( NOT containskey(svcPkgAddAllow, get(res,"SvcPkgName")) ) {
			put(svcPkgAddAllow, get(res,"SvcPkgName"), get(res,"AddAllowed"));
		}
	}
	
	if( get(res,"SvcPkgName") <> "" AND get(res,"SalabilityRestricted") <> "" ) {
		if( NOT containskey(svcPkgSalRestrict, get(res,"SvcPkgName")) ) {
			put(svcPkgSalRestrict, get(res,"SvcPkgName"), get(res,"SalabilityRestricted"));
		}
	}
}

// VER: 63175 CMM 5/23/12
// For Addons, the Salable tables have the modelName as NULL
// lets build a list of all adds that this BAN and BP are allowed to have
querySvcPkgSalableByBAN = bmql("SELECT SvcPkgName FROM SvcPkgSalableByBAN WHERE BAN = $BAN and ModelVariableName IS NULL");
for row in querySvcPkgSalableByBAN {
	append(strSvcPkg, get(row, "SvcPkgName"));
}

querySvcPkgSalableByBP = bmql("SELECT SvcPkgName FROM SvcPkgSalableByBP WHERE BPId = $BPId and ModelVariableName IS NULL");
for row in querySvcPkgSalableByBP {
	append(strSvcPkg, get(row, "SvcPkgName"));
}

				
for addOnName in addOnNames 
{
	if(addOnName <> "") {
		addAllowed = get(svcPkgAddAllow, addOnName);
		salabilityRestriced = get(svcPkgSalRestrict, addOnName);
		
		if( addAllowed == "1" AND salabilityRestriced == "0" AND findinarray(results, addOnName) == -1  ) {
			// its ok for everyone to buy this
			append(results, addOnName);
		}
		elif( addAllowed == "1" AND salabilityRestriced == "1" AND findinarray(results, addOnName) == -1  ) {
			// if found in the strSvcPkg, then its ok for the customer to buy this
			if( findinarray(strSvcPkg, addOnName) <> -1 ) { 
				append(results, addOnName); 
			}
		}
	}
}	
	
return "" + "|^|" + join(results, "|^|");]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getGlobalAddonConstraints_4895848]]></java_class_name><child_class_names></child_class_names><date_modified>1358564320000</date_modified><guid><![CDATA[LEGACY_4895848]]></guid><_children></_children></bm_function><bm_lib_func_param><id>4895851</id><bm_lib_func_id>4895849</bm_lib_func_id><param_name><![CDATA[modelName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564319000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_4895851]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>722881902</id><name><en><![CDATA[CTL Get OMR Retrieval]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[ctlGetOMRRetrieval]]></variable_name><description><en><![CDATA[CTL specific OMR retrieval, returns calculated line and quote level information returned from the POM services OMR response.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>32</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>722881901</function_id><main_script_text></main_script_text><date_modified>1386348992000</date_modified><guid><![CDATA[sbcenturylink_722881902]]></guid><_children><bm_function><id>722881901</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    CTL Get OMR Retireval(ctlGetOMRRetrieval)
//** Type:        Utility Library Function   
//**
//** Description: CTL specific OMR retrieval, returns calculated line and quote level information 
//**              returned from the POM services OMR response.
//** 
//** Param:       keyVsQuoteValueDict      - contains quote level information
//**              docNumArray              - list of document numbers that forms part of the key to docNumKeyVsLineValueDict
//**              docNumKeyVsLineValueDict - contains line level information such as part number, model name etc
//**                                       - it has a complex key with format docNum:KEY (the valid values for KEY are mentioned below)
//**
//** Return type: dictionary of string dictionaries      - contains 2 dictionaries: line info, quote info.
//**
//** History:     Date     Author    Story         Comment    
//**              11/22/13 SPingle  US 2081  - Initial Implementation
//************************************************************************************************************

retDict = dict("dict<string>"); // key: {GENERAL_INFO, LINE_INFO}, 
                                // value: corresponding dictionaries created above that 

ret                   = "";
omrId                 = "";
quoteNumber           = "";
inputXML              = "";
outputXML             = "";
allConfigs            = "";
retrieveDetailURL     = "";
retrieveDetailCreds   = "";
serviceCallError      = "";
requestStatus         = "";
errorMsg              = "";
debugInformation      = "";
approvedPriceComments = "";
contractType          = "";
priceStatus           = "";
msTimeOnFuncEntry     = getcurrenttimeinmillis();            // Get this first so we have an accurate reading of the entry time
msTimeOnFuncExit      = -1;                                  // To indicate that time has not yet been recorded
msTimeOnSvcCallout    = -1;
msTimeOnSvcReturn     = -1;
msFuncDuration        = 0;
msSvcCallDuration     = 0;

inputHeaders               = dict("string");
docNumVsGeneralInfoDict    = dict("string");    // key: documentNumber, value: general information like error message, fault string etc
docNumVsPriceResponseDict = dict("string");    // key: documentNumber, value: pricing string present in <price> tag in the response xml

configArray = string[];

listOfTags      = string[] {"Status", "Exception", "Message", "PomRetrieveOmrDetailResponse", "OmrQuoteItemResponse"};   // list of outer tags in the response xml, stored in array so that we can loop
listOfInnerTags = string[] {"LineId", "ApprovalFlag", "ItemSpecialPriceList"}; // list of inner tags in the response xml, store in array so that we can loop

omrId       = get(keyVsQuoteValueDict, "ctlOmrId_quote");
quoteNumber = get(keyVsQuoteValueDict, "quoteNumber_quote");

inputXml    = 
    "<?xml version=\"1.0\" encoding=\"utf-8\" ?>" +
    "<PomRetrieveOmrDetailRequest xmlns=\"http://www.centurylink.com/XMLSchema/POM\">" +
    "  <OmrId>" + omrId + "</OmrId>" +
    "  <QuoteId>" + quoteNumber + "</QuoteId>" +
    "</PomRetrieveOmrDetailRequest>";

//Setup global vars for service endpoints.
retrieveDetailURL = "";
retrieveDetailCreds = "";
globalVarsResult = bmql("SELECT Keyword, Value FROM ctlGlobalVars");
for val in globalVarsResult {
    if(get(val, "Keyword") == "OMR_RETRIEVAL_URL"){
        retrieveDetailURL = get(val, "Value");
    }
    if(get(val, "Keyword") == "OMR_CREDENTIAL_B64"){
        retrieveDetailCreds = get(val, "Value");
    }
}

// Build the headers
put(inputHeaders, "Authorization", "Basic " + retrieveDetailCreds);
put(inputHeaders, "Content-Type", "text/xml");
print inputXML;

// Record the time immediately before calling the service.  Add no code between this and the urldatabypost call
msTimeOnSvcCallout   = getcurrenttimeinmillis();
outputXML = trim(urldatabypost(retrieveDetailURL, inputXML, "NULL", inputHeaders));
// Record the time immediately after calling the service.  Add no code between this and the urldatabypost call
msTimeOnSvcReturn    = getcurrenttimeinmillis();
print outputXML;

if(startswith(outputXML, "NULL")){
   serviceCallError  = "Failed to receive Retrieve OMR Detail Service response.";
   put(keyVsQuoteValueDict, "preValidationError_quote", serviceCallError);
}
else{
    getErrorMsg = false;
    errorMsg = "";
    for searchTag in listOfTags {
        dataInTag         = "";    
        blankTag          = "<" + searchTag + "/>";
        startTag          = "<" + searchTag + ">";
        startTagWithExtra = "<" + searchTag + " ";
        endTag            = "</" + searchTag + ">";
        
        startLen = len(startTag);
        endLen   = len(endTag);

        if(find(outputXML, blankTag) <> -1){
            dataInTag = "";
        }
        elif((find(outputXML, startTag) <> -1) AND (find(outputXML, endTag) <> -1)){
            dataInTag = substring(outputXML, find(outputXML, startTag) + startLen, find(outputXML, endTag));
        }
        elif((find(outputXML, startTagWithExtra) <> -1) AND (find(outputXML, endTag) <> -1)){
            temp = substring(outputXML, find(outputXML, startTagWithExtra) +  startLen, find(outputXML, endTag)); 
            pos = find(temp,">");
            dataInTag = substring(temp, pos + 1, len(temp));
        }
        else{
            dataInTag = "NULL";
        }
        
        if(searchTag == "Status") {
            if(upper(dataInTag) == "FAILURE"){
                getErrorMsg = true;
            }
        }
        elif(getErrorMsg AND (searchTag == "Message" OR searchTag == "Exception")){
            errorMsg = dataInTag;
        }
        elif(searchTag == "PomRetrieveOmrDetailResponse") {
            allConfigs = dataInTag;
        }
        elif((searchTag <> "OmrQuoteItemResponse") AND upper(dataInTag) <> "NULL"){
             put(docNumVsGeneralInfoDict, "INTEGRATION_ERROR", "Unknown process integration error.");
        }
    }
    // Can't handle tildes or vetrical bars in the error message as these are BMI separators
    if(errorMsg <> ""){
        errorMsg = replace(errorMsg, "~", " - ");
        errorMsg = replace(errorMsg, "|", " : ");
        put(keyVsQuoteValueDict, "preValidationError_quote", errorMsg);
    }
    
    //get a range of possible OmrQuoteItemResponse's returned by Service using the sizeofarray docNumArray.
    noOfLines = sizeofarray(docNumArray);
    if(noOfLines > 0){
      //Repalce an initial comment with iSubproductID before the OmrQuoteItemResponse's start.
      allConfigs = replace(allConfigs, substring(allConfigs, find(allConfigs, "<!--iSubproductID") , find(allConfigs, "-->") + len("-->")), "");  
      for item in docNumArray{
          commentedStr = "";
          //Replace the comment in between "</OmrQuoteItemResponse>" and "<OmrQuoteItemResponse>"
          commentedStr = substring(allConfigs, find(allConfigs, "</OmrQuoteItemResponse><!--") + len("</OmrQuoteItemResponse>"), find(allConfigs, "--><OmrQuoteItemResponse>") + len("-->"));
          if(commentedStr <> ""){    
              allConfigs = replace(allConfigs, commentedStr, "");
          }
          else{
              break;    
          }
      }    
    }
    
    allConfigs  = replace(allConfigs, "</OmrQuoteItemResponse><OmrQuoteItemResponse>","</OmrQuoteItemResponse>!@!<OmrQuoteItemResponse>");
    configArray = split(allConfigs, "!@!");
    for config in configArray {
        configDocNum          = "";
        approvalFlag          = "";
        approvedPriceComments = "";
        pricingSubStr         = "";
        contractType          = "";
        priceStatus           = "";
        mrcDiscountType       = "%"; 
        nrcDiscountType       = "%";
        priceMRC              = 0.0;
        priceNRC              = 0.0;
        priceMRCNet           = 0.0;
        priceNRCNet           = 0.0;
        contractMonthlyDisc   = 0.0;   
        contractInstallDisc   = 0.0;   
        for searchTag in listOfInnerTags {  //Get the line document number for each OmrQuoteItemResponse.
            outputXML         = config;
            dataInTag         = "";    
            blankTag          = "<" + searchTag + "/>";
            startTag          = "<" + searchTag + ">";
            startTagWithExtra = "<" + searchTag + " ";
            endTag            = "</" + searchTag + ">";
            
            startLen = len(startTag);
            endLen   = len(endTag);

            if(find(outputXML, blankTag) <> -1){
                dataInTag = "";
            }
            elif((find(outputXML, startTag) <> -1) AND (find(outputXML, endTag) <> -1)){
                dataInTag = substring(outputXML, find(outputXML, startTag) + startLen, find(outputXML, endTag));
            }
            elif((find(outputXML, startTagWithExtra) <> -1) AND (find(outputXML, endTag) <> -1)){
                temp = substring(outputXML, find(outputXML, startTagWithExtra) +  startLen, find(outputXML, endTag)); 
                pos = find(temp,">");
                dataInTag = substring(temp, pos + 1, len(temp));
            }
            else{
                dataInTag = "NULL";
            }
            
            if(searchTag == "LineId") {
                configDocNum = dataInTag;
            }
            elif((searchTag == "ApprovalFlag") AND (dataInTag <> "") AND (upper(dataInTag) <> "NULL")) {
                approvalFlag = dataInTag; 
            }
            elif((searchTag == "ItemSpecialPriceList") AND (dataInTag <> "") AND (upper(dataInTag) <> "NULL")) {
                mrcPriceStartTag      = "<MRCPrice>";
                mrcPriceEndTag        = "</MRCPrice>";
                nrcPriceStartTag      = "<NRCPrice>";
                nrcPriceEndTag        = "</NRCPrice>";
                approvedPriceComments = "";
                
                mrcPriceInTag = substring(dataInTag, find(dataInTag, mrcPriceStartTag) + len(mrcPriceStartTag), find(dataInTag, mrcPriceEndTag));
                nrcPriceInTag = substring(dataInTag, find(dataInTag, nrcPriceStartTag) + len(nrcPriceStartTag), find(dataInTag, nrcPriceEndTag));
                
                if(mrcPriceInTag <> "" AND upper(mrcPriceInTag) <> "NULL") {
                    mrcListStartTag     = "<ItemListPrice>";
                    mrcListEndTag       = "</ItemListPrice>";
                    mrcFinalStartTag    = "<ItemFinalPrice>";
                    mrcFinalEndTag      = "</ItemFinalPrice>";
                    mrcListInTag = substring(mrcPriceInTag, find(mrcPriceInTag, mrcListStartTag) + len(mrcListStartTag), find(mrcPriceInTag, mrcListEndTag));
                    mrcFinalInTag = substring(mrcPriceInTag, find(mrcPriceInTag, mrcFinalStartTag) + len(mrcFinalStartTag), find(mrcPriceInTag, mrcFinalEndTag));
                    put(docNumVsPriceResponseDict, configDocNum + ":MRCLIST", mrcListInTag);
                    put(docNumVsPriceResponseDict, configDocNum + ":MRCFINAL", mrcFinalInTag);
                }
                if(nrcPriceInTag <> "" AND upper(nrcPriceInTag) <> "NULL") {
                    nrcListStartTag     = "<ItemListPrice>";
                    nrcListEndTag       = "</ItemListPrice>";
                    nrcFinalStartTag    = "<ItemFinalPrice>";
                    nrcFinalEndTag      = "</ItemFinalPrice>";
                    nrcListInTag = substring(nrcPriceInTag, find(nrcPriceInTag, nrcListStartTag) + len(nrcListStartTag), find(nrcPriceInTag, nrcListEndTag));
                    nrcFinalInTag = substring(nrcPriceInTag, find(nrcPriceInTag, nrcFinalStartTag) + len(nrcFinalStartTag), find(nrcPriceInTag, nrcFinalEndTag));
                    put(docNumVsPriceResponseDict, configDocNum + ":NRCLIST", nrcListInTag);
                    put(docNumVsPriceResponseDict, configDocNum + ":NRCFINAL", nrcFinalInTag);
                }
                //approvedPriceComments = util.getTagInnerXML(dataInTag, "ApprovedPriceComments");
            }
        }
        //print "Util Data for Line#:" + configDocNum;
        if(approvalFlag == "ApprovedWithChanges" AND containskey(docNumKeyVsLineValueDict, configDocNum + ":priceMRC") AND NOT isnull(get(docNumKeyVsLineValueDict, configDocNum + ":priceMRC"))
            AND containskey(docNumKeyVsLineValueDict, configDocNum + ":priceMRCNet") AND NOT isnull(get(docNumKeyVsLineValueDict, configDocNum + ":priceMRCNet"))){
            priceMRC        = atof(get(docNumKeyVsLineValueDict, configDocNum + ":priceMRC"));
            mrcDiscountType = get(docNumKeyVsLineValueDict, configDocNum + ":mrrDiscountType");
            if(get(docNumVsPriceResponseDict, configDocNum + ":MRCFINAL") <> "" AND isnumber(get(docNumVsPriceResponseDict, configDocNum + ":MRCFINAL"))){
                returnedNetMRC  = atof(get(docNumVsPriceResponseDict, configDocNum + ":MRCFINAL"));
            }
            else{
                returnedNetMRC  = atof(get(docNumKeyVsLineValueDict, configDocNum + ":priceMRCNet"));
            }
            
            if(priceMRC <> 0.0){
                if(mrcDiscountType == "%"){
                    contractMonthlyDisc = ((priceMRC - returnedNetMRC) * 100)/ priceMRC;
                }
                else{
                    contractMonthlyDisc = priceMRC - returnedNetMRC;
                }
            }
            else{
                contractMonthlyDisc = 0.0;
            }
    
            //print "Put in the Util Line Dict for :" + configDocNum + " MRC Prices: " + string(returnedNetMRC);
            put(docNumKeyVsLineValueDict, configDocNum + ":priceMRCNet", string(returnedNetMRC));
            put(docNumKeyVsLineValueDict, configDocNum + ":contractMonthlyDisc", string(contractMonthlyDisc));
            put(docNumKeyVsLineValueDict, configDocNum + ":contractTerm1MonthlyDisc", string(contractMonthlyDisc));
        }
        
        if(approvalFlag == "ApprovedWithChanges" AND containskey(docNumKeyVsLineValueDict, configDocNum + ":priceNRC") AND NOT isnull(get(docNumKeyVsLineValueDict, configDocNum + ":priceNRC"))
            AND containskey(docNumKeyVsLineValueDict, configDocNum + ":priceNRCNet") AND NOT isnull(get(docNumKeyVsLineValueDict, configDocNum + ":priceNRCNet"))){
            priceNRC        = atof(get(docNumKeyVsLineValueDict, configDocNum + ":priceNRC"));
            nrcDiscountType = get(docNumKeyVsLineValueDict, configDocNum + ":nrcDiscountType");
            if(get(docNumVsPriceResponseDict, configDocNum + ":NRCFINAL") <> "" AND isnumber(get(docNumVsPriceResponseDict, configDocNum + ":NRCFINAL"))){
                returnedNetNRC  = atof(get(docNumVsPriceResponseDict, configDocNum + ":NRCFINAL"));
            }else{
                returnedNetNRC  = atof(get(docNumKeyVsLineValueDict, configDocNum + ":priceNRCNet"));
            }
            if(priceNRC <> 0.0){
                if(nrcDiscountType == "%"){
                    contractInstallDisc = ((priceNRC - returnedNetNRC) * 100)/ priceNRC;
                }
                else{
                    contractInstallDisc = priceNRC - returnedNetNRC;
                }
            }
            else{
                contractInstallDisc = 0.0;
            }
            
            //print "Put in the Util Line Dict for :" + configDocNum + " NRCPrices: " + string(returnedNetNRC);
            put(docNumKeyVsLineValueDict, configDocNum + ":priceNRCNet", string(returnedNetNRC));
            put(docNumKeyVsLineValueDict, configDocNum + ":contractInstallDisc", string(contractInstallDisc));
            put(docNumKeyVsLineValueDict, configDocNum + ":contractTerm1InstallDisc", string(contractInstallDisc));
        }
        //Return correct values back for ICB or ERR items on ApprovedWithChanges
        contractType = get(docNumKeyVsLineValueDict, configDocNum + ":contractType");
        priceStatus = get(docNumKeyVsLineValueDict, configDocNum + ":priceStatus");
        if(approvalFlag == "ApprovedWithChanges" AND priceStatus == "POM" AND (contractType == "ICB" OR contractType == "ERR")){
            //Generate the MRCList and MRCNet substring that will be replaced in global LIU for ICB or ERR lines
            //Example of a ICB or ERR substring: MRCList$ATTR$0.0$ROW$MRCNet$ATTR$0.0$ROW$NRCList$ATTR$0.0$ROW$NRCNet$ATTR$0.0
            pricingSubStr = "MRCList$ATTR$" + string(returnedNetMRC) + "$ROW$MRCNet$ATTR$" + string(returnedNetMRC) + "$ROW$NRCList$ATTR$" + string(returnedNetNRC) + "$ROW$NRCNet$ATTR$" + string(returnedNetNRC);
            put(docNumKeyVsLineValueDict, configDocNum + ":priceMRC", string(returnedNetMRC));
            put(docNumKeyVsLineValueDict, configDocNum + ":priceMRCNet", string(returnedNetMRC));
            put(docNumKeyVsLineValueDict, configDocNum + ":contractMonthlyDisc", string(0.0));
            put(docNumKeyVsLineValueDict, configDocNum + ":contractTerm1MonthlyDisc", string(0.0));
            put(docNumKeyVsLineValueDict, configDocNum + ":priceNRC", string(returnedNetNRC));
            put(docNumKeyVsLineValueDict, configDocNum + ":priceNRCNet", string(returnedNetNRC));
            put(docNumKeyVsLineValueDict, configDocNum + ":contractInstallDisc", string(0.0));
            put(docNumKeyVsLineValueDict, configDocNum + ":contractTerm1InstallDisc", string(0.0));
            put(docNumKeyVsLineValueDict, configDocNum + ":pricingSubStr", pricingSubStr);
            put(docNumKeyVsLineValueDict, configDocNum + ":priceStatus", "");
            
        }
    }
}

put(retDict, "LINE_INFO"   , docNumKeyVsLineValueDict);
put(retDict, "QUOTE_INFO"  , keyVsQuoteValueDict);
return retDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_ctlGetOMRRetrieval_722881901]]></java_class_name><child_class_names></child_class_names><date_modified>1386348992000</date_modified><guid><![CDATA[sbcenturylink_722881901]]></guid><_children></_children></bm_function><bm_lib_func_param><id>722881904</id><bm_lib_func_id>722881902</bm_lib_func_id><param_name><![CDATA[keyVsQuoteValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1386348992000</date_modified><order_no>1</order_no><guid><![CDATA[sbcenturylink_722881904]]></guid></bm_lib_func_param><bm_lib_func_param><id>722881905</id><bm_lib_func_id>722881902</bm_lib_func_id><param_name><![CDATA[docNumArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1386348992000</date_modified><order_no>2</order_no><guid><![CDATA[sbcenturylink_722881905]]></guid></bm_lib_func_param><bm_lib_func_param><id>722881906</id><bm_lib_func_id>722881902</bm_lib_func_id><param_name><![CDATA[docNumKeyVsLineValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1386348992000</date_modified><order_no>3</order_no><guid><![CDATA[sbcenturylink_722881906]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>37729795</id><name><en><![CDATA[Get Legacy Constraints Valid Options]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getLegacyConstraintsValidOptions]]></variable_name><description><en><![CDATA[The legacy combinations that were sold in the past needs to be valid options going forward as well so we will exclude those values for the corresponding AIPs]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>37729794</function_id><main_script_text></main_script_text><date_modified>1358564308000</date_modified><guid><![CDATA[LEGACY_37729795]]></guid><_children><bm_function><id>37729794</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Legacy Constraints Valid Options (getLegacyConstraintsValidOptions)                     **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: The legacy combinations that were sold in the past needs to be valid options going forward  **
//**              as well so we will exclude those values for the corresponding AIPs
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

AIPInt = integer[];

//Convert the AIP array into integer array as the data table has AIPIds as integers
indexes = range(ArrayQuantity);
for index in indexes {
	if(NOT isnull(AIP[index]) AND AIP[index] <> "" and isnumber(AIP[index])) {
		append(AIPInt, atoi(AIP[index]));
	}
}

//Get the legacy valid option for the corresponding AIPs
aipOptionDict = dict("string");
rows = bmql("SELECT AcctProdId, OptionValue FROM AcctProdOption WHERE AcctProdId IN $AIPInt AND AttrName=$attrName");
for row in rows {
	id = get(row, "AcctProdId");
	val = get(row, "OptionValue");
	put(aipOptionDict, id, val);
}

//If the optionVals are constrained exclude those if present in the data table for that specific AIP
for index in indexes {
	if(containskey(aipOptionDict, AIP[index])) {
		val = get(aipOptionDict, AIP[index]);
		if(val <> "") {
			optionVals[index] = replace(optionVals[index], "|^|" + get(aipOptionDict, AIP[index]), "");
		}
	}
}

return optionVals;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getLegacyConstraintsValidOptions_37729794]]></java_class_name><child_class_names></child_class_names><date_modified>1358564309000</date_modified><guid><![CDATA[LEGACY_37729794]]></guid><_children></_children></bm_function><bm_lib_func_param><id>37729797</id><bm_lib_func_id>37729795</bm_lib_func_id><param_name><![CDATA[ArrayQuantity]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1358564308000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_37729797]]></guid></bm_lib_func_param><bm_lib_func_param><id>37729798</id><bm_lib_func_id>37729795</bm_lib_func_id><param_name><![CDATA[AIP]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564308000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_37729798]]></guid></bm_lib_func_param><bm_lib_func_param><id>37729799</id><bm_lib_func_id>37729795</bm_lib_func_id><param_name><![CDATA[attrName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564308000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_37729799]]></guid></bm_lib_func_param><bm_lib_func_param><id>37729800</id><bm_lib_func_id>37729795</bm_lib_func_id><param_name><![CDATA[optionVals]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564308000</date_modified><order_no>4</order_no><guid><![CDATA[LEGACY_37729800]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>6941063</id><name><en><![CDATA[Get AIP Addon Constraints]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getAIPAddonConstraints]]></variable_name><description><en><![CDATA[Get the constraints for add-on action when AIP is present]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>6941062</function_id><main_script_text></main_script_text><date_modified>1358564319000</date_modified><guid><![CDATA[LEGACY_6941063]]></guid><_children><bm_function><id>6941062</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get AIP Addon Constraints (getAIPAddonConstraints)                                          **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Constrains the action add if AIP is present for that add-on                                 **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

ret = string[];
	
indexes = range(arrayControlAttribute);
for index in indexes  {
	if(AIP[index] <> "") {
		append(ret, "Add");
	}
	else {
		append(ret, "Delete|^|Change");
	}	
}
	
return ret;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getAIPAddonConstraints_6941062]]></java_class_name><child_class_names></child_class_names><date_modified>1358564319000</date_modified><guid><![CDATA[LEGACY_6941062]]></guid><_children></_children></bm_function><bm_lib_func_param><id>6941065</id><bm_lib_func_id>6941063</bm_lib_func_id><param_name><![CDATA[arrayControlAttribute]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1358564319000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_6941065]]></guid></bm_lib_func_param><bm_lib_func_param><id>6941066</id><bm_lib_func_id>6941063</bm_lib_func_id><param_name><![CDATA[AIP]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564319000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_6941066]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>9673614</id><name><en><![CDATA[Get Legacy Constraints]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getLegacyConstraints]]></variable_name><description><en><![CDATA[Returns a list of valid legacy values]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>9673612</function_id><main_script_text></main_script_text><date_modified>1358564313000</date_modified><guid><![CDATA[LEGACY_9673614]]></guid><_children><bm_function><id>9673612</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Legacy Constraints (getLegacyConstraints)                                               **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Returns a list of valid legacy values                                                       **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

result = string[];

//Gets the display values from the data table based on the attribute and all the values that ends with *
retTbl = bmql("SELECT DISTINCT Value FROM AttributeValues WHERE AttributeVarName=$attribute AND DisplayValue LIKE '%*'");	
for row in retTbl {
	append(result, get(row, "Value")+"*");
}

if(modelAIP <> "") {
	pos = findinarray(result, value+"*");
	if(pos <> -1) {
		remove(result, pos);
	}
	
	if(valueOther <> "") {
		//Gets the display values from the data table based on the attribute and either the value selected or the 
		//value present in the other field
		dispValOther = valueOther + "*";		
		retTbl = bmql("SELECT DisplayValue FROM AttributeValues WHERE AttributeVarName=$attribute AND DisplayValue=$dispValOther");
		
		if(NOT isnull(retTbl)) {
			pos = findinarray(result, valueOther+"*");
			if(pos <> -1) {
				remove(result, pos);
			}
		}	
	}
}
	
retString = join(result, "|^|");
if( NOT isnull(retString) AND retString <> "" ) { retString = replace(retString, "*", ""); }
return retString;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getLegacyConstraints_9673612]]></java_class_name><child_class_names></child_class_names><date_modified>1358564313000</date_modified><guid><![CDATA[LEGACY_9673612]]></guid><_children></_children></bm_function><bm_lib_func_param><id>9673616</id><bm_lib_func_id>9673614</bm_lib_func_id><param_name><![CDATA[modelAIP]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_9673616]]></guid></bm_lib_func_param><bm_lib_func_param><id>9673617</id><bm_lib_func_id>9673614</bm_lib_func_id><param_name><![CDATA[attribute]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_9673617]]></guid></bm_lib_func_param><bm_lib_func_param><id>9673618</id><bm_lib_func_id>9673614</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_9673618]]></guid></bm_lib_func_param><bm_lib_func_param><id>10072313</id><bm_lib_func_id>9673614</bm_lib_func_id><param_name><![CDATA[valueOther]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>4</order_no><guid><![CDATA[LEGACY_10072313]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>206743646</id><name><en><![CDATA[Check If Other Attribute Not Matches Primary Attribute For Array]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[checkIfOtherAttributeNotMatchesPrimaryAttributeForArray]]></variable_name><description><en><![CDATA[For a edit+single select use case for array attribute - check if other attribute matches primary attribute]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>206743645</function_id><main_script_text></main_script_text><date_modified>1376745603000</date_modified><guid><![CDATA[testsavvis_169127950]]></guid><_children><bm_function><id>206743645</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************************** 
//** Function:    Check If Other Attribute Not Matches Primary Attribute For Array                                        
//**              (checkIfOtherAttributeNotMatchesPrimaryAttributeForArray)                                               
//** Type:        Utility Library Function                                                                    	          
//**                                                                                                          	          
//** Description: For a edit+single select use case - check if other attribute matches primary atribute                   
//**                                                                                                                      
//** Parameters:  primaryAttributeArray - primary array attribute                                                         
//**              otherAttributeArray   - other array attribute                                                             
//**                                                                                                                      
//** Return Type: boolean - return true if found a match else return false                                                
//**                                                                                                                      
//** History:     Date     Author       Comment                                                                           
//**              10/01/12 SKharche     VER 64794 - New implementation to support edit+single select scenario 
//**              10/30/12 SKharche     VER 65162 - Updated to get the range based on primaryAttribute    
//**              08/02/13 SKharche     BIGMACH-2433 - Getting null pointer error when trying to add additional custom hardware    
//**************************************************************************************************************************


//Get valid values for other attribute
//If other attribute do not match primary attribute return true else return false

//VER 65162 - Updated to get the range based on primaryAttribute
indexes = range(sizeofarray(primaryAttributeArray));

// BIGMACH-2433 - Getting null pointer error when trying to add additional custom hardware
// To fix this we will make sure we check array instances if both primary and other array have same size
sizeOfPrimaryArray = sizeofarray(primaryAttributeArray);
sizeOfOtherArray   = sizeofarray(otherAttributeArray);

if(sizeOfPrimaryArray == sizeOfOtherArray) {
    for index in indexes {
        if(UPPER(primaryAttributeArray[index]) <> UPPER(otherAttributeArray[index])) {
            return true;
        }
    }
}

return false;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_checkIfOtherAttributeNotMatchesPrimaryAttributeForArray_206743645]]></java_class_name><child_class_names></child_class_names><date_modified>1376745603000</date_modified><guid><![CDATA[testsavvis_169127949]]></guid><_children></_children></bm_function><bm_lib_func_param><id>206743647</id><bm_lib_func_id>206743646</bm_lib_func_id><param_name><![CDATA[primaryAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1376745603000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_169127952]]></guid></bm_lib_func_param><bm_lib_func_param><id>206743648</id><bm_lib_func_id>206743646</bm_lib_func_id><param_name><![CDATA[otherAttributeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1376745603000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_169127953]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>25006632</id><name><en><![CDATA[Is Canada Data Center]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[isCanadaDataCenter]]></variable_name><description><en><![CDATA[Checks if the selected data center is a canada data center]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>25006631</function_id><main_script_text></main_script_text><date_modified>1358564309000</date_modified><guid><![CDATA[LEGACY_25006632]]></guid><_children><bm_function><id>25006631</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Is Canada Data Center (isCanadaDataCenter)                                                  **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Checks if the selected data center is a canada data center                                  **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

svcPkgName = "";

//Checks the data table to see if the combination of the canada SvcPkgName and dataCenter is present. 
//If present then it is canada data center
retTbl = bmql("SELECT DISTINCT SvcPkgName FROM SvcPkgLocAvailable WHERE SvcPkgName=$canadaProduct AND DataCenter=$dataCenter");
if(NOT isnull(retTbl)) {
	for row in retTbl {
		svcPkgName = get(row, "SvcPkgName");
	}
}

if(trim(svcPkgName) == "" ) { return false; }
return true;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_isCanadaDataCenter_25006631]]></java_class_name><child_class_names></child_class_names><date_modified>1358564309000</date_modified><guid><![CDATA[LEGACY_25006631]]></guid><_children></_children></bm_function><bm_lib_func_param><id>25006634</id><bm_lib_func_id>25006632</bm_lib_func_id><param_name><![CDATA[canadaProduct]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564309000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_25006634]]></guid></bm_lib_func_param><bm_lib_func_param><id>25006635</id><bm_lib_func_id>25006632</bm_lib_func_id><param_name><![CDATA[dataCenter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564309000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_25006635]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>10076474</id><name><en><![CDATA[Get Legacy Values]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getLegacyValues]]></variable_name><description><en><![CDATA[Returns the valid value for the drop down with legacy values]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>10076472</function_id><main_script_text></main_script_text><date_modified>1358564314000</date_modified><guid><![CDATA[LEGACY_10076474]]></guid><_children><bm_function><id>10076472</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Legacy Values (getLegacyValues)                                                         **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Returns the valid value for the drop down with legacy values                                **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

result = "";
isEmpty = true;

//Legacy values are identified as * in their display value
//Checks the data table to get the display values for the combination of attribute and either display value or 
//value of the other attribute
legacyValue = valueOther + "*";
retTbl = bmql("SELECT DisplayValue FROM AttributeValues WHERE AttributeVarName=$attribute AND (DisplayValue=$valueOther OR DisplayValue=$legacyValue)");
for row in retTbl {
	result = get(row, "DisplayValue");
	isEmpty = false;
}

if(isEmpty AND valueOther <> "") { return "Other"; }
elif(valueOther <> "") { return valueOther; }

return value;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getLegacyValues_10076472]]></java_class_name><child_class_names></child_class_names><date_modified>1358564314000</date_modified><guid><![CDATA[LEGACY_10076472]]></guid><_children></_children></bm_function><bm_lib_func_param><id>10076476</id><bm_lib_func_id>10076474</bm_lib_func_id><param_name><![CDATA[attribute]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564314000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_10076476]]></guid></bm_lib_func_param><bm_lib_func_param><id>10076477</id><bm_lib_func_id>10076474</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564314000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_10076477]]></guid></bm_lib_func_param><bm_lib_func_param><id>10076478</id><bm_lib_func_id>10076474</bm_lib_func_id><param_name><![CDATA[valueOther]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564314000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_10076478]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>206743640</id><name><en><![CDATA[Compare Step]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[compareStep]]></variable_name><description><en><![CDATA[VER 64894: Compares current step with target step to see if current step comes before or after target step.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>3</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>206743639</function_id><main_script_text></main_script_text><date_modified>1358564316000</date_modified><guid><![CDATA[testsavvis_170419007]]></guid><_children><bm_function><id>206743639</id><ref_type>16</ref_type><script_text><![CDATA[//****************************************************************************************
//**	Util Function: Compare Step (compareStep)										**
//**																					**
//**	Parameters 	1)	currentStep - step that your quote is currently at				**
//**				2)	targetStep - step you want to compare your current step to		**
//**	Returns		-1 if current step is before target step							**
//**				0 if current step == target step									**
//**				1 if current step is after target step								**						
//**																					**
//**	History:																		**
//**		10/05/12  STillett	VER 64894: Creation										**
//****************************************************************************************

stepArray = string[]{"start_step", "design", "underDesignReview", "priced", 
"underDiscountReview", "discountApproved", "pendingApprovals", "finalizedQuote", 
"inCustomerReview", "submitOrderRedlineInitialStepFinalCustomerReview", "orderSubmitted", 
"bookedWon", "canceled", "expired"};

currentIndex = findinarray(stepArray, currentStep);
targetIndex = findinarray(stepArray, targetStep);
if (currentIndex == -1) {
	print "ERROR: CurrentStep, '" + currentStep + "' has not been added to the util Compare Step.  Please check the Compare Step util to update.";
	print "The valid input values are " + join(stepArray, ", ");
	return -666;
}
if(targetIndex == -1) {
	print "ERROR: TargetStep, '" + targetStep + "' is not part of the util Compare Step.";
	print "The valid input values are " + join(stepArray, ", ");
	return -666;
}

if (currentIndex < targetIndex) {
	return -1;
} elif (currentIndex == targetIndex) {
	return 0;
} else {
	return 1;
}]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_compareStep_206743639]]></java_class_name><child_class_names></child_class_names><date_modified>1358564316000</date_modified><guid><![CDATA[testsavvis_170419006]]></guid><_children></_children></bm_function><bm_lib_func_param><id>206743641</id><bm_lib_func_id>206743640</bm_lib_func_id><param_name><![CDATA[currentStep]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564316000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_170419009]]></guid></bm_lib_func_param><bm_lib_func_param><id>206743642</id><bm_lib_func_id>206743640</bm_lib_func_id><param_name><![CDATA[targetStep]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564316000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_170419010]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>191391270</id><name><en><![CDATA[Get isDeletable Values]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getIsDeletableValues]]></variable_name><description><en><![CDATA[Gets the isDeletable attribute values to be allowed. All the 'Yes' values before the last 'No' are constrained.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>10</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>191391269</function_id><main_script_text></main_script_text><date_modified>1358564314000</date_modified><guid><![CDATA[testsavvis_161106201]]></guid><_children><bm_function><id>191391269</id><ref_type>16</ref_type><script_text><![CDATA[//*****************************************************************************************************************
//** Function:    Get isDeletable Values (getIsDeletableValues)                           			 **
//** Type:        Utility Library Function                                                                       **
//**                                                                                                             **
//** Description: Gets the isDeletable attribute values to be allowed                                            **
//**              All the 'Yes' values before the last 'No' are constrained                                      **
//**                                                                                                             **
//** Parameters:  isDeletableArray - this is isDeletable attribute of the array for which the rule is called for **
//**                                                                                                             **
//** Return type: string[] - all 'Yes' found before the last 'No' are replaced by 'No' and added to return array **
//**                                                                                                             **
//** History:     Date     Author       Comment                                                                  **
//**              08/22/12 SKharche     Implementation to support Special Offers                                 **
//*****************************************************************************************************************

//Copy the original array into the return array and overwrite the instances to be constrained
retArray = isDeletableArray;

lastIndexOfNo = 0;
indexes = range(sizeofarray(isDeletableArray));

//Get the last index of NO in the array
for index in indexes {
	if(isDeletableArray[index] == "No") {
		lastIndexOfNo = index;
	}	
}

//Overwirte the values (any 'Yes') till the last index in the array
for index in indexes {
	if(index <= lastIndexOfNo ) {
		retArray[index] = "No";
	}
}

return retArray;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getIsDeletableValues_191391269]]></java_class_name><child_class_names></child_class_names><date_modified>1358564314000</date_modified><guid><![CDATA[testsavvis_161106200]]></guid><_children></_children></bm_function><bm_lib_func_param><id>191391271</id><bm_lib_func_id>191391270</bm_lib_func_id><param_name><![CDATA[isDeletableArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564314000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_161106203]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>13606466</id><name><en><![CDATA[DEPRECATED - please use version 2]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getRecommendedItemsReturnString]]></variable_name><description><en><![CDATA[DEPRECATED: Please Use Recommended Items Return String2 , cannot remove due to ghost code.
  Returns the recommended item return string]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>13606465</function_id><main_script_text><![CDATA[attributes = string[];
attrValues = string[];

append(attributes, "NGB Active Clients");
append(attributes, "PRETTY_DESC");
append(attrValues, "Actove Client List");
append(attrValues, "MY PD");

isAddOnSelected = 1;

return util.getRecommendedItemsReturnString("Active Backup Clients 1.0", attributes, attrValues, "abcAIP", isAddonSelected, false, true, "", "");]]></main_script_text><date_modified>1371905638000</date_modified><guid><![CDATA[LEGACY_13606466]]></guid><_children><bm_function><id>13606465</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Recommended Items Return String (getRecommendedItemsReturnString)                       **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Returns the recommended item return string                                                  **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**              07/25/12 KNewyear     VER 63966 - Change the "=" delimiter to "^=^"                         **
//**              09/25/12 STillett     VER 64737: rework logic to allow pretty desc to be passed into script **
//**************************************************************************************************************

techDescr = "";
prettyDescr = "";
encStr = "";
recItems = "";
action = "";
attrvalues = values;
prettyDescGiven = false;

//encStr is a delimited string to push into the tech description
indexes = range(sizeofarray(attributes));
for index in indexes {
	//VER 64737: skip putting pretty description in the tech description
	if(attributes[index] <> "PRETTY_DESC") {
		// VER 63966 - Change the first delimiter to "^=^"
		encStr = encStr + attributes[index] + "^=^" + attrvalues[index] + "^-^";
	} else {
		//VER 64737: get pretty Desc from  values array
		prettyDescGiven = true;
		prettyDescr = attrvalues[index];
	}
}

techDescr = substring(encStr,0,-3);

//Pretty description is concatenation of all the selected values
if(sizeofarray(values) > 0 AND prettyDescGiven == false) {
	prettyDescr = join(values, " "); 
}

//Below logic is to get the action performed on the add-on 
if(NOT isArrayAddon) {
	action = "Add";
	if( AIP <> "" AND isAddOnSelected <> -1 ) {
		action = "Change";
	}
	elif( AIP <> "" AND isAddOnSelected == -1 ) {
		action = "Delete";
	}
}	
else {
	action = arrayAction;
	if(isAIPPresent) {
		action = "Delete";
	}
}

dcOrCountry = dataCenterOrCountry;
if(trim(dataCenterOrCountry)=="") { dcOrCountry = "Global"; }

recItems = part + "~1~" + techDescr + "!@!" + prettyDescr + "!@!" + AIP + "!@!" + action + "!@!" + dcOrCountry + "~|^|";	

return recItems;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getRecommendedItemsReturnString_13606465]]></java_class_name><child_class_names></child_class_names><date_modified>1371905639000</date_modified><guid><![CDATA[LEGACY_13606465]]></guid><_children></_children></bm_function><bm_lib_func_param><id>13606468</id><bm_lib_func_id>13606466</bm_lib_func_id><param_name><![CDATA[part]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905638000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_13606468]]></guid></bm_lib_func_param><bm_lib_func_param><id>13606469</id><bm_lib_func_id>13606466</bm_lib_func_id><param_name><![CDATA[attributes]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1371905638000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_13606469]]></guid></bm_lib_func_param><bm_lib_func_param><id>13606470</id><bm_lib_func_id>13606466</bm_lib_func_id><param_name><![CDATA[values]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1371905638000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_13606470]]></guid></bm_lib_func_param><bm_lib_func_param><id>13606471</id><bm_lib_func_id>13606466</bm_lib_func_id><param_name><![CDATA[AIP]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905638000</date_modified><order_no>4</order_no><guid><![CDATA[LEGACY_13606471]]></guid></bm_lib_func_param><bm_lib_func_param><id>13606472</id><bm_lib_func_id>13606466</bm_lib_func_id><param_name><![CDATA[isAddonSelected]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1371905639000</date_modified><order_no>5</order_no><guid><![CDATA[LEGACY_13606472]]></guid></bm_lib_func_param><bm_lib_func_param><id>13606473</id><bm_lib_func_id>13606466</bm_lib_func_id><param_name><![CDATA[isArrayAddon]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>0</datatype><date_modified>1371905639000</date_modified><order_no>6</order_no><guid><![CDATA[LEGACY_13606473]]></guid></bm_lib_func_param><bm_lib_func_param><id>13606474</id><bm_lib_func_id>13606466</bm_lib_func_id><param_name><![CDATA[isAIPPresent]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>0</datatype><date_modified>1371905639000</date_modified><order_no>7</order_no><guid><![CDATA[LEGACY_13606474]]></guid></bm_lib_func_param><bm_lib_func_param><id>13606475</id><bm_lib_func_id>13606466</bm_lib_func_id><param_name><![CDATA[arrayAction]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905639000</date_modified><order_no>8</order_no><guid><![CDATA[LEGACY_13606475]]></guid></bm_lib_func_param><bm_lib_func_param><id>13606476</id><bm_lib_func_id>13606466</bm_lib_func_id><param_name><![CDATA[dataCenterOrCountry]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905639000</date_modified><order_no>9</order_no><guid><![CDATA[LEGACY_13606476]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>191391275</id><name><en><![CDATA[Check If isDeletable Needs to be Constrained]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[checkIfIsDeletableNeedsToBeConstrained]]></variable_name><description><en><![CDATA[To make Special Offers Array IsDeleteable easier, we force the user to keep all the isDeletable=False items FIRST in the list. We dont allow a user to create a Special offer with the first item deletable, but the second item Not Deletable (aka customer MUST buy the second item). This routine helps find this situation]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>191391274</function_id><main_script_text></main_script_text><date_modified>1358564315000</date_modified><guid><![CDATA[testsavvis_156430118]]></guid><_children><bm_function><id>191391274</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************************************************
//** Function:    Check If isDeletable Needs to be Constrained (checkIfIsDeletableNeedsToBeConstrained)                                         **
//** Type:        Utility Library Function                                                                                                      **
//**                                                                                                                                            **
//** Description: To make Special Offers Array IsDeleteable easier, we force the user to keep all the isDeletable=False items FIRST in the list **
//**              We dont allow a user to create a Special offer with the first item deletable,                                                **  
//**	          but the second item Not Deletable (aka customer MUST buy the second item)                                                     **
//**              This routine helps find this situation                                                                                        **
//**                                                                                                                                            **
//** Parameters:  isDeletableArray - this is the isDeletable attribute of the array for which the rule is called for                            **
//**                                                                                                                                            **
//** Return Type: boolean - return true if a sequence of Yes followed by No is found else return false                                          **
//**                                                                                                                                            **
//** History:     Date     Author       Comment                                                                                                 **
//**              08/22/12 SKharche     Implementation to support Special Offers Is Deletable scenario mentioned above                          **
//**                                    Support VER 62770                                                                                       **
//************************************************************************************************************************************************

//stores the previous isDeletable array instance value to be compared with current value
previousIsDeletable = "";

for isDeletable in isDeletableArray {
	//If the sequence is like 'Yes followed by No' then don't allow it and return true so that the constraint runs
	if(previousIsDeletable == "Yes" AND isDeletable == "No") {
		return true;
	}
	
	//Copy current value to the previous value so that it can be checked in the next iteration
	previousIsDeletable = isDeletable;	
}

return false;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_checkIfIsDeletableNeedsToBeConstrained_191391274]]></java_class_name><child_class_names></child_class_names><date_modified>1358564315000</date_modified><guid><![CDATA[testsavvis_156430117]]></guid><_children></_children></bm_function><bm_lib_func_param><id>191391276</id><bm_lib_func_id>191391275</bm_lib_func_id><param_name><![CDATA[isDeletableArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564315000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_156430121]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5405289</id><name><en><![CDATA[Get Config Model Constraints]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getConfigModelConstraints]]></variable_name><description><en><![CDATA[used to constrain the primary configuration models based on attributes. queries the config.constraints data table.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>5405288</function_id><main_script_text></main_script_text><date_modified>1358564318000</date_modified><guid><![CDATA[LEGACY_5405289]]></guid><_children><bm_function><id>5405288</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Config Model Constraints (getConfigModelConstraints)                                    **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Used to constrain the primary configuration models based on attributes.                     **
//**              queries the config.constraints data table.                                                  **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

ret = string[];
qryRes = recordset();

if( parentVal2 == "" ) {
	qryRes = bmql( "SELECT ConstrainedVal FROM Constraints WHERE ServicePackage = $servicePackage AND ConstrainedAttribute = $constrainedAttr AND ParentVal1 = $parentVal1" );
}
elif( parentVal3 == "" ) {
	qryRes = bmql( "SELECT ConstrainedVal FROM Constraints WHERE ServicePackage = $servicePackage AND ConstrainedAttribute = $constrainedAttr AND ParentVal1 = $parentVal1 AND ParentVal2 = $parentVal2" );
}
else {
	qryRes = bmql( "SELECT ConstrainedVal FROM Constraints WHERE ServicePackage = $servicePackage AND ConstrainedAttribute = $constrainedAttr AND ParentVal1 = $parentVal1 AND ParentVal2 = $parentVal2 AND ParentVal3 = $parentVal3" );
}
	
for res in qryRes {
	append( ret, get( res, "ConstrainedVal" ) );
}

return join( ret, "|^|" );]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getConfigModelConstraints_5405288]]></java_class_name><child_class_names></child_class_names><date_modified>1358564318000</date_modified><guid><![CDATA[LEGACY_5405288]]></guid><_children></_children></bm_function><bm_lib_func_param><id>5405291</id><bm_lib_func_id>5405289</bm_lib_func_id><param_name><![CDATA[servicePackage]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_5405291]]></guid></bm_lib_func_param><bm_lib_func_param><id>5405292</id><bm_lib_func_id>5405289</bm_lib_func_id><param_name><![CDATA[constrainedAttr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_5405292]]></guid></bm_lib_func_param><bm_lib_func_param><id>5405293</id><bm_lib_func_id>5405289</bm_lib_func_id><param_name><![CDATA[parentVal1]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_5405293]]></guid></bm_lib_func_param><bm_lib_func_param><id>5405294</id><bm_lib_func_id>5405289</bm_lib_func_id><param_name><![CDATA[parentVal2]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>4</order_no><guid><![CDATA[LEGACY_5405294]]></guid></bm_lib_func_param><bm_lib_func_param><id>5405295</id><bm_lib_func_id>5405289</bm_lib_func_id><param_name><![CDATA[parentVal3]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>5</order_no><guid><![CDATA[LEGACY_5405295]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>13343954</id><name><en><![CDATA[Get Installation Region - Network]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getInstallationRegionNetwork]]></variable_name><description><en><![CDATA[Returns the installation region based on the country]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>13343953</function_id><main_script_text></main_script_text><date_modified>1358564310000</date_modified><guid><![CDATA[LEGACY_13343954]]></guid><_children><bm_function><id>13343953</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Installation Region - Network (getInstallationRegionNetwork)                            **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Gets the region from the data table based on the country                                    **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

installationRegion = "";
rows = bmql("SELECT Region FROM CountryToRegion WHERE (Country=$value) OR (Region=$value)");
for row in rows {
	installationRegion = get(row, "Region");
	break;
}
return installationRegion;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getInstallationRegionNetwork_13343953]]></java_class_name><child_class_names></child_class_names><date_modified>1358564310000</date_modified><guid><![CDATA[LEGACY_13343953]]></guid><_children></_children></bm_function><bm_lib_func_param><id>13343956</id><bm_lib_func_id>13343954</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564310000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_13343956]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>9203834</id><name><en><![CDATA[Get Global Value]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getGlobalValue]]></variable_name><description><en><![CDATA[Returns the global values of the keyword specified]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>9203833</function_id><main_script_text></main_script_text><date_modified>1358564319000</date_modified><guid><![CDATA[LEGACY_9203834]]></guid><_children><bm_function><id>9203833</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Global Value (getGlobalValue)                                                           **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Gets the value of the global attribute based on the keyword                                 **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

ret = "";
bmqlKey = Keyword;

allAttrs = bmql("SELECT Value FROM GlobalVars WHERE Keyword = $bmqlKey");

for val in allAttrs {
	ret = get(val, "Value");
}

return ret;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getGlobalValue_9203833]]></java_class_name><child_class_names></child_class_names><date_modified>1358564319000</date_modified><guid><![CDATA[LEGACY_9203833]]></guid><_children></_children></bm_function><bm_lib_func_param><id>9203836</id><bm_lib_func_id>9203834</bm_lib_func_id><param_name><![CDATA[Keyword]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564319000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_9203836]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>720108916</id><name><en><![CDATA[CTL Get Loop Data By SWC]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[ctlGetLoopDataBySWC]]></variable_name><description><en><![CDATA[Takes in a string of WireCenter CLLI and related Loop Option and presents the Speed value that is supported at those WireCenters.  
The type allows for returning either AccessSpeed or AccessProtocol Values. Loop Option is not needed for AccessProtocol Values.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>720108915</function_id><main_script_text></main_script_text><date_modified>1385055371000</date_modified><guid><![CDATA[testsavvis_542004797]]></guid><_children><bm_function><id>720108915</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    GetLoopDataBySWC (ctlGetLoopDataBySWC)                                                   
//** Type:        Utility Library Function                                                                    
//**                                                                                                          
//** Description: Returns a dictionary of Protocols or Speeds for WireCenter CLLIs.
//**
//** Parameters:  SWCCLLI - Serving Wire Center CLLI
//**              LoopOption - Loop Protocol  
//**                                                                                                          
//** History:     Date     Author       Comment                                                               
//**              11/18/13 SKharche     BIGMACH-3012 - CTL code reconciliation
//**              11/14/13 SArjuna      US2123 - Initial Creation
//*************************************************************************************************************

//Declare a return Variable.
//It is a String Dictionary. Key is SWC CLLI; Value is a delimited string based on type
//If type is AccessProtocol it will return Protocols
//If type is AccessSpeed it will return Speeds
retStr = "";

//declare an index variable to iterate over the Loop Options Array
index = -1;

//Get the 8 characters of a CLLI
CLLI8 = "";
if (SWCCLLI <> "" ) {
    CLLI8 = substring(SWCCLLI, 0,8);
}

//Process for Access Protocols
if (type == "AccessProtocol" and CLLI8 <> "" ) {
        //Retrieve LOOP_OPTION for the CLLI that is in Active Status
        results = bmql("select LOOP_OPTION from ctlLoopAvailability2 where SWC_CLLI8=$CLLI8 and ACTIVE='Y'");
        protocol = "";
        //Loop thru the result set and build a delimited string
        for result in results {
            protocol = protocol + "~" + get(result, "LOOP_OPTION");
        }
        //Set the Delimited string into the return String.
	retStr = substring(protocol, 1);    
}
//Process for Access Speeds
elif( type== "AccessSpeed" AND CLLI8 <> "" AND LoopOption <> "") {

       //Retrieve SPEED_VALUE for the CLLI and LOOP_OPTION that is in Active Status
       results = bmql("select SPEED_VALUE from ctlLoopAvailability2 where SWC_CLLI8=$CLLI8 and LOOP_OPTION=$LoopOption and ACTIVE='Y'");
       speed = "";
        //Loop thru the result set and build a delimited string       
       for result in results {
           speed = speed + "~" + get(result, "SPEED_VALUE");
       }
       //Set the Delimited string into the return String.
	retStr = substring(speed,1);
} 

//return a String
return retStr;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_ctlGetLoopDataBySWC_720108915]]></java_class_name><child_class_names></child_class_names><date_modified>1385055371000</date_modified><guid><![CDATA[testsavvis_542004796]]></guid><_children></_children></bm_function><bm_lib_func_param><id>720108917</id><bm_lib_func_id>720108916</bm_lib_func_id><param_name><![CDATA[SWCCLLI]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1385055371000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_542004799]]></guid></bm_lib_func_param><bm_lib_func_param><id>720108918</id><bm_lib_func_id>720108916</bm_lib_func_id><param_name><![CDATA[LoopOption]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1385055371000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_542004800]]></guid></bm_lib_func_param><bm_lib_func_param><id>720108919</id><bm_lib_func_id>720108916</bm_lib_func_id><param_name><![CDATA[Type]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1385055371000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_542004801]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>13343942</id><name><en><![CDATA[Get Installation Region - DataCenter]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getInstallationRegionDataCenter]]></variable_name><description><en><![CDATA[Returns the installation region based on the dataCenter]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>13343941</function_id><main_script_text></main_script_text><date_modified>1358564313000</date_modified><guid><![CDATA[LEGACY_13343942]]></guid><_children><bm_function><id>13343941</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Installation Region - DataCenter (getInstallationRegionDataCenter)                      **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Gets the region from the data table based on the data center                                **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

installationRegion = "";
rows = bmql("SELECT RegionName FROM DataCenterMaster WHERE brLogicalName=$value");
for row in rows {
	installationRegion = get(row, "RegionName");
	break;
}
return installationRegion;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getInstallationRegionDataCenter_13343941]]></java_class_name><child_class_names></child_class_names><date_modified>1358564313000</date_modified><guid><![CDATA[LEGACY_13343941]]></guid><_children></_children></bm_function><bm_lib_func_param><id>13343944</id><bm_lib_func_id>13343942</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_13343944]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4902394</id><name><en><![CDATA[Get Encoded String]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getEncodedString]]></variable_name><description><en><![CDATA[returns encoded string of attributes in format of "attribute=value^-^attribute=value"]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>4902393</function_id><main_script_text></main_script_text><date_modified>1358564316000</date_modified><guid><![CDATA[LEGACY_4902394]]></guid><_children><bm_function><id>4902393</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Encoded String (getEncodedString)                                                       **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: returns encoded string of attributes in format of "attribute=value^-^attribute=value"       **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**              07/25/12 KNewyear     VER 63966 - Change the "=" delimiter to "^=^"                         **
//**************************************************************************************************************

encStr = "";

index = range(sizeofarray(attributes));
for i in index {
	// VER 63966 - Change the first delimiter to "^=^"
	//encStr = encStr + attributes[i] + "=" + values[i] + "^-^";
	encStr = encStr + attributes[i] + "^=^" + values[i] + "^-^";
}
	
return substring(encStr,0,-3);]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getEncodedString_4902393]]></java_class_name><child_class_names></child_class_names><date_modified>1358564316000</date_modified><guid><![CDATA[LEGACY_4902393]]></guid><_children></_children></bm_function><bm_lib_func_param><id>4902396</id><bm_lib_func_id>4902394</bm_lib_func_id><param_name><![CDATA[attributes]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564316000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_4902396]]></guid></bm_lib_func_param><bm_lib_func_param><id>4902397</id><bm_lib_func_id>4902394</bm_lib_func_id><param_name><![CDATA[values]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564316000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_4902397]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5856633</id><name><en><![CDATA[DEPRECATED Get Physical Address]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getPhysicalAddress]]></variable_name><description><en><![CDATA[DEPRECATED The function is used to perform a web service call to the savvis system and get the physical addresses associated with the opportunity]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>5856632</function_id><main_script_text></main_script_text><date_modified>1368886220000</date_modified><guid><![CDATA[LEGACY_5856633]]></guid><_children><bm_function><id>5856632</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Physical Address (getPhysicalAddress)                                                   
//** Type:        Utility Library Function                                                                    
//**                                                                                                          
//** Description: The function is used to perform a web service call to the savvis system and                 
//**              get the physical addresses associated with the opportunity                                  
//**                                                                                                          
//** History:     Date     Author       Comment                                                               
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                
//**              05/06/13 STillett     VER 66818 - add identifying tags to WS Call
//**************************************************************************************************************

headerDict = dict("string");
soapURL = "";
getAddressXML = "";

getAddressXML = urldatabypost("https://" + lower(CompanyName) + ".bigmachines.com/bmfsweb/" + lower(CompanyName) + "/image/WebServices/getAddress.xml", "", "SOAP Not Available");
getAddressXML = replace(getAddressXML, "SESSIONID_REPLACE", SessionID);
getAddressXML = replace(getAddressXML, "OPPORTUNITY_ID_REPLACE", OpportunityID);
getAddressXML = replace(getAddressXML, "%USERNAME%", _user_login);
getAddressXML = replace(getAddressXML, "%OPPORTUNITY%", OpportunityID);

//GLOBAL VARIABLE CALL
urlHeader = "";
allAttrs = bmql("SELECT Value FROM GlobalVars WHERE Keyword = 'SVVS_URL_PREFIX'");
for val in allAttrs {
	urlHeader = get(val, "Value");
}

getAddressURL = urlHeader + "BMWebServices/opportunity";

put(headerDict, "Content-Type", "text/xml; charset=utf-8"); //Soap Receiver requires straight text/xml
put(headerDict, "SOAPAction", ""); //Every SOAP call must have a soap Action

//getAddressResponse = urldatabypost(getAddressURL, getAddressXML, "Error", headerDict);
//return getAddressResponse;

return "";]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getPhysicalAddress_5856632]]></java_class_name><child_class_names></child_class_names><date_modified>1368886220000</date_modified><guid><![CDATA[LEGACY_5856632]]></guid><_children></_children></bm_function><bm_lib_func_param><id>5856635</id><bm_lib_func_id>5856633</bm_lib_func_id><param_name><![CDATA[CompanyName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1368886220000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_5856635]]></guid></bm_lib_func_param><bm_lib_func_param><id>5856636</id><bm_lib_func_id>5856633</bm_lib_func_id><param_name><![CDATA[SessionID]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1368886220000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_5856636]]></guid></bm_lib_func_param><bm_lib_func_param><id>5856637</id><bm_lib_func_id>5856633</bm_lib_func_id><param_name><![CDATA[OpportunityID]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1368886220000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_5856637]]></guid></bm_lib_func_param><bm_lib_func_param><id>434651566</id><bm_lib_func_id>5856633</bm_lib_func_id><param_name><![CDATA[_user_login]]></param_name><ref_id>3</ref_id><param_location>1</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1368886220000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_324503116]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>569426711</id><name><en><![CDATA[CTL Line Item Update]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[ctlLineItemUpdate]]></variable_name><description><en><![CDATA[CTL specific line item update, returns calculated line and quote level information. Used by CTL for calculating discounts (EZ pricing), approval routing etc]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>32</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>569426710</function_id><main_script_text></main_script_text><date_modified>1390429011000</date_modified><guid><![CDATA[testsavvis_413874229]]></guid><_children><bm_function><id>569426710</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    CTL Line Item Update(ctlLineItemUpdate)
//** Type:        Utility Library Function   
//**
//** Description: CTL specific line item update, returns calculated line and quote level information. 
//**              Used by CTL for calculating discounts (EZ pricing), approval routing etc
//** 
//** Param:       keyVsQuoteValueDict      - contains quote level information
//**              docNumArray              - list of document numbers that forms part of the key to docNumKeyVsLineValueDict
//**              docNumKeyVsLineValueDict - contains line level information such as part number, model name etc
//**                                       - it has a complex key with format docNum:KEY (the valid values for KEY are mentioned below)
//**
//** Return type: dictionary of string dictionaries - contains various dictionaries such as line info, quote info etc
//**                                                - outer dict key: valid values for keys are mentioned below
//**                                                - inner dict key: documentNumber, parentDocumentNumber or keywords
//**
//** History:     Date     Author    Story         Comment    
//**              07/22/13 SKharche  BIGMACH-2368  - Initial Implementation
//**              08/05/13 SKharche  BIGMACH-2347  - CTL code reconciliation
//**              07/26/13 SPingle   US 1341       - Federal Sales Pros need pricing approval to bypass FD and go directly to POM       
//**              09/17/13 SKharche  BIGMACH-2611  - CTL code reconciliation.(bug fix) Update the 
//**                                                 ctlNewNet value when applying EZ pricing for a line
//**              09/23/13 SKharche  BIGMACH-2710  - CTL code reconciliation
//**              08/06/13 SPingle   US 1691       - For CTL Bundles - Allow Sales Pro to discount bundle port and components
//**              09/15/13 SPingle   US 1350       - NRC Waivers for Standard Pricing
//**              09/17/13 RMendoza  US 1350       - Clear NRC Waiver string when setting to NYP 
//**              11/18/13 SKharche  BIGMACH-3012  - CTL code reconciliation
//**              10/10/13 SPingle   US 1852       - On remove of the last Lite product from the quote,
//**                                                 the "Add'l Products for DRF" dropdown will be set to empty.
//**              10/29/13 RMendoza  US 2089       - Route discounts on local loops to EZ Pricing
//**              11/01/13 RMendoza  US 1053       - Provide EZ Pricing approval routing for iQ Local Loops
//**              11/11/13 RMendoza  US 2147       - Update Pricing Approval to move to Discount Approved if quote is LIT only
//**              11/12/13 pathell   US 2132       - Updated code to Check to see if we are in a Lite Model
//**              11/24/13 SPingle   US 2081       - Persisting the discount return from the OMR util before we even start any further disc calc.
//**              12/09/13 SPingle   DE 234        - For FTTC promos applied for a line, please ignore any approval needed if not POM.
//**              12/20/13 RMendoza  US 2230       - For FTTC promos applied for a line, prevent any manual discounts and EZ Pricing from user
//**              01/05/14 SPingle   US 2383       - Ignore any further approval calculations if Apporved or Rejected by POM
//**              01/21/14 SPingle   US 1311       - Avoid sending Aggregate Billing offerings back to SFA. Do not add them to rollup.
//**              01/21/14 SPingle   US 2410       - Reset Create NSP attribute if quote only has LITE and AB models.
//************************************************************************************************************

/* LIST of keys for quote info dict
    actionName
    ctlUseSelectedEzPromo_quote
    ctlSelectedEzSalesOffer_quote
    ctlSelectedEzPromo_quote
    ctlContractName1_quote
    ctlContractName2_quote
    ctlContractName3_quote
    ctlContractTerm1_quote
    ctlContractTerm2_quote
    ctlContractTerm3_quote
    ctlPreferredDiscountApprover_quote
    ctlPromotionsApplied
    ctlContractCommit1Str
    ctlContractCommit2Str
    ctlContractCommit3Str
    ctlAdditionalProductsForDRF_quote //US 1053
    system_user_login//US 2383
*/

/* LIST of keys for line info dict - key is a complex key with format docNum:key
    modelName           - _model_name
    priceMRCStr         - displayMonthlyList_line
    priceNRCStr         - displayInstallationList_line
    priceMRCNetStr      - displayMonthlyNet_line
    priceNRCNetStr      - displayInstallationNet_line
    offeringID          - ctlSalesOfferId_line
    newLineEZPromo      - ctlEzPromoCode_line
    parentDocNum        - _parent_doc_number
    lineItemComment     - _line_item_comment
    crmExtraInfo        - crmExtraInfo_line
    contractMonthlyDisc - displayContractMonthlyDisc_line
    contractInstallDisc - displayContractInstallationDisc_line
    term1MonthlyDisc    = line.contractTerm1MonthlyDisc //US 1691
    term1InstallDisc    = line.contractTerm1InstallDisc //US 1691
    mrrDiscountType     - displayMRRDiscountType_line
    nrcDiscountType     - displayNRCDiscountType_line
    contractType        - displayContractType_line
    crmPartName         - crmPartName_line
    ctlEzPriceString    - ctlEzPriceString_line
    ctlLocationID       - ctlLocationID_line
    priceStatus         - priceStatus_line
    ctlFdPriceString    - ctlFdPriceString_line
    modelVariableName   - _model_variable_name
    ctlContractName     - ctlContractName_line
    ctlContractBrand    - ctlContractBrand_line
    ctlContractTerm     - ctlContractTerm_line
    ctlContractCommit   - ctlContractCommit_line
    ctlPromotionsApplied- ctlPromotionsApplied_line
    partNumber          - _part_number //US 2089
*/

/*
    GENERAL_INFO         - error messages, debug information, and similar high level data
    LINE_INFO            - line level attribute return
    QUOTE_INFO           - quote level attribute return
    PARENT_DOC_NUMS      - parent doc nums that forms keys to other model dictionaries
    modelMRRNetStrDict   - modelMRRNet
    modelNRCNetStrDict   - modelNRCNet
    modelNYPDict         - modelNYPflags
*/


ret = "";

retDict = dict("dict<string>"); // key: {GENERAL_INFO, LINE_INFO}, 
                                // value: corresponding dictionaries created above that 
                                
docNumVsGeneralInfoDict = dict("string");   // key: documentNumber, value: general information like return string, debug string etc
docNumVsLineInfoDict    = dict("string");   // key: documentNumber, value: values for line level attributes
keyVsQuoteInfoDict      = dict("string");   // key: documentNumber, value: values for quote level attributes
keyVsParentDocNumDict   = dict("string");   // key: parentDocumentNumber, value: parentDocumentNumber

ctlCommitLineVal = 0.0;      //[US 405] Added this for storing config level commit value
ctlExisting      = 0.0;      //[US 967] - Populating existing in Proposal List Totals section
ctlDelta         = 0.0;      //[US 966] - Populating Delta = New - Existing
ctlContractCommit1_quote = 0.0;
ctlContractCommit2_quote = 0.0;
ctlContractCommit3_quote = 0.0;
FDRoutingSupported       = 1;
EZRoutingSupported       = 1;
POMRoutingSupported      = 1;

nameValDelim = "^=^";
pairDelim    = "^-^";
                
// VER 66168/US 394 Declare dictionaries for CTL Contract tab calculations
ctlContractVsContractDict   = dict("string");     //Key = Contract Name, Value = Contract Name
ctlContractVsBrandDict      = dict ("string");    //Key = Contract Name, Value = Brand Name
ctlContractVsTermDict       = dict("string");     //Key = Contract Name, Value = Term
ctlContractVsCommitDict     = dict("string");     //Key = Contract Name, Value = Commit
ctlContractVsMRCActualsDict = dict("float");      //Key = Contract Name, Value = MRC Total values

// US 524  Declare dictionaries for CTL Contract Values for parts - Swapnil P (2-21-13)
ctlModelContractToLineDict  = dict("string");     //Key = Model Doc Number, Value = Model Contract Name
ctlModelBrandToLineDict     = dict("string");     //Key = Model Doc Number, Value = Model Brand Name
ctlModelTermToLineDict      = dict("string");     //Key = Model Doc Number, Value = Model Term
ctlModelCommitToLineDict    = dict("string");     //Key = Model Doc Number, Value = Model Commit
ctlModelEzPromoToLineDict   = dict("string");     //Key = Model Doc Number, Value = Model Ez Promo
ctlChangeOfCommitDict       = dict("string");     //Key = Contract Name, Value = Flag for change of Term or Commit

// [US 523] Fetch existing promo levels from the commerce attribute to assign to the lines
ctlParentDocNumVsBrandDict = dict("string");      //Key = Document Number, Value = Brand

// [US 718] Remember whether we have already output NYP for a model (parent doc)
ctlParentDocNumVsNypOutput  = dict("string");     //Key = parent document number, Value = parent doc number
ctlLiteProductFlagDict      = dict("string");     //Key = model doc num, Value = Flag for LITE products

// [US 718] Remember whether we have already output NSP flag for a model (parent doc)
ctlParentDocNumVsNSPOutput = dict("string");      //Key: parent document number; value: parent doc number

// US 668 - Add CTL part MRC and NRC List, Term, Commit and Contract Type dict's.
// String1: crmPartName^contractType^term^commit
// String2: String1^locationID^mrcList^mrcNet^nrcList^nrcNet^previousMRC         
ctlPartRollupDict           = dict("string");     //Key = String1, Value = string2
ctlPartMRCListDict          = dict("float");      //Key = String1, Value = Sum of MRC List for String1
ctlPartNRCListDict          = dict("float");      //Key = String1, Value = Sum of NRC List for String1
ctlPartMRCNetDict           = dict("float");      //Key = String1, Value = Sum of MRC Net for String1
ctlPartNRCNetDict           = dict("float");      //Key = String1, Value = Sum of NRC Net for String1
ctlPartOTCNetDict           = dict("float");      //Key = String1, Value = Sum of NRC Net for String1
ctlPartPrevMRCDict          = dict("float");      //Key = String1, Value = Sum of prevMRC List for String1
ctlQvValueDict              = dict("float");      //Key = String1, Value = Calculated Qv value associated with the offering
ctlBundleNameDict           = dict("string");     //Key = String1, Value = list of bundle names (seperated bu ";" if morethan 1) for String1
ctlBundleVsParentDocDict    = dict("string");     //Key = Name of a bundle, Value = line parent doc number
ctlProdcutVsOfferingIdDict  = dict("string");     //Key: OfferingID, Value: Product Name
modelNYPDict                = dict("string");
ctlNRCWaiverDict            = dict("string");      //Key = Modifier Value, Value = Eligibility

// VER 66870/[US 935] Mapping from offering names to promos selected for the offering (if any)
ctlOfferingVsEzPromo = dict("string");            //Key = offering name; value = EZ promo level

modelMRRNetStrDict  = dict("string");
modelNRCNetStrDict  = dict("string");

// [US 980] Global variables to track whether any lines on the quote need some various kinds of approval
ctlPOMApprovalRequired      = false;
ctlEZApprovalRequired       = false;
ctlFDApprovalRequired       = false;
ctlEzOrFDApprovalRequired   = false;
ctlEzApprovalOnLoops        = false; // US 2089 Reads from ctlSvcPkgMaster Table to check if part requires EZ Approval
ctlLITApprovalFlag          = true;  // US 2147 Use for Approval Routing if quote has only LITE products
ctlFTTCPromoApplied         = false; //DE234
resetCreateNSP              = true; //US 2410

actionName                    = get(keyVsQuoteValueDict, "actionName");
ctlUseSelectedEzPromo_quote   = get(keyVsQuoteValueDict, "ctlUseSelectedEzPromo_quote");
ctlSelectedEzSalesOffer_quote = get(keyVsQuoteValueDict, "ctlSelectedEzSalesOffer_quote");
ctlSelectedEzPromo_quote      = get(keyVsQuoteValueDict, "ctlSelectedEzPromo_quote");
ctlContractName1_quote        = get(keyVsQuoteValueDict, "ctlContractName1_quote");
ctlContractName2_quote        = get(keyVsQuoteValueDict, "ctlContractName2_quote");
ctlContractName3_quote        = get(keyVsQuoteValueDict, "ctlContractName3_quote");
ctlContractTerm1_quote        = get(keyVsQuoteValueDict, "ctlContractTerm1_quote");
ctlContractTerm2_quote        = get(keyVsQuoteValueDict, "ctlContractTerm2_quote");
ctlContractTerm3_quote        = get(keyVsQuoteValueDict, "ctlContractTerm3_quote");
ctlPreferredDiscountApprover_quote = get(keyVsQuoteValueDict, "ctlPreferredDiscountApprover_quote");
ctlContractCommit1Str         = get(keyVsQuoteValueDict, "ctlContractCommit1_quote");
ctlContractCommit2Str         = get(keyVsQuoteValueDict, "ctlContractCommit2_quote");
ctlContractCommit3Str         = get(keyVsQuoteValueDict, "ctlContractCommit3_quote");
salesChannel                  = get(keyVsQuoteValueDict, "quoteSalesChannel");
ctlAdditionalProductsForDRF   = get(keyVsQuoteValueDict, "ctlAdditionalProductsForDRF_quote");
system_user_login             = get(keyVsQuoteValueDict, "system_user_login");

if(ctlContractCommit1Str <> "" AND NOT isnull(ctlContractCommit1Str) AND isnumber(ctlContractCommit1Str)) {
    ctlContractCommit1_quote = atof(ctlContractCommit1Str);
}
if(ctlContractCommit2Str <> "" AND NOT isnull(ctlContractCommit2Str) AND isnumber(ctlContractCommit2Str)) {
    ctlContractCommit2_quote = atof(ctlContractCommit2Str);
}
if(ctlContractCommit3Str <> "" AND NOT isnull(ctlContractCommit3Str) AND isnumber(ctlContractCommit3Str)) {
    ctlContractCommit3_quote = atof(ctlContractCommit3Str);
}
        
for docNum in docNumArray {
    // Pull the common data here (data needed by model and line)
    modelName = get(docNumKeyVsLineValueDict, docNum + ":modelName");
    ctlPromotionsApplied= get(docNumKeyVsLineValueDict, docNum + ":ctlPromotionsApplied");    
    
    /*********************************** START: CTL Code for Part Lines ****************************************************/
    /* US 523, 524, 594: On save, recalculate the price MRC net and Price NRC net on change of Ez Promo,
       change of Brandlevel Term or Commit. further pushing recalculated values into line attributes.
       US 718: Refactor prior to implementing all pricing in Get All Pricing and associated utility.
            - If term, commit, or ez promo has changed, output source to NYP
            - If promo is changed to NONE, output discounts to 0, nets to list, and source to STD if EZ
            - Otherwise leave everything alone.  Don't output price, or source, or discounts
            - Calculate and output rollup integration 
    */
    if(modelName == "") {
        lineRet             = "";
        crmExtraInfo        = "";
        ctlProductType      = "";
        ctlBundleName       = "";
        ctlProduct          = "";
        newLineEZPromo      = "";
        appliedPromoToLine  = "";
        crmNRCMapping       = "";
        newContractType     = "";

        overrideBundlePromo   = false; //US 1691
        ctlFTTCPromoApplied   = false; //DE234
        
        modelQty    = 1;
        previousMRC = 0.0;
        mrcDiscount = 0.0; 
        ctlNewNet   = 0.0; 
        ctlQVValue  = 0.0; 
        priceMRC    = 0.0;
        priceNRC    = 0.0;
        priceMRCNet = 0.0;
        priceNRCNet = 0.0;
        extNewList  = 0.0;
        
        modelQty            = atoi(get(docNumKeyVsLineValueDict, docNum + ":modelQty"));
        priceMRCStr         = get(docNumKeyVsLineValueDict, docNum + ":priceMRC");
        priceNRCStr         = get(docNumKeyVsLineValueDict, docNum + ":priceNRC");
        priceMRCNetStr      = get(docNumKeyVsLineValueDict, docNum + ":priceMRCNet");
        priceNRCNetStr      = get(docNumKeyVsLineValueDict, docNum + ":priceNRCNet");
        offeringID          = get(docNumKeyVsLineValueDict, docNum + ":offeringID");
        newLineEZPromo      = get(docNumKeyVsLineValueDict, docNum + ":newLineEZPromo");
        parentDocNum        = get(docNumKeyVsLineValueDict, docNum + ":parentDocNum");
        lineItemComment     = get(docNumKeyVsLineValueDict, docNum + ":lineItemComment");
        crmExtraInfo        = get(docNumKeyVsLineValueDict, docNum + ":crmExtraInfo");
        contractMonthlyDisc = atof(get(docNumKeyVsLineValueDict, docNum + ":contractMonthlyDisc"));
        contractInstallDisc = atof(get(docNumKeyVsLineValueDict, docNum + ":contractInstallDisc"));
        term1MonthlyDisc    = atof(get(docNumKeyVsLineValueDict, docNum + ":contractTerm1MonthlyDisc"));//US 1691
        term1InstallDisc    = atof(get(docNumKeyVsLineValueDict, docNum + ":contractTerm1InstallDisc"));//US 1691
        mrrDiscountType     = get(docNumKeyVsLineValueDict, docNum + ":mrrDiscountType");
        nrcDiscountType     = get(docNumKeyVsLineValueDict, docNum + ":nrcDiscountType");
        contractType        = get(docNumKeyVsLineValueDict, docNum + ":contractType");
        crmPartName         = get(docNumKeyVsLineValueDict, docNum + ":crmPartName");
        ctlEzPriceString    = get(docNumKeyVsLineValueDict, docNum + ":ctlEzPriceString");
        ctlLocationID       = get(docNumKeyVsLineValueDict, docNum + ":ctlLocationID");
        priceStatus         = get(docNumKeyVsLineValueDict, docNum + ":priceStatus");
        ctlFdPriceString    = get(docNumKeyVsLineValueDict, docNum + ":ctlFdPriceString");
        ctlNrcWaiverString  = get(docNumKeyVsLineValueDict, docNum + ":ctlNrcWaiverString");
        partNumber          = get(docNumKeyVsLineValueDict, docNum + ":partNumber"); //US 2089
        ctlEzPriceString    = get(docNumKeyVsLineValueDict, docNum + ":ctlEzPriceString"); //US 2089
        
        //US 2081: by default just return any MRC and NRC discounts into the docNumVsLineInfoDict. 
        //This is to make sure we always return a discount when we return data back from this UTIL to global LIU. 
        //These discounts can be from the OMR retrieval util that we do not want to miss when calulating / returning values back from this util.
        put(docNumVsLineInfoDict, docNum + ":contractMonthlyDisc", string(contractMonthlyDisc));
        put(docNumVsLineInfoDict, docNum + ":contractInstallDisc", string(contractInstallDisc));
        put(docNumVsLineInfoDict, docNum + ":contractTerm1MonthlyDisc", string(term1MonthlyDisc));
        put(docNumVsLineInfoDict, docNum + ":contractTerm1InstallDisc", string(term1InstallDisc));
        //Below code is to make sure we put the pricingSubStr in the return line dict. This should only be populated for ICB or ERR lines.
        if(get(docNumKeyVsLineValueDict, docNum + ":pricingSubStr") <> "" AND NOT isnull(get(docNumKeyVsLineValueDict, docNum + ":pricingSubStr"))){
             put(docNumVsLineInfoDict, docNum + ":pricingSubStr", get(docNumKeyVsLineValueDict, docNum + ":pricingSubStr"));
             put(docNumVsLineInfoDict, docNum + ":priceStatus", get(docNumKeyVsLineValueDict, docNum + ":priceStatus"));
        }
        
        if(priceMRCStr <> "" AND NOT isnull(priceMRCStr) AND isnumber(priceMRCStr)) {
            priceMRC = atof(priceMRCStr);
        }
        
        if(priceNRCStr <> "" AND NOT isnull(priceNRCStr) AND isnumber(priceNRCStr)) {
            priceNRC = atof(priceNRCStr);
        }
        
        if(priceMRCNetStr <> "" AND NOT isnull(priceMRCNetStr) AND isnumber(priceMRCNetStr)) {
            priceMRCNet = atof(priceMRCNetStr);
        }
        
        if(priceNRCNetStr <> "" AND NOT isnull(priceNRCNetStr) AND isnumber(priceNRCNetStr)) {
            priceNRCNet = atof(priceNRCNetStr);
        }
        
        if(NOT containskey(ctlProdcutVsOfferingIdDict, offeringID)){
            offerNames = bmql("SELECT distinct ProductName, CrmNrcMapping from ctlProduct WHERE SalesOfferingID = $offeringID");
            for option in offerNames {
                ctlProduct = get(option, "ProductName");
                crmNRCMapping = get(option, "CrmNrcMapping");
                put(ctlProdcutVsOfferingIdDict, offeringID + ":OFFERINGID", ctlProduct);
                put(ctlProdcutVsOfferingIdDict, offeringID + ":NRCMAP", crmNRCMapping); //US 1270  - Get the OTC/NRC flag       
                break;
            }
        }
        else{
            ctlProduct = get(ctlProdcutVsOfferingIdDict, offeringID + ":OFFERINGID");
            crmNRCMapping = get(ctlProdcutVsOfferingIdDict, offeringID + ":NRCMAP");
        }
        
        if((actionName == "applyDiscounts")
                AND ctlUseSelectedEzPromo_quote == "true"
                AND (ctlSelectedEzSalesOffer_quote <> "")
                AND (ctlSelectedEzSalesOffer_quote == ctlProduct)){
            newLineEZPromo = ctlSelectedEzPromo_quote;
        }
        
        litePartFlag = false;
        
        //US 705: Check for LITE parts and set the pricing source to 'LIT' 
        if(containskey(ctlLiteProductFlagDict, parentDocNum)){
            litePartFlag = true;
        }
		//US 2147 Adding logic to set to false if part is not LIT
		else{
			ctlLITApprovalFlag = false;
		}
        
        //US 1852: On deleting a last LITE line item, make sure to reset the Additional Products for DRF attribute with correct value.
        //US 2410: Removed the code that was here to support US 1852. We no longer set the ctlAdditionalProductsForDRF_quote for LITE products. 

        if(lineItemComment <> "") {
            //[US 758/705] : Get Previous MRC value from Comment field
            
            //US 919: Get Product Type, PrevMRC, Bundle Names from crmExtraInfo_line attribute (SPingle).
            if(crmExtraInfo <> ""){
                /************************* START decodeNameValuePair UTIL CODE ***********************/
                // The below code is copied from the util decodeNameValuePair(). Once we get function calling
                // functions then we can replace the code with the util call.
                // keyValPairsDict = util.decodeNameValuePair(crmExtraInfo, "#^#", "#!#");
                //Sample string: prevMRC#^#0.0#!#ctlProductType#^#New#!#ctlProductBundle#^#Data Standard
                keyValPairsDict = dict("string");
                nameValuePairsArray = split(crmExtraInfo, pairDelim);
                for nameValuePair in nameValuePairsArray {
                    tempData = split(nameValuePair, nameValDelim);
                    if(tempData[0] <> "") {
                        put(keyValPairsDict, tempData[0], tempData[1]);
                    }
                }
                /************************* END decodeNameValuePair UTIL CODE *************************/
                
                if(containskey(keyValPairsDict, "prevMRC") AND get(keyValPairsDict, "prevMRC") <> ""){
                   previousMRC = atof(get(keyValPairsDict, "prevMRC"));
                }
                if(containskey(keyValPairsDict, "ctlProductType")){
                    ctlProductType = get(keyValPairsDict, "ctlProductType");
                }
                //US 939: Track Bundles for SFA
                if(containskey(keyValPairsDict, "ctlProductBundle")){
                    ctlBundleName = get(keyValPairsDict, "ctlProductBundle");
                }
            }
            
            // [US 1210] Override discounts if the part is in a bundle
            if (ctlBundleName <> ""){
                newLineEZPromo = "";
                
                fMRC = priceMRC;
                // US 1691 - Check to see if the bundle promo discount was manually overridden by User. If yes, then append the crmExtraInfo attribute
                // value with a bundle overridden text. This tells that the part had a bundle promo but that promo was overridden by user by applying manual MRC discounts.
                // For MRC promo
                if(contractMonthlyDisc <> term1MonthlyDisc AND find(ctlBundleName, "MRCOverridden") == -1){
                    crmExtraInfo = crmExtraInfo + "!#!MRCOverridden";
                }
                else{
                    if(find(crmExtraInfo, "!#!MRCOverridden") == -1){
                        if (fMRC <> 0.0) {
                            if(mrrDiscountType == "%"){
                                contractMonthlyDisc = ((fMRC - priceMRCNet) * 100)/ fMRC;
                            }
                            else{
                                contractMonthlyDisc = fMRC - priceMRCNet;
                            }
                        }
                        else{
                            contractMonthlyDisc = 0.0;
                        }
                    }
                }
                
                fNRC = priceNRC;
                // US 1691: For NRC promo
                if(contractInstallDisc <> term1InstallDisc AND find(ctlBundleName, "NRCOverridden") == -1){
                    crmExtraInfo = crmExtraInfo + "!#!NRCOverridden";
                }
                else{
                    if(find(crmExtraInfo, "!#!NRCOverridden") == -1){
                        if (fNRC <> 0.0) {
                            if(nrcDiscountType == "%"){
                                contractInstallDisc = ((fNRC - priceNRCNet) * 100)/ fNRC;
                            }
                            else{
                                contractInstallDisc = fNRC - priceNRCNet;
                            }
                        }
                        else{
                            contractInstallDisc = 0.0;
                        }
                    }
                }
                
                //US 1691: If either the MRC or NRC promo discounts were altered, then please mark the part with "overrideBundlePromo". This is used in routing process below
                //Also we cleared the bundle promo from the ctlPromotionsApplied_line attribute that was coming in from Pricing services. 
                if(find(crmExtraInfo, "!#!MRCOverridden") <> -1 OR find(crmExtraInfo, "!#!NRCOverridden") <> -1){
                    overrideBundlePromo = true;
                    lineRet = lineRet   + docNum + "~ctlPromotionsApplied_line~|" ;
                }
                
                put(docNumVsLineInfoDict, docNum + ":contractMonthlyDisc", string(contractMonthlyDisc));
                put(docNumVsLineInfoDict, docNum + ":contractInstallDisc", string(contractInstallDisc));
                put(docNumVsLineInfoDict, docNum + ":mrrDiscountType", "%");
                put(docNumVsLineInfoDict, docNum + ":nrcDiscountType", "%");
                
                lineRet = lineRet   + docNum + "~crmExtraInfo_line~"   + crmExtraInfo   + "|" ;
            }
						
	    //US 2230 - Prevent Discounting if line contains FTTC Promo, Discounts are Reverted back if there are any manual changes
            techDescription = "";
	    //Splitting the line comment to pull the techdescription out of it
            techDescArray = split(lineItemComment, "!@!");
	    if(techDescArray[0] <> ""){
	    	techDescription = techDescArray[0];
		if(find(techDescription, "FTTCIP") <> -1){
	            if(contractMonthlyDisc <> term1MonthlyDisc){
	            	contractMonthlyDisc = term1MonthlyDisc;
	            }
	            if(contractInstallDisc <> term1InstallDisc){
	                contractInstallDisc = term1InstallDisc;
	            }									
	        put(docNumVsLineInfoDict, docNum + ":contractMonthlyDisc", string(contractMonthlyDisc));
	        put(docNumVsLineInfoDict, docNum + ":contractInstallDisc", string(contractInstallDisc));
	        put(docNumVsLineInfoDict, docNum + ":mrrDiscountType", "%");
	        put(docNumVsLineInfoDict, docNum + ":nrcDiscountType", "%");
	        //Set EZPromo to empty if FTTC Promo Exists
	        newLineEZPromo = "";						
		}								
	    }
            
            //US 967: Populating New Net - Ramesh Rouniyar (05-02-2013)
            if(not isnull(contractMonthlyDisc)){    // [US 1210] Using adjusted discount
                mrcDiscount = contractMonthlyDisc; 
            }
            
            if(not isnull(mrrDiscountType) AND mrrDiscountType == "%") {
                ctlNewNet = priceMRC - (priceMRC * mrcDiscount/100);
            } 
            elif(not isnull(mrrDiscountType) AND mrrDiscountType == "Amt") {
                ctlNewNet = priceMRC - mrcDiscount;
            } 
            else {
                ctlNewNet = priceMRC;
            }  
            
            // Code for QV Value 
            // [US 967] - Bug Fix -Ramesh Rouniyar (05-07-2013)
            // [US 967] Populating existing in Proposal List Totals section - Ramesh Rouniyar (04-30-2013)
            ctlExisting = ctlExisting + previousMRC;             
            ctlQVValue = ctlNewNet - previousMRC;
            
            // [US 966] - Populating Delta = New - Existing
            extNewList = priceMRC * modelQty;
            ctlDelta = ctlDelta + (extNewList - previousMRC);
            
            // [US 718] If term or commit has changed, then set source to NYP
            if(get(ctlChangeOfCommitDict, get(ctlModelContractToLineDict, parentDocNum)) == "true" AND litePartFlag == false){
                newContractType = "NYP";
                put(docNumVsLineInfoDict, docNum + ":contractMonthlyDisc", "0.0");
            }
            
            // US 705: LITE and STD parts with manual discounting
            if(contractType <> "NYP" AND newContractType <> "NYP") {
                if(contractMonthlyDisc <> 0.0){     // [US 1210] Using adjusted discount
                    if(mrrDiscountType == "%"){
                        priceMRCNet = round(priceMRC - ((contractMonthlyDisc * priceMRC)/100),2);
                    }elif(mrrDiscountType == "Amt"){ //US 1085- apply $ discount on MRC and NRC list price
                        priceMRCNet = priceMRC - contractMonthlyDisc;
                    }
                }
                else{
                    priceMRCNet = priceMRC;
                }
            
                if(contractInstallDisc <> 0.0){
                    if(nrcDiscountType == "%"){
                        priceNRCNet = round(priceNRC - ((contractInstallDisc * priceNRC)/100),2);
                    }elif(nrcDiscountType == "Amt"){ //US 1085- apply $ discount on MRC and NRC list price
                        priceNRCNet = priceNRC - contractInstallDisc;
                    }
                }
                else{
                    priceNRCNet = priceNRC;
                }
               
                put(docNumVsLineInfoDict, docNum + ":priceMRC", string(priceMRC));
                put(docNumVsLineInfoDict, docNum + ":priceNRC", string(priceNRC));
                put(docNumVsLineInfoDict, docNum + ":priceMRCNet", string(priceMRCNet));
                put(docNumVsLineInfoDict, docNum + ":priceNRCNet", string(priceNRCNet));
                //put(docNumVsLineInfoDict, docNum + ":priceStatus", "");
                
                if(litePartFlag == true){
                    newContractType = "LIT";
                }
                // US 739 - EZ price application
                // if Promo was selected and applied for line's parent.
                elif(newLineEZPromo <> "") { 
                    // making sure we are setting EZ promo price to lines that have EZ levels back from pricing response.
                    if(ctlEzPriceString <> "") {
                        ezMRCDiscount = 0.0;
                        ezNRCDiscount = 0.0;
                        
                        //If Promo was set to None, set Net to List prices. 
                        if(newLineEZPromo == "NONE" AND contractType == "EZ") {
                            priceMRCNet = priceMRC;
                            priceNRCNet = priceNRC;
                            newContractType = "STD";
                        }
                        elif(newLineEZPromo == "NONE" AND contractType <> "EZ") {
                            // [US 1210] Using adjusted discounts
                            ezMRCDiscount = contractMonthlyDisc;    
                            ezNRCDiscount = contractInstallDisc;
                            
                            if(mrrDiscountType == "%") {
                                priceMRCNet = round(priceMRC - ((ezMRCDiscount * priceMRC)/100),2);
                            }
                            //US 1085- apply $ discount on MRC and NRC list price
                            elif(mrrDiscountType == "Amt") { 
                                priceMRCNet = priceMRC - ezMRCDiscount;
                            }
                            
                            if(nrcDiscountType == "%") {
                                priceNRCNet = round(priceNRC - ((ezNRCDiscount * priceNRC)/100),2);
                            }
                            //US 1085- apply $ discount on MRC and NRC list price
                            elif(nrcDiscountType == "Amt") { 
                                priceNRCNet = priceNRC - ezNRCDiscount;
                            }
                        }
                        else {
                            newContractType = "EZ";
                            promoPairs = split(ctlEzPriceString, "^=^");
                            for each in promoPairs {
                                singlePromoVals = split(each, "^-^");
                                ezPromo    = singlePromoVals[0];
                                ezPromoMRC = singlePromoVals[3];
                                //ezPromoNRC = singlePromoVals[4];
                                
                                // selected promo matches the promo in ezprice string
                                if(newLineEZPromo == ezPromo) {
                                    appliedPromoToLine = newLineEZPromo;
                                    
                                    if(ezPromoMRC <> "" AND NOT isnull(ezPromoMRC) AND isnumber(ezPromoMRC)) {
                                        priceMRCNet = atof(ezPromoMRC);
                                    }
                                    
                                   /*Commented to resolve a issue reported while testing for US 1350. User needs to modify NRC discounts on EZ lines. 
                                    if(ezPromoNRC <> "" AND NOT isnull(ezPromoNRC) AND isnumber(ezPromoNRC)) {
                                        priceNRCNet = atof(ezPromoNRC);
                                    }
                                    */
                                    if(mrrDiscountType == "%"){
                                        if(priceMRC <> 0.0){
                                            ezMRCDiscount = ((priceMRC - priceMRCNet) * 100)/ priceMRC;
                                        }
                                    }
                                    elif(mrrDiscountType == "Amt"){
                                        ezMRCDiscount = priceMRC - priceMRCNet;
                                    }
                                    
                                    if(nrcDiscountType == "%") {
                                        if(priceNRC <> 0.0){
                                            ezNRCDiscount = ((priceNRC - priceNRCNet) * 100)/ priceNRC;
                                        }
                                    }
                                    elif(nrcDiscountType == "Amt") {
                                        ezNRCDiscount = priceNRC - priceNRCNet;
                                    }
                                    
                                }
                            }
                        }
                        ctlNewNet = priceMRCNet;//BIGMACH-2611: Update ctlNewNet when applying EZ pricing for a line
                        put(docNumVsLineInfoDict, docNum + ":priceMRC", string(priceMRC));
                        put(docNumVsLineInfoDict, docNum + ":priceNRC", string(priceNRC));
                        put(docNumVsLineInfoDict, docNum + ":priceMRCNet", string(priceMRCNet));
                        put(docNumVsLineInfoDict, docNum + ":priceMRCNet", string(priceMRCNet));
                        put(docNumVsLineInfoDict, docNum + ":contractMonthlyDisc", string(ezMRCDiscount));
                        put(docNumVsLineInfoDict, docNum + ":contractInstallDisc", string(ezNRCDiscount));
                        put(docNumVsLineInfoDict, docNum + ":appliedPromoToLine", appliedPromoToLine);
                    }
                }
                elif(contractType == "ICB") {
                    newContractType = "ICB";
                }
                // BIGMACH-2190/DE 97 - Added check for contract type of ERR to CTL loop
                elif(contractType == "ERR") {
                    newContractType = "ERR";
                }
                else {
                    newContractType = "STD";
                }
            }
            
            //US 1311: Avoid sending Aggregate Billing offerings back to SFA. Check for AB flag in line comment to avoid the adding of offering in rollup dict.
            aggregateBilledPart = false;
            if (find(lineItemComment, "AggregateFlag^=^true") <> -1){
                aggregateBilledPart = true;
            }

            modelMRRNet  = 0.0;
            modelNRCNet  = 0.0;
            
            if(containskey(modelMRRNetStrDict, parentDocNum)){ modelMRRNet =  atof(get(modelMRRNetStrDict, parentDocNum));}
            if(containskey(modelNRCNetStrDict, parentDocNum)){ modelNRCNet =  atof(get(modelNRCNetStrDict, parentDocNum));}
            put(modelMRRNetStrDict, parentDocNum, string(priceMRCNet + modelMRRNet));
            put(modelNRCNetStrDict, parentDocNum, string(priceNRCNet + modelNRCNet));     
            
            put(keyVsParentDocNumDict, parentDocNum, parentDocNum);
            
            parentContract = get(ctlModelContractToLineDict, parentDocNum);
            if(containskey(ctlContractVsMRCActualsDict, parentContract)  
               AND get(ctlContractVsMRCActualsDict, parentContract) > 0.0) {
                put(ctlContractVsMRCActualsDict, 
                    parentContract, 
                    get(ctlContractVsMRCActualsDict, parentContract) + priceMRCNet);
            } else {
                put(ctlContractVsMRCActualsDict, parentContract, priceMRCNet);
            }
            
            //US 668 -  Get the crmPartName in dict. for Rollup integration
            ctlcontractTypeLineVal = get(ctlModelContractToLineDict, parentDocNum);
            ctlTermLineVal = get(ctlModelTermToLineDict, parentDocNum);
            ctlCommitLineVal = atof(get(ctlModelCommitToLineDict, parentDocNum));
            
            //US 1311: updated the condition to make sure we avoid Aggregate billing parts from the rollup    
            if(crmPartName <> "" AND NOT(aggregateBilledPart)) {
                ctlPartRollupDict_Key = crmPartName + "^" + ctlProductType + "^" + ctlcontractTypeLineVal + "^" + ctlTermLineVal + "^" + string(ctlCommitLineVal);
                
                if(NOT(containskey(ctlPartMRCListDict, ctlPartRollupDict_Key))) {
                    put(ctlPartMRCListDict, ctlPartRollupDict_Key, priceMRC);
                    put(ctlPartNRCListDict, ctlPartRollupDict_Key, priceNRC);
                    put(ctlPartMRCNetDict, ctlPartRollupDict_Key, priceMRCNet);
                    //US 1270  - Add NRC net into correct dicts based on the OTC/NRC flag
                    if(crmNRCMapping == "OTC") { 
                        put(ctlPartOTCNetDict, ctlPartRollupDict_Key, priceNRCNet);
                        put(ctlPartNRCNetDict, ctlPartRollupDict_Key, 0.0);
                    } else {
                        put(ctlPartNRCNetDict, ctlPartRollupDict_Key, priceNRCNet);
                        put(ctlPartOTCNetDict, ctlPartRollupDict_Key, 0.0);
                    }
                    
                    put(ctlPartPrevMRCDict, ctlPartRollupDict_Key, previousMRC);
                    put(ctlQvValueDict, ctlPartRollupDict_Key, ctlQVValue);
                } else {
                    put(ctlPartMRCListDict, ctlPartRollupDict_Key, get(ctlPartMRCListDict, ctlPartRollupDict_Key) + priceMRC);
                    put(ctlPartNRCListDict, ctlPartRollupDict_Key, get(ctlPartNRCListDict, ctlPartRollupDict_Key) + priceNRC);
                    put(ctlPartMRCNetDict, ctlPartRollupDict_Key, get(ctlPartMRCNetDict, ctlPartRollupDict_Key) + priceMRCNet);
                    
                    //US 1270  - Add NRC net into correct dicts based on the OTC/NRC flag
                    if(crmNRCMapping == "OTC") {
                        put(ctlPartOTCNetDict, ctlPartRollupDict_Key, get(ctlPartOTCNetDict, ctlPartRollupDict_Key) + priceNRCNet);
                        put(ctlPartNRCNetDict, ctlPartRollupDict_Key, get(ctlPartNRCNetDict, ctlPartRollupDict_Key) + 0.0);
                    } else {
                        put(ctlPartNRCNetDict, ctlPartRollupDict_Key, get(ctlPartNRCNetDict, ctlPartRollupDict_Key) + priceNRCNet);
                        put(ctlPartOTCNetDict, ctlPartRollupDict_Key, get(ctlPartOTCNetDict, ctlPartRollupDict_Key) + 0.0);
                    }
                    
                    put(ctlPartPrevMRCDict, ctlPartRollupDict_Key, get(ctlPartPrevMRCDict, ctlPartRollupDict_Key) + previousMRC);
                    put(ctlQvValueDict, ctlPartRollupDict_Key, get(ctlQvValueDict, ctlPartRollupDict_Key) + ctlQVValue);
                }
              
                if(ctlBundleName <> "") {
                    ctlBundleName = replace(ctlBundleName, "!#!MRCOverridden", "");
                    ctlBundleName = replace(ctlBundleName, "!#!NRCOverridden", "");
                    if(NOT containskey(ctlBundleNameDict, ctlPartRollupDict_Key)) {
                        put(ctlBundleNameDict, ctlPartRollupDict_Key, ctlBundleName);
                        if(NOT containskey(ctlBundleVsParentDocDict, parentDocNum)) {
                            put(ctlBundleVsParentDocDict, parentDocNum, ctlBundleName);  
                            //print "Not Contains Key " + ctlPartRollupDict_Key + " Bundle for - " + ctlBundleName + " " + parentDocNum;
                        }
                        else{
                            put(ctlBundleVsParentDocDict, parentDocNum, get(ctlBundleVsParentDocDict, parentDocNum) + ";" + ctlBundleName);
                        }
                    } else {
                        if(find(get(ctlBundleNameDict, ctlPartRollupDict_Key), ctlBundleName) == -1) {
                            //print "Contains Key " + ctlPartRollupDict_Key + " But Not Bundle - " + ctlBundleName+ " " + parentDocNum;
                            put(ctlBundleNameDict, ctlPartRollupDict_Key, get(ctlBundleNameDict, ctlPartRollupDict_Key) + ";" + ctlBundleName);
                            put(ctlBundleVsParentDocDict, parentDocNum, get(ctlBundleVsParentDocDict, parentDocNum) + ";" + ctlBundleName); 
                        } else {
                            if(NOT containskey(ctlBundleVsParentDocDict, parentDocNum)) {
                                //print "Contains Key " + ctlPartRollupDict_Key + " but Bundle from diff model 1- " + ctlBundleName+ " " + parentDocNum;
                                put(ctlBundleNameDict, ctlPartRollupDict_Key, get(ctlBundleNameDict, ctlPartRollupDict_Key) + ";" + ctlBundleName);
                                put(ctlBundleVsParentDocDict, parentDocNum, ctlBundleName);
                            }
                            elif(find(get(ctlBundleVsParentDocDict, parentDocNum), ctlBundleName) == -1) {
                                //print "Contains Key " + ctlPartRollupDict_Key + " but Bundle from diff model 2- " + ctlBundleName+ " " + parentDocNum;
                                put(ctlBundleNameDict, ctlPartRollupDict_Key, get(ctlBundleNameDict, ctlPartRollupDict_Key) + ";" + ctlBundleName);
                                put(ctlBundleVsParentDocDict, parentDocNum, get(ctlBundleVsParentDocDict, parentDocNum) + ";" + ctlBundleName);
                            }
                        }  
                    }
                }
                
                mrcList    = round(get(ctlPartMRCListDict, ctlPartRollupDict_Key), 2);
                mrcNet     = round(get(ctlPartMRCNetDict, ctlPartRollupDict_Key), 2);
                nrcList    = round(get(ctlPartNRCListDict, ctlPartRollupDict_Key), 2);
                nrcNet     = round(get(ctlPartNRCNetDict, ctlPartRollupDict_Key), 2);
                nrcNetOTC  = round(get(ctlPartOTCNetDict, ctlPartRollupDict_Key), 2);
                prevMrc    = round(get(ctlPartPrevMRCDict, ctlPartRollupDict_Key), 2);
                bundleName = get(ctlBundleNameDict, ctlPartRollupDict_Key);
                qvValue    = round(get(ctlQvValueDict, ctlPartRollupDict_Key), 2);
                
                appendPriceStr = string(mrcList) + "^" + string(mrcNet) + "^" + string(nrcList) + "^" + string(nrcNet) + "^" + string(prevMrc) + "^" +  string(qvValue) + "^" + bundleName + "^" + string(nrcNetOTC);
                put(ctlPartRollupDict, ctlPartRollupDict_Key, ctlPartRollupDict_Key + "^" + ctlLocationID + "^" + appendPriceStr);
            }
            
            // Only set contract type attributes if we have a non-empty value to set them to
            if(newContractType <> "") {
                put(docNumVsLineInfoDict, docNum + ":newContractType", newContractType);
                
                // [JGSmith: 03/21/13] Roll up NYP to parent if any part has NYP
                if(newContractType == "NYP") {
                    put(docNumVsLineInfoDict, docNum + ":priceStatus", "");
                    put(docNumVsLineInfoDict, docNum + ":priceMessageType", "");
                    
                    // If any part is NYP, the parent should be also, but only output once for any parent
                    if(NOT containskey(ctlParentDocNumVsNypOutput, parentDocNum)) {
                        put(docNumVsLineInfoDict, parentDocNum + ":newContractType", "NYP");
                        put(docNumVsLineInfoDict, parentDocNum + ":priceMessageType", "");
                        
                        put(ctlParentDocNumVsNypOutput, parentDocNum, parentDocNum);
                        
                        // These dicts are used in the model loop in the end to display NYP at model level
                        put(modelNYPDict, parentDocNum, "NYP");
                    }
                }
                
                // [US 637: clear tracking id if source indicates it is not applicable
                if((newContractType == "NYP") OR (newContractType == "ERR")) {
                    lineRet = lineRet + docNum + "~ctlLoopTrackingId_line~|"
                                      // [US 1212] Also clear EZ and FD data since repricing will refresh
                                      + docNum + "~ctlEzPriceString_line~|"
                                      + docNum + "~ctlFdPriceString_line~|"
                                      // [US 1350] clear NRC Waiver String          
                                      + docNum + "~ctlNrcWaiverString_line~|";
                }
            }               
        }
        
        // US 524  Set CTL Contract Values from Model dicts to resp. parts - Swapnil P (2-24-13)
        lineRet = lineRet   + docNum + "~ctlContractName_line~"   + get(ctlModelContractToLineDict, parentDocNum)   + "|"                    + docNum + "~ctlContractBrand_line~"  + get(ctlModelBrandToLineDict, parentDocNum)   + "|"
                            + docNum + "~ctlContractTerm_line~"   + get(ctlModelTermToLineDict, parentDocNum)    + "|"
                            + docNum + "~ctlContractCommit_line~" + get(ctlModelCommitToLineDict, parentDocNum)  + "|"
                            + docNum + "~ctlEzPromoCode_line~"    + appliedPromoToLine + "|";
                            
        put(docNumVsLineInfoDict, docNum + ":newNet", string(ctlNewNet));
        put(docNumVsLineInfoDict, docNum + ":quoteValue", string(ctlQVValue));
                            
        // [US 980] Calculate whether this part needs any kind of approval
        partNeedsPomApprovalForMrc      = false;
        partNeedsEzApprovalForMrc       = false;
        partNeedsFdApprovalForMrc       = false;
        partNeedsEzOrFdApprovalForMrc   = false;
        partNeedsPomApprovalForNrc      = false;
        partNeedsEzApprovalForNrc       = false;
        partNeedsFdApprovalForNrc       = false;
        partNeedsEzOrFdApprovalForNrc   = false;
        mrcPromoFlag                    = false;  
        nrcPromoFlag                    = false;  
        triggerWaiverApproval           = false; //US 1350
        byPassNRCApproval               = false; //US 1350
        currentPartSource               = contractType;
        currentPartStatus               = priceStatus; 
        currentPartMrcList              = priceMRC;
        currentPartMrcNet               = 0.0;
        currentPartNrcList              = priceNRC;
        currentPartNrcNet               = 0.0;
        nonStealthEzMrcLevels           = dict("string");
        nonStealthEzNrcLevels           = dict("string");
        stealthMrcLimit                 = currentPartMrcList;
        stealthNrcLimit                 = currentPartNrcList;
        selectedEzEligibility           = "";
        fdMrcLimit                      = currentPartMrcList;
        fdNrcLimit                      = currentPartNrcList;
        
        // Find the lowest stealth MRC and NRC, and any selected EZ level's eligibility\
        // Note that currently we do not get EZ levels for NRC.  The code below is for when we do.
        // When there are no stealth values (for MRC, NRC, or both) the stealth limits will == List
        if(newContractType <> ""){
            currentPartSource = newContractType;
        }
        
        currentPartMrcNet = priceMRCNet;
        currentPartNrcNet = priceNRCNet;
        
        if(ctlEzPriceString <> "") {
            ezPromoStrings = split(ctlEzPriceString, "^=^");
            for eachEzPromoString in ezPromoStrings {
                if(eachEzPromoString == "") {
                    continue;
                }
                singleEzPromoVals   = split(eachEzPromoString, "^-^");
                if(sizeofarray(singleEzPromoVals) < 4) {
                    continue;
                }
             
                if(newLineEZPromo == singleEzPromoVals[0]) {
                   selectedEzEligibility = singleEzPromoVals[2];
                }
                
                ezEligibility = upper(singleEzPromoVals[2]);
                ezMrc         = 0.0;
                ezNrc         = 0.0;
                
                if(isnumber(singleEzPromoVals[3])) {
                    ezMrc = atof(singleEzPromoVals[3]);
                    if((ezEligibility <> "STEALTH") AND NOT containsKey(nonStealthEzMrcLevels, ezMrc)) {
                        put(nonStealthEzMrcLevels, ezMrc, ezEligibility);
                    }
                    if((ezEligibility == "STEALTH") AND (ezMrc < stealthMrcLimit)) {
                        stealthMrcLimit = ezMrc;
                    }
                }
                
                if(isnumber(singleEzPromoVals[4])) {
                    ezNrc = atof(singleEzPromoVals[4]);
                    if((ezEligibility <> "STEALTH") AND NOT containsKey(nonStealthEzNrcLevels, ezNrc)) {
                        put(nonStealthEzNrcLevels, ezNrc, ezEligibility);
                    }
                    if((ezEligibility == "STEALTH") AND (ezNrc < stealthNrcLimit)) {
                        stealthNrcLimit = ezNrc;
                    }
                }
            }
        }
        
        // [US 1212] Extract FD levels and limits from the line level attribute
        if (ctlFdPriceString <> "") {
            fdLevelStrings = split(ctlFdPriceString, "^=^");
            for eachFdLevelString in fdLevelStrings {
                if (eachFdLevelString == "") {
                    continue;
                }
                
                singleFdLevelVals   = split(eachFdLevelString, "^-^");
                if (sizeofarray(singleFdLevelVals) < 2) {
                    continue;
                }
                
                // We use the level 3 FD limit at this time.  Later we may use different levels depending
                // on the user.
                if (find(singleFdLevelVals[0], "3") > -1){
                    if (isnumber(singleFdLevelVals[1])) {
                        fdMrcLimit = atof(singleFdLevelVals[1]);
                    }
                }
            }
        }
        
        //US 1350: Get the NRC waiver modifier values from the string and store them in a dict.
        nrcWaiverPairs = split(ctlNrcWaiverString, "^=^");
        for each in nrcWaiverPairs{
            singleWaiverVals = split(each, "^-^");
            if(singleWaiverVals[0] <> "" AND NOT isnull(singleWaiverVals[0])){
                put(ctlNRCWaiverDict, string(atof(singleWaiverVals[0])), singleWaiverVals[2]);
            }
        } 
        //US 1350: If NRCNet matches a value in the NRCwaiver string, get the respective waiver eligibility and set the NRC waiver approval flags.
        if(containskey(ctlNRCWaiverDict, string(priceNRCNet))){
            if(upper(get(ctlNRCWaiverDict, string(priceNRCNet))) == "SELF SERVE" AND NOT isnull(get(ctlNRCWaiverDict, string(priceNRCNet)))){
                byPassNRCApproval = true;
            }
            elif(UPPER(get(ctlNRCWaiverDict, string(priceNRCNet))) == "APPROVAL" AND NOT isnull(get(ctlNRCWaiverDict, string(priceNRCNet)))){
                triggerWaiverApproval = true;
            }
        }
        
        //[US 1265] - If MRC List and MRC Net differ AND that difference is NOT due to the application of a promo code, then the line item should be considered for discount approval - RRamesh (06-01-2013)
        // Uncommenting - NULL Pointer issue taken care off - RRamesh(06-03-2013)
        //US 1691: Make sure that the part's bundle promo discount was not overridden. update the conditon with an extra AND
        if(not isnull(ctlPromotionsApplied) AND ctlPromotionsApplied <> "" AND NOT overrideBundlePromo){
            promoCode = split(ctlPromotionsApplied, "^=^");
            
            // MRC Code
            if(not isnull(promoCode[0])){
                mrcPromoCode = split(promoCode[0],"^-^");
            // Swapnil PBelow Code causing run time exception..Commenting this for now. Please validate for NULL
                if(not isnull(mrcPromoCode[1]) AND mrcPromoCode[1] <> ""){
                    mrcPromoFlag = true;
                }
            }  
            
            // NRC Code
            if(not isnull(promoCode[1])){
                nrcPromoCode = split(promoCode[1],"^-^");
                if(not isnull(nrcPromoCode[1]) AND nrcPromoCode[1] <> ""){
                    nrcPromoFlag = true;
                }
            }    
        }
        
        
        // [US 1266] Change to use status of POM
        if(currentPartStatus == "POM"){ 
            partNeedsPomApprovalForMrc = true;
        } elif((currentPartSource <> "LIT") AND (currentPartSource <> "NYP")) {
            // No approval needed for not yet priced or lite parts
            if(currentPartMrcNet < currentPartMrcList AND NOT(mrcPromoFlag)) {
                if((currentPartSource == "EZ") OR containsKey(nonStealthEzMrcLevels, currentPartMrcNet)) {
                    if(selectedEzEligibility == "") {
                        selectedEzEligibility = get(nonStealthEzMrcLevels, currentPartMrcNet);
                    }
                    if(selectedEzEligibility <> "SELF SERVE") {
                        // No approval required for self serve EZ
                        partNeedsEzApprovalForMrc = true;
                    }
                } else {
                    //US 1691: Check to see if this is not a bundle overridden part 
                    if(NOT overrideBundlePromo){
                        if(currentPartMrcNet < stealthMrcLimit) {
                            if(currentPartMrcNet < fdMrcLimit) {
                                partNeedsPomApprovalForMrc = true;
                            } else {
                                partNeedsFdApprovalForMrc = true;
                            }
                        } else {
                            if(currentPartMrcNet >= fdMrcLimit) {
                                if(ctlPreferredDiscountApprover_quote == "FD") {
                                    partNeedsFdApprovalForMrc = true;
                                } elif(ctlPreferredDiscountApprover_quote == "EZ") {
                                    partNeedsEzApprovalForMrc = true;
                                } else {
                                    // Part needs approval, but user needs to identify preferred approver
                                    partNeedsEzOrFdApprovalForMrc = true;
                                }
                            } else {
                                partNeedsEzApprovalForMrc = true;
                            }
                        }
                    }
                    else{
                        //US 1691: if this is a bundle overridden part, please send for POM approval
                        partNeedsPomApprovalForMrc = true;
                    }
                }
            }
           
            //US 1350: If NRCWaiver eligibility is found to be "Approval", then route to EZ approval for NRC.
            if(currentPartNrcNet < currentPartNrcList AND (triggerWaiverApproval)){
                partNeedsEzApprovalForNrc  = true;
            }
            
            if(currentPartNrcNet < currentPartNrcList AND NOT(nrcPromoFlag)) {
                if((currentPartSource == "EZ") OR containsKey(nonStealthEzNrcLevels, currentPartNrcNet)) {
                    //US 1350: If NRCNet not found in the NRC waivers, then make sure it is routed to POM.
                    if(currentPartNrcNet < fdNrcLimit AND NOT(triggerWaiverApproval) AND NOT(byPassNRCApproval)) {
                        partNeedsPomApprovalForNrc = true;
                    }
                    else{
                        if(selectedEzEligibility == "") {
                            selectedEzEligibility = get(nonStealthEzNrcLevels, currentPartNrcNet);
                        }
                        if(selectedEzEligibility <> "SELF SERVE") {
                            // No approval required for self serve EZ
                            partNeedsEzApprovalForNrc = true;
                        }
                    }
                } else {
                    //US 1691: Check to see if this is not a bundle overridden part 
                    if(NOT overrideBundlePromo){
                        if(NOT(triggerWaiverApproval) AND NOT(byPassNRCApproval)){//US1350: Bypass this section if NRC discount is eligible for NRC waivers.
                            if(currentPartNrcNet < stealthNrcLimit) {
                                if(currentPartNrcNet < fdNrcLimit) {
                                    partNeedsPomApprovalForNrc = true;
                                } else {
                                    partNeedsFdApprovalForNrc = true;
                                }
                            } else {
                                if(currentPartNrcNet >= fdNrcLimit) {
                                    if(ctlPreferredDiscountApprover_quote == "FD") {
                                        partNeedsFdApprovalForNrc = true;
                                    } elif(ctlPreferredDiscountApprover_quote == "EZ") {
                                        partNeedsEzApprovalForNrc = true;
                                    } else {
                                        // Part needs approval, but user needs to identify preferred approver
                                        partNeedsEzOrFdApprovalForNrc = true;
                                    }
                                } else {
                                    partNeedsEzApprovalForNrc = true;
                                }
                            }
                        }
                    }
                    else{
                        //US 1691: if this is a bundle overridden part, please send for POM approval
                        partNeedsPomApprovalForNrc = true;
                    }
                }
            }
        }
        //Us 2383: Support POM roundtrip - Please ignore any further approval calculations if Apporved or Rejected by POM user
        if((actionName <> "Approve Discount" OR actionName <> "Reject Discount") AND system_user_login <> "pomapiuser"){
            //US 1341: Federal Sales Pros need pricing approval to bypass FD and go directly to POM   
            salesChannel = get(keyVsQuoteValueDict, "salesChannel_quote");
            results = bmql("SELECT FDRoutingSupported, EZRoutingSupported, POMRoutingSupported from ctlSalesChannel WHERE QuoteSalesChannel = $salesChannel");
            for result in results {
                //Routing flags pulled from datatable based on Sales Channel
                if(NOT isnull(get(result, "FDRoutingSupported"))AND get(result, "FDRoutingSupported") <> ""){
                    FDRoutingSupported  = atoi(get(result, "FDRoutingSupported"));
                }
                if(NOT isnull(get(result, "EZRoutingSupported"))AND get(result, "EZRoutingSupported") <> ""){
                    EZRoutingSupported  = atoi(get(result, "EZRoutingSupported"));
                }
                if(NOT isnull(get(result, "POMRoutingSupported"))AND get(result, "POMRoutingSupported") <> ""){
                    POMRoutingSupported = atoi(get(result, "POMRoutingSupported"));
                }
            }
            
            //US 2089 - Route discounts on local loops to EZ Pricing 
            EZApprovals = bmql("SELECT EZApprovalOnDiscount from ctlSvcPkgMaster WHERE SvcPkgName = $partNumber");				
            for approval in EZApprovals{
                    if(NOT isnull(get(approval, "EZApprovalOnDiscount"))AND get(approval, "EZApprovalOnDiscount") == "M"){
                            ctlEzApprovalOnLoops = true;
                            break;
                    }
            }				
            
            //DE234: Check to see if any FTTC promos applied on this line. This promo code is be part of techdescription.
            //This is a temporary fix for now until we bring in a bigger story to handle all the whereabouts of FTTC promo's in commerce.
            techDescription = "";
            //Splitting the line comment to pull the techdescription out of it
            techDescArray = split(lineItemComment, "!@!");
            if(techDescArray[0] <> ""){
                techDescription = techDescArray[0];
                if(find(techDescription, "FTTCIP") <> -1){
                    ctlFTTCPromoApplied = true;
                }
            }
                                                           
            // Update global flags
            // US 2089 Added condition to check the ctlEZApprovalFlag and ctlEZPriceString to route discount for EZ Pricing based on ctlSvcPkgMaster table
            // US 2089 Condition checks if MRC discount exists and there is no NRC discount for this part
            // US 1053 check DRF attribute, if No then use existing logic, if Yes then check for Non LITE items and route to POM if Non LITE items exist
            //DE 234: When a FTTC Promo is applied to the line, please ignore any approval needed/required flags when not POM.
            if (ctlAdditionalProductsForDRF == "No" OR ctlAdditionalProductsForDRF == ""){
                if(ctlEzApprovalOnLoops AND ctlEzPriceString == "" AND (currentPartMrcNet < currentPartMrcList) AND (currentPartNrcNet == currentPartNrcList) AND ctlPOMApprovalRequired == false AND ctlFTTCPromoApplied == false){
                    ctlEZApprovalRequired = true;
                    put(docNumVsLineInfoDict, docNum + ":ctlEZApprovalRequired", string(ctlEZApprovalRequired));
                }
                else{
                    if(partNeedsPomApprovalForMrc OR partNeedsPomApprovalForNrc){
                        if(POMRoutingSupported == 1){//Check if POM flag from table
                            ctlPOMApprovalRequired = true;
                            put(docNumVsLineInfoDict, docNum + ":ctlPOMApprovalRequired", string(ctlPOMApprovalRequired));
                        }   
                    }elif(partNeedsEzApprovalForMrc OR partNeedsEzApprovalForNrc){
                        if(EZRoutingSupported == 1){//Check if EZ flag from table
                            ctlEZApprovalRequired = true;
                            put(docNumVsLineInfoDict, docNum + ":ctlEZApprovalRequired", string(ctlEZApprovalRequired));
                        }elif(POMRoutingSupported == 1){//Check if POM flag from table
                            ctlPOMApprovalRequired = true;
                            put(docNumVsLineInfoDict, docNum + ":ctlPOMApprovalRequired", string(ctlPOMApprovalRequired));
                        }
                    }elif(partNeedsFdApprovalForMrc OR partNeedsFdApprovalForNrc){
                        if(FDRoutingSupported == 1){//Check if FD flag from table
                            ctlFDApprovalRequired = true;
                            put(docNumVsLineInfoDict, docNum + ":ctlFDApprovalRequired", string(ctlFDApprovalRequired));
                        }elif(POMRoutingSupported == 1){//Check if POM flag from table
                            ctlPOMApprovalRequired = true;
                            put(docNumVsLineInfoDict, docNum + ":ctlPOMApprovalRequired", string(ctlPOMApprovalRequired));
                        }   
                    }elif(partNeedsEzOrFdApprovalForMrc OR partNeedsEzOrFdApprovalForNrc){
                        if(FDRoutingSupported == 1 OR EZRoutingSupported == 1){//Check if FD or EZ flag from table
                            ctlEzOrFDApprovalRequired = true;
                            put(docNumVsLineInfoDict, docNum + ":ctlEzOrFDApprovalRequired", string(ctlEzOrFDApprovalRequired));
                        }elif(POMRoutingSupported == 1){//Check if POM flag from table
                            ctlPOMApprovalRequired = true;
                            put(docNumVsLineInfoDict, docNum + ":ctlPOMApprovalRequired", string(ctlPOMApprovalRequired));
                        }
                    }
                }
            }// US 1053 Route to POM if DRF is Yes and Non Lite Parts exist
            // US 2147 Adding condition to check if quote has all Lite Parts and if so approval is not required
            elif(ctlAdditionalProductsForDRF == "Yes" AND ctlLITApprovalFlag == false){
                    ctlPOMApprovalRequired = true;
                    put(docNumVsLineInfoDict, docNum + ":ctlPOMApprovalRequired", string(ctlPOMApprovalRequired));
            }		
        }
        // [US 980] Update NSP approval logic:
        // If Part is LITE OR PART is NYP the above logic will keep approval flags false
        if((partNeedsEzApprovalForMrc
            OR partNeedsFdApprovalForMrc
            OR partNeedsPomApprovalForMrc
            OR partNeedsEzOrFdApprovalForMrc
            OR partNeedsEzApprovalForNrc
            OR partNeedsFdApprovalForNrc
            OR partNeedsPomApprovalForNrc
            OR partNeedsEzOrFdApprovalForNrc)) {
            
            put(docNumVsLineInfoDict, docNum + ":approvalNeededType", "Y");
            
            // US 718: Remember whether we have already output NSP flag for a model (parent doc)
            if (NOT containskey(ctlParentDocNumVsNSPOutput, parentDocNum)) {
                put(docNumVsLineInfoDict, parentDocNum + ":approvalNeededType", "Y");
                put(ctlParentDocNumVsNSPOutput, parentDocNum, parentDocNum);
            }
        } else {
            put(docNumVsLineInfoDict, docNum + ":approvalNeededType", "");
            
            // US 718: Remember whether we have already output NSP flag for a model (parent doc)
            if (NOT containskey(ctlParentDocNumVsNSPOutput, parentDocNum)) {
                put(docNumVsLineInfoDict, parentDocNum + ":approvalNeededType", "");
            }
        }   
        
        // [US 622] Make pricing source blank if manual discount is applied
        if(((priceMRC <> priceMRCNet) OR (priceNRC <> priceMRCNet))
                AND ((newLineEZPromo == "") OR (newLineEZPromo == "NONE")) AND newContractType <> "NYP") {
            put(docNumVsLineInfoDict, parentDocNum + ":newContractType", "");
        }
                
        ret = ret + lineRet; 
    }
    /*********************************** END: CTL Code for Part Lines ****************************************************/
    
    /*********************************** START: CTL Code for Model Lines ****************************************************/
    /* US 523, 524, 594: On save, check to see if Brand level Commit or Term was changed. 
                    store a  flag in dict to signify changes for a Brand. Further store values in respective
                     model level dict's that can be used in the part line loop.
    */                 
    // VER 66168/US 394 - For lines that are product models, extract unique brands, and corresponding terms
    // and commitments.  Also keep running total of MRC for the brand
    else {
        lineRet = "";
        ctlCommit = 0.0;
                
        modelVariableName   = get(docNumKeyVsLineValueDict, docNum + ":modelVariableName");
        ctlContractName     = get(docNumKeyVsLineValueDict, docNum + ":ctlContractName");
        ctlContractBrand    = get(docNumKeyVsLineValueDict, docNum + ":ctlContractBrand");
        ctlContractTerm     = get(docNumKeyVsLineValueDict, docNum + ":ctlContractTerm");
        ctlCommitStr        = get(docNumKeyVsLineValueDict, docNum + ":ctlContractCommit");
        
        if(ctlCommitStr <> "" AND isnumber(ctlCommitStr)) {
            ctlCommit = atof(ctlCommitStr);
        }
        
        //US 705 : Check for LITE Model
        //US 2132 : Check to see if we are in a Lite Model
        if(find(upper(modelVariableName), "GENERICLITEMODEL") <> -1 ){	
            put(ctlLiteProductFlagDict, docNum, "true");
        }
        
        if(isnull(ctlContractName)) {
            ctlContractName = "";
        }
      
        if(isnull(ctlContractBrand)) {
            ctlContractBrand = "";
        }
        
        // [US 523] Remember brand for this document number
        put(ctlParentDocNumVsBrandDict, docNum, ctlContractName);
       
        if(isnull(ctlContractTerm )) {
            ctlContractTerm = "";
        }
        
        if(NOT(containskey(ctlContractVsBrandDict, ctlContractName))){
            put(ctlContractVsContractDict, ctlContractName, ctlContractName);
            put(ctlContractVsBrandDict, ctlContractName, ctlContractBrand);
            
            // [US 1089] Remove checks on change to contract term
            if(ctlContractName == ctlContractName1_quote){
                if(ctlContractCommit1_quote <> ctlCommit){  //If Commit has changed on quote level
                    ctlContractTerm = ctlContractTerm1_quote;
                    ctlCommit = ctlContractCommit1_quote;
                    
                    put(ctlChangeOfCommitDict, ctlContractName, "true");//set flag for this brand
                    put(ctlContractVsTermDict, ctlContractName, ctlContractTerm1_quote );
                    put(ctlContractVsCommitDict, ctlContractName, string(ctlCommit));//get the new commit
                }
                else{
                    put(ctlChangeOfCommitDict, ctlContractName, "false");
                }
            }
            
            if(ctlContractName == ctlContractName2_quote){
                if(ctlContractCommit2_quote <> ctlCommit){  //If Commit has changed on quote level
                    ctlContractTerm = ctlContractTerm2_quote;
                    ctlCommit = ctlContractCommit2_quote;
                    put(ctlChangeOfCommitDict, ctlContractName, "true");//set flagfor this brand
                    put(ctlContractVsTermDict, ctlContractName, ctlContractTerm2_quote );
                    put(ctlContractVsCommitDict, ctlContractName, string(ctlCommit));//get new commit
                }
                else{
                    put(ctlChangeOfCommitDict, ctlContractName, "false");
                }
            }
            
            if(ctlContractName == ctlContractName3_quote){
                if(ctlContractCommit3_quote <> ctlCommit){  //If Commit has changed on quote level
                    ctlContractTerm = ctlContractTerm3_quote;
                    ctlCommit = ctlContractCommit3_quote;
                    put(ctlChangeOfCommitDict, ctlContractName, "true");//set flag for this brand
                    put(ctlContractVsTermDict, ctlContractName, ctlContractTerm3_quote );
                    put(ctlContractVsCommitDict, ctlContractName, string(ctlCommit));//get new commit
                }
                else{
                    put(ctlChangeOfCommitDict, ctlContractName, "false");
                }
            }
            
            // if there was no change to Commit for this current Brand on the quote.
            // This means there is no change in Commit for the resp. Brand
            if(containskey(ctlChangeOfCommitDict, ctlContractName) AND get(ctlChangeOfCommitDict, ctlContractName)== "false"){
                put(ctlContractVsTermDict, ctlContractName, ctlContractTerm );
                if(ctlCommit <> 0.0){
                    put(ctlContractVsCommitDict, ctlContractName, string(ctlCommit));
                } else{
                    put(ctlContractVsCommitDict, ctlContractName, "0.0");
                }
            }
        }
        
        // US 524  Set CTL model dicts Model dicts to store Model level Contract values
        if(NOT(containskey(ctlModelContractToLineDict, docNum))){
                put(ctlModelContractToLineDict, docNum, ctlContractName);
                put(ctlModelBrandToLineDict, docNum, ctlContractBrand);
                put(ctlModelTermToLineDict, docNum, ctlContractTerm );
                put(ctlModelCommitToLineDict, docNum, string(ctlCommit));
        }
        
        //US 2410: Reset Create NSP attribute if quote only has LITE and AB models. If we find a detailed model on quote, set the flag to false.
        if(find(upper(modelVariableName), "GENERICLITEMODEL") == -1 OR find(modelName, "Aggregate Billing") == -1){
            resetCreateNSP = false;
        }
        
        // US 524  Set CTL Contract Values from Model dicts to resp. parts
        lineRet = lineRet   + docNum + "~ctlContractName_line~"   + ctlContractName  + "|" 
                            + docNum + "~ctlContractBrand_line~"  + ctlContractBrand         + "|"
                            + docNum + "~ctlContractTerm_line~"   + ctlContractTerm          + "|"
                            + docNum + "~ctlContractCommit_line~" + string(ctlCommit) + "|";
               
        ret = ret + lineRet;
    }
    /*********************************** END: CTL Code for Model Lines ****************************************************/
}

/*********************************** START: CTL QUOTE Level Returns ****************************************************/
// VER 66168/US 394 - Returning CTL Contract Summary info - John G Smith 
ctlCommitStr = "";
ctlContractArray = values(ctlContractVsContractDict);    // Array of unique Contract names referenced on the quote
dictIndex = range(sizeofarray(ctlContractArray));  // Indexes in to the array of brand values
for i in dictIndex {
    ctlContractName = ctlContractArray[i];
    ctlBrand        = get(ctlContractVsBrandDict, ctlContractName);
    ctlTerm         = get(ctlContractVsTermDict, ctlContractName);
    ctlCommitStr    = get(ctlContractVsCommitDict, ctlContractName);
    
    // For each unique brand, set quote attributes for the contract type, term, commit, and mrc total
    ret = ret + "1~ctlContractBrand" + string(i+1) + "_quote~"      + ctlBrand              + "|"
              // Contract Name should not be needed here as we never add a new line through update
              + "1~ctlContractTerm" + string(i+1) + "_quote~"       + ctlTerm               + "|"
              + "1~ctlContractCommit" + string(i+1) +"_quote~"      + ctlCommitStr          + "|"
              + "1~ctlContractMRCActuals" + string(i+1) + "_quote~" + string(get(ctlContractVsMRCActualsDict, ctlContractName)) + "|";
} // End of "for i in dictIndex"
    
// Now we need to clear the remaining rows of contract type, name, term, commit, and actuals in case they had
// values before, such as when we delete a line item
if (sizeofarray(ctlContractArray) < 3){    // Number of rows in our contract summary table
    // We get 3 - index from this, and convert it back in the loop
    remainingIndexes = range(3 - sizeofarray(ctlContractArray));
    // So for example, if we have a non-empty entry on row 1, the range above will be range(3-1), which
    // will be the array {0, 1}.  These are indexes "from the tail end" of the array, and can be converted
    // to table rows using (3 - this value)
    for i in remainingIndexes{
        indexToUse = 3 - i;
         ret = ret + "1~ctlContractBrand" + string(indexToUse) + "_quote~"       + ""    + "|"
                   + "1~ctlContractTerm" + string(indexToUse) + "_quote~"        + ""    + "|"
                   + "1~ctlContractName" + string(indexToUse) + "_quote~"        + ""    + "|"  // [US 671]
                   + "1~ctlContractCommit" + string(indexToUse) + "_quote~"      + "0.0" + "|"
                   + "1~ctlContractMRCActuals" + string(indexToUse) + "_quote~"  + "0.0" + "|";
    }
}

// VER 66870/[US 935] CTL: Clear selected offering and promo only if the "use" flag was set to avoid clearing
// In the middle of an operation to set a promo for an offering
if (ctlUseSelectedEzPromo_quote == "true") {
    ret = ret + "1~ctlSelectedEzSalesOffer_quote~|"
              + "1~ctlSelectedEzPromo_quote~|"
              + "1~ctlUseSelectedEzPromo_quote~false|";
}

// BIGMACH-2001 - CTL code reconciliation
// [US 980] Calculate summary quote value and return variable for CTL NSP routing
ctlQuoteLevelApprovalRouting = "";      // Default - quote does not need routing
if (ctlPOMApprovalRequired) {print "Line # 1310";
    ctlQuoteLevelApprovalRouting = "POM";
} elif (ctlEZApprovalRequired) {
    ctlQuoteLevelApprovalRouting = "EZ";
} elif (ctlEzOrFDApprovalRequired) {
    ctlQuoteLevelApprovalRouting = "EZ or FD";
} elif (ctlFDApprovalRequired) {
    ctlQuoteLevelApprovalRouting = "FD";
}
print ctlQuoteLevelApprovalRouting;
ret = ret + "1~ctlDiscountApprovalLevelRequired_quote~" + ctlQuoteLevelApprovalRouting + "|";

//US 2410: Reset CreateNSP attribute if no detailed IQ model found on quote
if(resetCreateNSP){
ret = ret + "1~ctlAdditionalProductsForDRF_quote~|";        
}

if(not isnull(ctlExisting)) {
    put(keyVsQuoteInfoDict, "totalExistingMonthlyNet", string(ctlExisting));
}              

if(not isnull(ctlDelta)) {
    put(keyVsQuoteInfoDict, "totalMonthlyListDelta", string(ctlDelta));
}

rollupArrayValues = values(ctlPartRollupDict);
put(keyVsQuoteInfoDict, "partSummary", join(rollupArrayValues, "!%!"));
/*********************************** END: CTL QUOTE Level Returns ****************************************************/

put(docNumVsGeneralInfoDict, "RETURN_STRING", ret);

put(retDict, "GENERAL_INFO", docNumVsGeneralInfoDict);
put(retDict, "LINE_INFO"   , docNumVsLineInfoDict);
put(retDict, "QUOTE_INFO"  , keyVsQuoteInfoDict);
put(retDict, "PARENT_DOC_NUMS", keyVsParentDocNumDict);
put(retDict, "modelMRRNetStrDict", modelMRRNetStrDict);
put(retDict, "modelNRCNetStrDict", modelNRCNetStrDict);
put(retDict, "modelNYPDict", modelNYPDict);

return retDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_ctlLineItemUpdate_569426710]]></java_class_name><child_class_names></child_class_names><date_modified>1390429011000</date_modified><guid><![CDATA[testsavvis_413874228]]></guid><_children></_children></bm_function><bm_lib_func_param><id>569426712</id><bm_lib_func_id>569426711</bm_lib_func_id><param_name><![CDATA[keyVsQuoteValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1390429011000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_413874231]]></guid></bm_lib_func_param><bm_lib_func_param><id>569426713</id><bm_lib_func_id>569426711</bm_lib_func_id><param_name><![CDATA[docNumArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1390429011000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_413874232]]></guid></bm_lib_func_param><bm_lib_func_param><id>569426714</id><bm_lib_func_id>569426711</bm_lib_func_id><param_name><![CDATA[docNumKeyVsLineValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1390429011000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_413874233]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>120847245</id><name><en><![CDATA[Is Savvis Company Editable]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[isSavvisCompanyEditable]]></variable_name><description><en><![CDATA[Used to Show/Hide the correct Savvis Company Menu depending on the BAN Selection, Current Workflow Step, and Current User Group]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>120847244</function_id><main_script_text></main_script_text><date_modified>1379768480000</date_modified><guid><![CDATA[testsavvis_120847245]]></guid><_children><bm_function><id>120847244</id><ref_type>16</ref_type><script_text><![CDATA[//*************************************************************************************************************
//** Function:    Is Savvis Company Editable (isSavvisCompanyEditable)                                       
//** Type:        utility Function                                                                           
//**                                                                                                         
//** History:     Used to Show/Hide the correct Savvis Company Menu depending on the Current Workflow Step   
//**             and Current User                                                                            
//**                                                                                                         
//** Date         Author     Comment                                                                         
//** 05/16/12     MBelin     VER 62001 - Savvis Company Menu implementation                                  
//** 06/15/12     MBelin     VER 60370 - Updated security requirements per Jamie - ALL in New/Design,        
//**                                     New through Final Customer Review for Admin.                        
//** 06/15/12     MBelin     VER 63577 - Updated security requirements per Flavia - Only A/PD/S/E in New OR  
//**                                     Design,  Only A/PD in Under Design Review to Final Customer Review. 
//** 04/18/13     SKharche   VER 66860 - Savvis company should be editable to sales users till discount approved step
//** 09/05/13     SKharche   BIGMACH-2611 - Allow CTL groups to get access to savvis company menu
//*************************************************************************************************************

//**********************
//** Assume false ... **
//**********************
returnValue = false;

// VER 66860 - Savvis company should be editable to sales users till discount approved step
// Added the additional steps when savvis company should be editable
initialEditStatuses = "start_step~design~underDesignReview~priced~underDiscountReview~discountApproved";
adminPdEditStatuses = "underDesignReview~priced~underDiscountReview~discountApproved~pendingApprovals~finalizedQuote~inCustomerReview";

//*************************************************************
//** First Condition - Only allow Edit if have a New BAN ... **
//*************************************************************
if (upper(CurrentBAN) == "NEW"){
	// VER 63840 - Add IT Business Systems and Sales Business Center to same access as Admin
    //************************************************************
    //** New or Design: Must be Sales, SE, Admin, or PD to edit **
    //************************************************************
    // BIGMACH-2611 - Allow CTL groups to get access to savvis company menu
    if ( (find(initialEditStatuses , CurrentStep) <> -1) AND 
         ( (find(CurrentUserGroups, "GroupSales") <> -1)              OR 
           (find(CurrentUserGroups, "GroupSolutionsEngineer") <> -1)  OR 
           (find(CurrentUserGroups, "GroupAdmin") <> -1)              OR 
           (find(CurrentUserGroups, "GroupProductDevelopment") <> -1) OR
	   (find(CurrentUserGroups, "GroupITBusinessSystems") <> -1)      OR
	   (find(CurrentUserGroups, "GroupSalesBusinessCenter") <> -1)    OR
           (find(CurrentUserGroups, "GroupCTLSales") <> -1) ) ){
        returnValue = true;
    }
    
    //**********************************************
    //** Later Steps: Must be Admin or PD to Edit **
    //**********************************************
    if ( (find(adminPdEditStatuses , CurrentStep) <> -1)           AND 
         ( (find(CurrentUserGroups, "GroupAdmin") <> -1)           OR
	   (find(CurrentUserGroups, "GroupITBusinessSystems") <> -1)   OR	
	   (find(CurrentUserGroups, "GroupSalesBusinessCenter") <> -1) OR
           (find(CurrentUserGroups, "GroupProductDevelopment") <> -1) ) ){
        returnValue = true;
    }

 } // END if New BAN
 
 return returnValue;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_isSavvisCompanyEditable_120847244]]></java_class_name><child_class_names></child_class_names><date_modified>1379768481000</date_modified><guid><![CDATA[testsavvis_120847244]]></guid><_children></_children></bm_function><bm_lib_func_param><id>120847247</id><bm_lib_func_id>120847245</bm_lib_func_id><param_name><![CDATA[CurrentBAN]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1379768481000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_120847247]]></guid></bm_lib_func_param><bm_lib_func_param><id>120847248</id><bm_lib_func_id>120847245</bm_lib_func_id><param_name><![CDATA[CurrentStep]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1379768481000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_120847248]]></guid></bm_lib_func_param><bm_lib_func_param><id>120847249</id><bm_lib_func_id>120847245</bm_lib_func_id><param_name><![CDATA[CurrentUserGroups]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1379768481000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_120847249]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>263833348</id><name><en><![CDATA[Get Recommended Items Return String 2]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getRecommendedItemsReturnString2]]></variable_name><description><en><![CDATA[VER 56432 - Created with new algorithm for realComment/Hierarchy values, and made more forward compatible with hash map]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>263833347</function_id><main_script_text><![CDATA[attr = string [];
atva = string [];
partInfoDict = dict("string");
recItems = "";

append(attr, "A1");
append(attr, "A2");
append(attr, "A3");
append(attr, "A4");

append(atva, "AV1");
append(atva, "AV2");
append(atva, "AV3");
append(atva, "AV4");

part = "IQ+ Premium Port";
mrcPackageId = "2353";
nrcPackageId = "2355";
crmProductId = "100207";  
put(partInfoDict, "crmProductName", crmProductId);
put(partInfoDict, "crmProductId", crmProductId);

put(partInfoDict, "aAddressInfo", "This is hte address");
put(partInfoDict, "prettyDesc", "prettyDesc");  
put(partInfoDict,"mrcPackageId",mrcPackageId);
put(partInfoDict,"nrcPackageId",nrcPackageId);


recItems = recItems + replace(
                     util.getRecommendedItemsReturnString2(part, "1" + 
                     ".001", attr, atva, "", 0, false, "", "USA", partInfoDict),
                                      "|^|", "~" + "1" + "|^|");
return  recItems;]]></main_script_text><date_modified>1390270881000</date_modified><guid><![CDATA[testsavvis_194519016]]></guid><_children><bm_function><id>263833347</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************************************
//** Function:    Get Recommended Items Return String 2 (getRecommendedItemsReturnString2)                       
//** Type:        Utility Library Function                                                                   
//**                                                                                                          
//** Description: Returns the recommended item return string  
//**
//** Parameters: part                   - part number for the selected item
//**             hierarchyLevel         - A Floating Point Numeric (1.000, 1.001) that specifies how the 
//**                                        part relates to other parts and controls sorting within Model within Commerce. 
//**                                        All parts with the same leading number represent the same sold service (Top Product plus addons)
//**                                        Top Level products should end with .000
//**                                        First Top Level Product for model should be 1.000. Second 2.000, etc.
//**                                        Addons share their parents integer number to ensure they stay together and then have a non .000 extension.
//**                                        Addons will be sorted within Commerce based on their suffix. .001 will sort before .002. 
//**                                        Addons with the same extension will sort alphabetically
//**                                        For Typical Savvis Product, the top part will be 1.000 and all addons will be 1.001
//**             attributes             - array of config attributes for this part
//**             values                 - array of values for above attributes
//**             AIP                    - IP for existing parts
//**             isAddonSelected        - flag identifying if Addon is Selected Or Not for the Model
//**             arrayAddonAction       - the action for this item (change, delete, add, "" if not array)
//**             dataCenterOrCountry    - data center/ country info for part
//**             partInfoDict           - holds other information about part
//**                currently passed in:
//**                    prettyDesc      - display description for part
//**                    zAddressInfo    - delimited string of Z address information from part
//**                                      (use Encode Address Info util to create string)
//**                    aAddressInfo    - delimited string of A address information from part
//**                                      (use Encode Address Info util to create string)
//**                    configComment   - this is the comment we show the user in config
//**                    priceMRC        - MRC price of the part
//**                    priceNRC        - NRC price of the part
//**                    crmProductName  - parts in SFDC are summarized based on this index from config.
//**                    ctlSalesOfferId - Sales Offer ID will be attached to the part and later used 
//**                                      in commerce to identify unique CTL Sales EZ offers. 
//**                    crmExtraInfo
//**                    approversList   - Comma separated list of approvers
//**                    mrcPriceSource  - price source for mrc
//**                    nrcPriceSource  - price source for nrc
//**
//**  Return type: string
//**        Format:
//**        part~1 (the qty of parts)~ comment (defined below)~
//**        comment format:
//**        technical description !@! pretty description !@! AIP !@! data center !@! hierarchy level
//**            !@! config comment !@! z address info !@! a address info !@! price MRC !@! price NRC
//**        Example of return string:
//**        Managed Server 1.0~1~Data Center - MS^=^ZZNJ3^-^Chassis - MS^=^HP DL360 G7^-^CPU Count - MS^=^2^-^CPU Speed - MS^=^
//**        2.26 GHz Intel Xeon Six-Core^-^Hard Drive Count - MS^=^2^-^Hard Drive Size - MS^=^146 GB SAS 10K^-^OS - MS^=^
//**        Red Hat Enterprise Linux AS v5 - 64 bit Managed Operating System^-^OS Ownership - MS^=^Savvis^-^RAM - MS^=^12 GB
//**        ^-^Service Level MS^=^Managed Server!@!ZZNJ3 HP DL360 G7 2 2.26 GHz Intel Xeon Six-Core 2 146 GB SAS 10K 
//**        Red Hat Enterprise Linux AS v5 - 64 bit Managed Operating System Savvis 12 GB Managed Server!@!!@!Add!@!ZZNJ3!@!100!@!50~
//** 
//** Line Item Comment Format
//** Index - Value
//** 1 - techDesc
//** 2 - prettyDescr
//** 3 - AIP
//** 4 - action
//** 5 - dcOrCountry
//** 6 - hierachyLevel
//** 7 - configComment
//** 8 - zAddressInfo
//** 9 - aAddressInfo
//** 10 - priceMRC
//** 11 - priceNRC
//** 12 - crmProductName ....[parts in SFDC are summarized based on this index from config.]
//** 13 - ctlSalesOfferId ...[Sales Offer ID will be attached to the part and later used in commerce to identify unique CTL Sales EZ offers.] 
//** 14 - crmExtraInfo (may contain: prevMRC, ctlProductId, ctlProductType)
//** 15 - commerceExtraInfo (may contain: approversList (Comma separated list), mrcPriceSource, AggregateFlag, and/or nrcPriceSource
//**                                                                                                          
//** History:     Date     Author       Comment                                                               
//**              11/30/12 STillett     VER 56432 - Extend algorithm to get part hierarchy
//**              02/14/13 SKharche     VER 66168 - Move CTL code into SVVS
//**                                                Update the logic to accept priceMRC, priceNRC and push it into the return string
//**              03/25/13 SKharche     VER 66539 - CTL Code Reconciliation
//**                       RConaghan     US 585   - Update the logic to accept crmProductName and push it into the return string
//**                       RConaghan     US 335   - Update the logic to accept crmExtraInfo and push it into the return string
//**              04/22/13 SKharche     VER 66870 - CTL Code Reconciliation
//**                       SArjuna       US 817   - Update the logic to accept crmProductId and push it into the return string
//**                       SPingle       US 874   - Update the logic to accept ctlSalesOfferId and push it into the return string
//**              09/24/13 SKharche     BIGMACH-2710 - CTL code reconciliation
//**                       SArjuna      US 1339      - Update the logic to accept 3 new keys and push 
//**                                                   it into the return string
//**              01/08/13 RConaghan    US 2357   - Added logic to handle part qty via partQty entry in partInfoDict
//**              01/20/14 SArjuna      US 2369   - Added two more keys for CommerceExtraInfo index
//**                                                mrcPackageId and nrcPackageId
//************************************************************************************************************************************

techDescr       = "";
prettyDescr     = "";
encStr          = "";
recItems        = "";
action          = "";
attrvalues      = values;
zAddressInfo    = "";
aAddressInfo    = "";
configComment   = "";
priceMRC        = "";
priceNRC        = "";
crmProductName  = "";
crmProductId    = "";
crmExtraInfo    = "";
ctlSalesOfferId = "";
approversList   = "";
mrcPriceSource  = "";
nrcPriceSource  = "";
aggregateFlag	= "";
partQty		= 1;
mrcPackageId    = "";
nrcPackageId    = "";

stdNameValDelim = "^=^";
stdPairDelim = "^-^";

//encStr is a delimited string to push into the tech description
indexes = range(sizeofarray(attributes));
for index in indexes {
        if(attributes[index] <> "PRETTY_DESC") {
        // VER 63966 - Change the first delimiter to "^=^"
        encStr = encStr + attributes[index] + "^=^" + attrvalues[index] + "^-^";
    } else {
        //VER 64737: get pretty Desc from  values array
        prettyDescr = attrvalues[index];
    }
}

//Look for pretty description in part info dictionary parameter
if(containskey(partInfoDict, "prettyDesc")) {
    prettyDescr = get(partInfoDict, "prettyDesc");
}

//Look for realComment in part info dictionary parameter
if(containskey(partInfoDict, "configComment")) {
    configComment = get(partInfoDict, "configComment");
}

//Look for zAddressInfo in part info dictionary parameter
if(containskey(partInfoDict, "zAddressInfo")) {
    zAddressInfo = get(partInfoDict, "zAddressInfo");
}

//Look for aAddressInfo in part info dictionary parameter
if(containskey(partInfoDict, "aAddressInfo")) {
    aAddressInfo = get(partInfoDict, "aAddressInfo");
}

// VER 66168 - Update the logic to accept priceMRC, priceNRC and push it into the return string
//Look for priceMRC in part info dictionary parameter
if(containskey(partInfoDict, "priceMRC")) {
    priceMRC = get(partInfoDict, "priceMRC");
}

// VER 66168 - Move CTL code into SVVS
//             Update the logic to accept priceMRC, priceNRC and push it into the return string
//Look for priceNRC in part info dictionary parameter
if(containskey(partInfoDict, "priceNRC")) {
    priceNRC = get(partInfoDict, "priceNRC");
}

// VER 66539/US 585 - CTL Code Reconciliation
//Look for crmProductName in part info dictionary parameter
if(containskey(partInfoDict, "crmProductName")) {
    crmProductName = get(partInfoDict, "crmProductName");
}

// VER 66870/US 817 - CTL Code Reconciliation
//Look for crmProductId in part info dictionary parameter
//Modified by Swapnil P to point to the new keyword "ctlSalesOfferId" and if not found then point to crmProductId ..
if(containskey(partInfoDict, "ctlSalesOfferId")){
    ctlSalesOfferId = get(partInfoDict, "ctlSalesOfferId");
} 
elif(containskey(partInfoDict, "crmProductId")) {
    ctlSalesOfferId = get(partInfoDict, "crmProductId");
}

//************BEGIN CRM EXTRA INFO*******************/
// VER 66539/US 335 - CTL Code Reconciliation
// US2431 Standardize legacy crmExtraInfo strings, and added keys for prevMRC, ctlProductId, ctlProductType
//Look for crmExtraInfo in the part info dictionary parameter
legacyCrmExtraInfo = "";
if(containskey(partInfoDict, "crmExtraInfo")){
    legacyCrmExtraInfo = replace(get(partInfoDict, "crmExtraInfo"), "#^#", stdNameValDelim);
	legacyCrmExtraInfo = replace(legacyCrmExtraInfo, "#!#", stdPairDelim);
}

if(containskey(partInfoDict, "prevMRC")) {
    prevMRC = get(partInfoDict, "prevMRC");
	crmExtraInfo = crmExtraInfo + "prevMRC" + stdNameValDelim + prevMRC + stdPairDelim;
}
if(containskey(partInfoDict, "ctlProductId")) {
    ctlProductId = get(partInfoDict, "ctlProductId");
	crmExtraInfo = crmExtraInfo + "ctlProductId" + stdNameValDelim + ctlProductId + stdPairDelim;
}
if(containskey(partInfoDict, "ctlProductType")) {
    ctlProductType = get(partInfoDict, "ctlProductType");
	crmExtraInfo = crmExtraInfo + "ctlProductType" + stdNameValDelim + ctlProductType + stdPairDelim;
}
if(crmExtraInfo <> ""){
	crmExtraInfo = substring(crmExtraInfo, 0, len(crmExtraInfo)-len(stdPairDelim)); //trim trailing stdPairDelim
}
if(legacyCrmExtraInfo <> ""){
	crmExtraInfo = legacyCrmExtraInfo + stdPairDelim + crmExtraInfo;
}
//************END CRM EXTRA INFO*********************/

//************BEGIN COMMERCE EXTRA INFO**************/
// BIGMACH-2710/US 1339 - Pull 3 new pieces of information if present
// Look for approversList in part info dictionary parameter
// US2431 - Added AggregateFlag to commerceExtraInfo and made commerceExtraInfo name-value based
commerceExtraInfo = "";
if(containskey(partInfoDict, "approversList")) {
    approversList = get(partInfoDict, "approversList");
	commerceExtraInfo = commerceExtraInfo + "approversList" + stdNameValDelim + approversList + stdPairDelim;
}
// Look for mrcPriceSource in part info dictionary parameter
if(containskey(partInfoDict, "mrcPriceSource")) {
    mrcPriceSource = get(partInfoDict, "mrcPriceSource");
	commerceExtraInfo = commerceExtraInfo + "mrcPriceSource" + stdNameValDelim + mrcPriceSource + stdPairDelim;
}
// Look for nrcPriceSource in part info dictionary parameter
if(containskey(partInfoDict, "nrcPriceSource")) {
    nrcPriceSource = get(partInfoDict, "nrcPriceSource");
	commerceExtraInfo = commerceExtraInfo + "nrcPriceSource" + stdNameValDelim + nrcPriceSource + stdPairDelim;
}

if(containskey(partInfoDict, "AggregateFlag")){
	aggregateFlag = get(partInfoDict, "AggregateFlag");
	commerceExtraInfo = commerceExtraInfo + "AggregateFlag" + stdNameValDelim + aggregateFlag + stdPairDelim;
}
// US2369 Added mrcPackageId and nrcPackageId
// Look for mrcPackageId in part info dictionary parameter
if(containskey(partInfoDict, "mrcPackageId")) {
    mrcPackageId = get(partInfoDict, "mrcPackageId");
	commerceExtraInfo = commerceExtraInfo + "mrcPackageId" + stdNameValDelim + mrcPackageId + stdPairDelim;
}
// Look for nrcPackageId in part info dictionary parameter
if(containskey(partInfoDict, "nrcPackageId")) {
    nrcPackageId = get(partInfoDict, "nrcPackageId");
	commerceExtraInfo = commerceExtraInfo + "nrcPackageId" + stdNameValDelim + nrcPackageId + stdPairDelim;
}

if(commerceExtraInfo <> ""){
	commerceExtraInfo = substring(commerceExtraInfo, 0, len(commerceExtraInfo)-len(stdPairDelim)); //trim trailing stdPairDelim
}
//*************END COMMERCE EXTRA INFO************/


//US 2357 - Add logic to handle partQty
if(containskey(partInfoDict, "partQty")) {
	tmpQty = get(partInfoDict, "partQty");
	if(isnumber(tmpQty) AND atof(tmpQty) == integer(atof(tmpQty))){
		partQty = integer(atof(tmpQty));
	}
}

techDescr = substring(encStr,0,-3);

//Pretty description is concatenation of all the selected values
if(sizeofarray(values) > 0 AND prettyDescr == "") {
    prettyDescr = join(values, " "); 
}

// Below logic is to get the action performed on the add-on
// Below IF handles the non-array addons
// For non-array addons there is no real action attribute, so based on some information the system decides the correct action
// 1. Default the action to Add
// 2. If AIP is present and the addon is selected then the action should be Change
// 3. If AIP is present and the addon is NOT selected then the action shoule be Delete  
if(arrayAddonAction == "") {
    action = "Add";
    if( AIP <> "" AND isAddOnSelected <> -1 ) {
        action = "Change";
    }
    elif( AIP <> "" AND isAddOnSelected == -1 ) {
        action = "Delete";
    }
}

// Below ELSE handles array addons, array addons have a real action attribute
else {
    action = arrayAddonAction;
    if(AIP <> "" AND isAddOnSelected == -1) {
        action = "Delete";
    }
}

//Get the data center or country, if it is blank then it is considered as Global
dcOrCountry = dataCenterOrCountry;
if(trim(dataCenterOrCountry)=="") { dcOrCountry = "Global"; } 

// VER 66168 - Move CTL code into SVVS
//             Update the logic to accept priceMRC, priceNRC and push it into the return string
// VER 66539 - CTL Code Reconciliation 
// US 585    - Update the logic to accept crmProductName and push it into the return string
// US 335    - Update the logic to accept crmExtraInfo and push it into the return string
// VER 66870 - CTL Code Reconciliation
// BIGMACH-2710/US 1339 - Update the logic to accept approversList, mrcPriceSource, nrcPriceSource 
// and push it into the return string
// US 2357 - Add logic to add partQty field to return string as part quantity
// Build the recommended item string
recItems = part + "~" +string(partQty) + "~" + techDescr + "!@!" + prettyDescr + "!@!" + AIP + "!@!" + action + "!@!" + 
           dcOrCountry + "!@!" + hierarchyLevel + "!@!" + configComment + "!@!" + zAddressInfo + "!@!" + 
           aAddressInfo + "!@!" + priceMRC + "!@!" + priceNRC + "!@!" + crmProductName + "!@!" + 
           ctlSalesOfferId + "!@!"+ crmExtraInfo + "!@!"+ commerceExtraInfo + "~|^|";

return recItems;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getRecommendedItemsReturnString2_263833347]]></java_class_name><child_class_names></child_class_names><date_modified>1390270881000</date_modified><guid><![CDATA[testsavvis_194519015]]></guid><_children></_children></bm_function><bm_lib_func_param><id>263833349</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[part]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1390270881000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_194519018]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833350</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[hierarchyLevel]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1390270881000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_194519019]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833351</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[attributes]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1390270881000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_194519020]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833352</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[values]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1390270881000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_194519021]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833353</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[AIP]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1390270881000</date_modified><order_no>5</order_no><guid><![CDATA[testsavvis_194519022]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833354</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[isAddonSelected]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1390270881000</date_modified><order_no>6</order_no><guid><![CDATA[testsavvis_194519023]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833355</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[isArrayAddon]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>0</datatype><date_modified>1390270881000</date_modified><order_no>7</order_no><guid><![CDATA[testsavvis_194519024]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833356</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[arrayAddonAction]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1390270881000</date_modified><order_no>8</order_no><guid><![CDATA[testsavvis_194519025]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833357</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[dataCenterOrCountry]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1390270881000</date_modified><order_no>9</order_no><guid><![CDATA[testsavvis_194519026]]></guid></bm_lib_func_param><bm_lib_func_param><id>263833358</id><bm_lib_func_id>263833348</bm_lib_func_id><param_name><![CDATA[partInfoDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1390270881000</date_modified><order_no>10</order_no><guid><![CDATA[testsavvis_194519027]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>526580700</id><name><en><![CDATA[Is PO Number Required]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[isPONumberRequired]]></variable_name><description><en><![CDATA[BIGMACH-2189: Util returns a string of "BPID" if BPID needs PO#, "BAN" if BAN needs PO# and "" if no PO# is needed]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>526580699</function_id><main_script_text></main_script_text><date_modified>1374325766000</date_modified><guid><![CDATA[testsavvis_382425038]]></guid><_children><bm_function><id>526580699</id><ref_type>16</ref_type><script_text><![CDATA[//***************************************************************************************************
//** Function:    Is PO Number Required (isPONumberRequired)   
//** Type:        Util                             
//**                                                                                                 
//** Description: Util returns a string of "BPID" if BPID needs PO#, "BAN" if BAN needs PO# and 
//**              "" if no PO# is needed
//**                                                                                                 
//** History:     Date     Author     Comment
//**              07/03/13 STillett   BIGMACH-2189: Creation
//***************************************************************************************************

if(banNumber <> "" AND banNumber <> "New") {
    banRows = bmql("SELECT PORequired FROM BAN WHERE BAN=$banNumber");
    for row in banRows {
        po = get(row, "PORequired");
        if(po == "1") {
                return "BAN";
        }
        if(po == "0") {
        	return "";
        }
    } 
}

bpRows = bmql("SELECT PORequired FROM BP WHERE BPId=$bpid");
for row in bpRows {
    po = get(row, "PORequired");
    if(po == "1") {
        return "BPID";
    }
}

return "";]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_isPONumberRequired_526580699]]></java_class_name><child_class_names></child_class_names><date_modified>1374325766000</date_modified><guid><![CDATA[testsavvis_382425037]]></guid><_children></_children></bm_function><bm_lib_func_param><id>526580701</id><bm_lib_func_id>526580700</bm_lib_func_id><param_name><![CDATA[banNumber]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1374325766000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_382425040]]></guid></bm_lib_func_param><bm_lib_func_param><id>526580702</id><bm_lib_func_id>526580700</bm_lib_func_id><param_name><![CDATA[bpid]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1374325766000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_382425041]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>206743607</id><name><en><![CDATA[Compare Status]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[compareStatus]]></variable_name><description><en><![CDATA[VER 64894: Created for use in scripts where we need to include all the statuses  before X or after X.  Meant to cut down on if statements that are very repetitive in BML.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>3</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>206743606</function_id><main_script_text></main_script_text><date_modified>1358564313000</date_modified><guid><![CDATA[testsavvis_170418514]]></guid><_children><bm_function><id>206743606</id><ref_type>16</ref_type><script_text><![CDATA[//****************************************************************************************
//**	Util Function: Compare Status (compareStatus)									**
//**																					**
//**	Parameters 	1)	currentStatus - status that your quote is currently at			**
//**				2)	targetStatus - status you want to compare your current status to**
//**	Returns		-1 if current status is before target status						**
//**				0 if current status == target status								**
//**				1 if current status is after target status							**						
//**																					**
//**	History:																		**
//**		10/05/12  STillett	VER 64894: Creation										**
//****************************************************************************************

statusArray = string[]{"New", "Design", "Pending SE Approval", 
"Pending DA Approval", "Pending SOW Creation", "Pricing Needed", "Priced", 
"Pending Discount Approval", "Discount Approved", "Pending Credit Approval", 
"Pending Capacity Approval", "Pending OD Approval", "Finalized Quote", 
"Final Customer Review", "Order Submitted - Redline", "Order Submitted", "Booked"};

currentIndex = findinarray(statusArray, currentStatus);
targetIndex = findinarray(statusArray, targetStatus);
if (currentIndex == -1) {
	print "ERROR: CurrentStatus, '" + currentStatus + "' has not been added to the util Compare Status.  Please check the Compare Status util to update.";
	print "The valid input values are " + join(statusArray, ", ");
	return -666;
}
if(targetIndex == -1) {
	print "ERROR: TargetStatus, '" + targetStatus + "' is not part of the util Compare Status.";
	print "The valid input values are " + join(statusArray, ", ");
	return -666;
}

if (currentIndex < targetIndex) {
	return -1;
} elif (currentIndex == targetIndex) {
	return 0;
} else {
	return 1;
}]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_compareStatus_206743606]]></java_class_name><child_class_names></child_class_names><date_modified>1358564313000</date_modified><guid><![CDATA[testsavvis_170418513]]></guid><_children></_children></bm_function><bm_lib_func_param><id>206743608</id><bm_lib_func_id>206743607</bm_lib_func_id><param_name><![CDATA[currentStatus]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_170418516]]></guid></bm_lib_func_param><bm_lib_func_param><id>206743609</id><bm_lib_func_id>206743607</bm_lib_func_id><param_name><![CDATA[targetStatus]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564313000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_170418517]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>13326883</id><name><en><![CDATA[Get DataCenter Constraints]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getDataCenterConstraints]]></variable_name><description><en><![CDATA[Returns list of the valid dataCenters based on the model]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>13326882</function_id><main_script_text></main_script_text><date_modified>1358564319000</date_modified><guid><![CDATA[LEGACY_13326883]]></guid><_children><bm_function><id>13326882</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get DataCenter Constraints (getDataCenterConstraints)                                       **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Returns list of the valid dataCenters based on the model                                    **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

ret = string[];
rows = bmql("SELECT DataCenter FROM SvcPkgLocAvailable WHERE ModelVariableName=$modelVarName");
for row in rows {
	append(ret, get(row, "DataCenter"));
}
return join(ret, "|^|");]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getDataCenterConstraints_13326882]]></java_class_name><child_class_names></child_class_names><date_modified>1358564319000</date_modified><guid><![CDATA[LEGACY_13326882]]></guid><_children></_children></bm_function><bm_lib_func_param><id>13326885</id><bm_lib_func_id>13326883</bm_lib_func_id><param_name><![CDATA[modelVarName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564319000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_13326885]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>392706785</id><name><en><![CDATA[Get Current Minutes]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getCurrentMinutes]]></variable_name><description><en><![CDATA[VER 66620 - gets the current time in minutes]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>392706784</function_id><main_script_text></main_script_text><date_modified>1366470385000</date_modified><guid><![CDATA[testsavvis_287373529]]></guid><_children><bm_function><id>392706784</id><ref_type>16</ref_type><script_text><![CDATA[//*************************************************************************************************************
//** Function:    Get Current Minutes (getCurrentMinutes)
//** Type:        utility Function
//**      
//** Description: This Function es created to provide a single place to consolidate the calculation of the current
//**              minutes value used to keep track of last approvals, so that redundant approvals can be skipped
//**
//**  IMPORTANT NOTE !!! - This calculation MUST be kept in synch with the util.addEvent() function !!!
//**                       We would combine these but for the fact that one utility function cannot call another one! 
//** 
//** Return type: String - returns current time in minutes
//**
//** History:     Date     Author       Comment 
//**              03/29/13 Skharche    VER 66620 - gets the current time in minutes
//***************************************************************************************************************

 return string(getcurrenttimeinmillis()/60000 - 22284000);]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getCurrentMinutes_392706784]]></java_class_name><child_class_names></child_class_names><date_modified>1366470385000</date_modified><guid><![CDATA[testsavvis_287373528]]></guid><_children></_children></bm_function></_children></bm_lib_func><bm_lib_func><id>13891906</id><name><en><![CDATA[Check Salability]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[checkSalability]]></variable_name><description><en><![CDATA[Checks if the model is salable for the customer]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>13891905</function_id><main_script_text></main_script_text><date_modified>1358564318000</date_modified><guid><![CDATA[LEGACY_13891906]]></guid><_children><bm_function><id>13891905</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Check Salability (checkSalability)                                                          **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Checks if the model is salable for the customer                                             **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

strBan = string[];
strBPId = string[];
BAN = "";
BPId = "";
isRestricted = false;

//If salability restricted is 0 then it is NOT salable
rows = bmql("SELECT AddAllowed, SalabilityRestricted FROM SvcPkgMaster WHERE ModelVariableName = $modelVariableName");
for row in rows {
	if( get(row, "AddAllowed") == "1" AND get(row, "SalabilityRestricted") == "0" ) { 
		return false;
	}
	elif( get(row, "AddAllowed") == "1" AND get(row, "SalabilityRestricted") == "1" ) { 
		isRestricted = true;
		break;
	}
}

//If salability restricted is 1 then check to see if the model is salable for the BAN or BPID. 
if(isRestricted) {
	idResults = bmql("SELECT bANNumber_quote, bPID_quote FROM commerce.quote_process");
	for idRes in idResults {
		BAN = get(idRes, "bANNumber_quote");
		BPId = get(idRes, "bPID_quote");
	}

	querySvcPkgSalableByBAN = bmql("SELECT BAN FROM SvcPkgSalableByBAN WHERE ModelVariableName = $modelVariableName");
	for row in querySvcPkgSalableByBAN {
		append(strBan, get(row, "BAN"));
	}
	
	if( findinarray(strBan, BAN) <> -1 ) { return false; }
	
	querySvcPkgSalableByBPId = bmql("SELECT BPId FROM SvcPkgSalableByBP WHERE ModelVariableName = $modelVariableName");
	for row in querySvcPkgSalableByBPId {
		append(strBPId, get(row, "BPId"));
	}
	
	if( findinarray(strBPId, BPId) <> -1) { return false; }
}

return true;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_checkSalability_13891905]]></java_class_name><child_class_names></child_class_names><date_modified>1358564319000</date_modified><guid><![CDATA[LEGACY_13891905]]></guid><_children></_children></bm_function><bm_lib_func_param><id>13891908</id><bm_lib_func_id>13891906</bm_lib_func_id><param_name><![CDATA[modelVariableName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564318000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_13891908]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>161263969</id><name><en><![CDATA[Create HTML Dynamic Menu]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[createHTMLDynamicMenu]]></variable_name><description><en><![CDATA[VER 63760 - Generates an HTML dropdown based on the DynamicMenu table.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>161263968</function_id><main_script_text></main_script_text><date_modified>1358564312000</date_modified><guid><![CDATA[testsavvis_142191971]]></guid><_children><bm_function><id>161263968</id><ref_type>16</ref_type><script_text><![CDATA[//Create HTML Dynmaic Menu Library Function
//For VER 63760

ret = "";

//Set the opening tag for the menu
// VER 63811 - Set width to 100% for all menues
ret = ret + "<select id=\"" + idName + "\" onchange='$(\"input[name=" + attributeName + "]\").val($(this).val());' style=\"width: 100%\">";

//Create the blank option string.
ret = ret + "<option value=\"\"></option>";

//Initialize hasCurrentValue flag
hasCurrentValue = false;

//Query the DynamicMenu table, grabbing all other options
menuOptions = bmql("SELECT DisplayValue, InternalValue from DynamicMenu WHERE Menu = $menuName AND (Active = 1 OR InternalValue = $selectedVal)");
for option in menuOptions {
	dispVal = get(option, "DisplayValue");
	intVal = get(option, "InternalValue");
	
	//Check to see if the option is the current selected value.  If so, make option the default selected value.
	//Also, set hasCurrentValue to true;
	if(intVal == selectedVal){
		ret = ret + "<option value=\"" + intVal + "\" selected=\"selected\">" + dispVal + "</option>";
		hasCurrentValue = true;
	}
	//Create a normal option otherwise
	else {
		ret = ret + "<option value=\"" + intVal + "\">" + dispVal + "</option>";
	}
}

//If current value not in table, create special entry for it.
if(hasCurrentValue == false AND selectedVal <> ""){
	ret = ret + "<option value=\"" + selectedVal + "\" selected=\"selected\">" + selectedVal + "</option>";
}

//Close out the menu tags
ret = ret + "</select>";

return ret;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_createHTMLDynamicMenu_161263968]]></java_class_name><child_class_names></child_class_names><date_modified>1358564312000</date_modified><guid><![CDATA[testsavvis_142191970]]></guid><_children></_children></bm_function><bm_lib_func_param><id>161263970</id><bm_lib_func_id>161263969</bm_lib_func_id><param_name><![CDATA[menuName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564312000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_142191973]]></guid></bm_lib_func_param><bm_lib_func_param><id>161263971</id><bm_lib_func_id>161263969</bm_lib_func_id><param_name><![CDATA[idName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564312000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_142191974]]></guid></bm_lib_func_param><bm_lib_func_param><id>161263972</id><bm_lib_func_id>161263969</bm_lib_func_id><param_name><![CDATA[selectedVal]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564312000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_142191975]]></guid></bm_lib_func_param><bm_lib_func_param><id>161263973</id><bm_lib_func_id>161263969</bm_lib_func_id><param_name><![CDATA[attributeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564312000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_142191976]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>12813376</id><name><en><![CDATA[Other Attribute Matches Primary]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[otherAttributeMatchesPrimary]]></variable_name><description><en><![CDATA[Checks to see if the other field and the primary field are equal]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>12813374</function_id><main_script_text></main_script_text><date_modified>1358564311000</date_modified><guid><![CDATA[LEGACY_12813376]]></guid><_children><bm_function><id>12813374</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Other Attribute Matches Primary (otherAttributeMatchesPrimary)                              **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Checks to see if the other field and the primary field are equal                            **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

if(UPPER(other) == UPPER(primary)) {
	return true;
}

return false;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_otherAttributeMatchesPrimary_12813374]]></java_class_name><child_class_names></child_class_names><date_modified>1358564311000</date_modified><guid><![CDATA[LEGACY_12813374]]></guid><_children></_children></bm_function><bm_lib_func_param><id>12813378</id><bm_lib_func_id>12813376</bm_lib_func_id><param_name><![CDATA[other]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564311000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_12813378]]></guid></bm_lib_func_param><bm_lib_func_param><id>12813379</id><bm_lib_func_id>12813376</bm_lib_func_id><param_name><![CDATA[primary]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564311000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_12813379]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>434651560</id><name><en><![CDATA[Get Physical Address 2]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getPhysicalAddress2]]></variable_name><description><en><![CDATA[The function is used to perform a web service call to the savvis system and get the physical addresses associated with the opportunity]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>434651559</function_id><main_script_text><![CDATA[keywordsVsValuesDict = dict("string");
put(keywordsVsValuesDict, "CompanyName", "testsavvis");
put(keywordsVsValuesDict, "SessionID", "999");
put(keywordsVsValuesDict, "OpportunityID", "1234");
put(keywordsVsValuesDict, "NodeName", "NODE2");

return util.getPhysicalAddress2(keywordsVsValuesDict);]]></main_script_text><date_modified>1386650486000</date_modified><guid><![CDATA[testsavvis_327494151]]></guid><_children><bm_function><id>434651559</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Physical Address 2 (getPhysicalAddress2)                                                   
//** Type:        Utility Library Function                                                                    
//**                                                                                                          
//** Description: The function is used to perform a web service call to the savvis system and                 
//**              get the physical addresses associated with the opportunity                                  
//**                                                                                                          
//** History:     Date     Author       Comment                                                               
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                
//**              05/06/13 STillett     VER 66818 - add identifying tags to WS Call
//**              05/09/13 SKharche     VER 67036 - Add NODE_NAME to XML
//**              12/02/13 SKharche     BIGMACH-3023 - Change URL prefix to support layer 7
//**************************************************************************************************************

headerDict = dict("string");

soapURL         = "";
getAddressXML   = "";
companyName     = "";
sessionID       = "";
opportunityID   = "";
transactionID   = "";
quoteNum        = "";
nodeName        = "";

commerceData = bmql("SELECT transactionID_quote, quoteNumber_quote FROM commerce.quote_process");
for data in commerceData {
    transactionID = get(data, "transactionID_quote");
    quoteNum      = get(data, "quoteNumber_quote");
}

if(containskey(keywordsVsValuesDict, "CompanyName"))    { companyName   = get(keywordsVsValuesDict, "CompanyName"); }
if(containskey(keywordsVsValuesDict, "SessionID"))      { sessionID     = get(keywordsVsValuesDict, "SessionID"); }
if(containskey(keywordsVsValuesDict, "OpportunityID"))  { opportunityID = get(keywordsVsValuesDict, "OpportunityID"); }
if(containskey(keywordsVsValuesDict, "NodeName"))       { nodeName      = get(keywordsVsValuesDict, "NodeName"); }

getAddressXML = urldatabypost("https://" + lower(companyName) + ".bigmachines.com/bmfsweb/" + lower(companyName) + "/image/WebServices/getAddress.xml", "", "SOAP Not Available");
getAddressXML = replace(getAddressXML, "SESSIONID_REPLACE", sessionID);
getAddressXML = replace(getAddressXML, "OPPORTUNITY_ID_REPLACE", opportunityID);
getAddressXML = replace(getAddressXML, "%USERNAME%", _user_login);
getAddressXML = replace(getAddressXML, "%TRAN%", transactionID);
getAddressXML = replace(getAddressXML, "%QN%", quoteNum);
getAddressXML = replace(getAddressXML, "%NODE_NAME%", nodeName);

//GLOBAL VARIABLE CALL
// BIGMACH-3023 - Update URL prefix to support Layer 7. If this is not present then use the regular prefix.
// This is to ensure backward compability and to provide flexibility to turn ON/OFF layer 7
urlHeader = "";
records = bmql("SELECT Value FROM GlobalVars WHERE Keyword = 'SVVS_URL_PREFIX_BMIWS'"); 
for record in records {
    urlHeader = get(record, "Value");
}

if(urlHeader == "") {
    allAttrs = bmql("SELECT Value FROM GlobalVars WHERE Keyword = 'SVVS_URL_PREFIX'");
    for val in allAttrs {
	urlHeader = get(val, "Value");
    }
}
getAddressURL = urlHeader + "BMWebServices/opportunity";

put(headerDict, "Content-Type", "text/xml; charset=utf-8"); //Soap Receiver requires straight text/xml
put(headerDict, "SOAPAction", ""); //Every SOAP call must have a soap Action

getAddressResponse = urldatabypost(getAddressURL, getAddressXML, "Error", headerDict);
return getAddressResponse;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getPhysicalAddress2_434651559]]></java_class_name><child_class_names></child_class_names><date_modified>1386650486000</date_modified><guid><![CDATA[testsavvis_327494150]]></guid><_children></_children></bm_function><bm_lib_func_param><id>434651561</id><bm_lib_func_id>434651560</bm_lib_func_id><param_name><![CDATA[keywordsVsValuesDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1386650486000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_327494153]]></guid></bm_lib_func_param><bm_lib_func_param><id>434651562</id><bm_lib_func_id>434651560</bm_lib_func_id><param_name><![CDATA[_user_login]]></param_name><ref_id>3</ref_id><param_location>1</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1386650486000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_327494154]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>392706779</id><name><en><![CDATA[Check Reapproval Needed]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[checkReapprovalNeeded]]></variable_name><description><en><![CDATA[VER 66620 - Checks if approval is redundant. If approved in the past and nothing changed on the line items then the approval is considered as redundant and it should be skipped 2nd time onwards]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>392706778</function_id><main_script_text><![CDATA[eventDict = dict("string");
baseValueDict = dict("string");

put(eventDict, "GOOD_FOR_DAYS", "1");
put(eventDict, "LAST_APPROVAL_DATE", "04/08/2013 13:40");
put(eventDict, "TIMESTAMP", "464854");
put(eventDict, "MRC", "41687.0");

put(baseValueDict, "TIMESTAMP", "464844");

return util.checkReapprovalNeeded(eventDict, baseValueDict);]]></main_script_text><date_modified>1366470384000</date_modified><guid><![CDATA[testsavvis_290103815]]></guid><_children><bm_function><id>392706778</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Check Reapproval Needed (checkReapprovalNeeded)
//** Type:        Utility Library Function   
//**
//** Description: Checks if approval is redundant. If approved in the past and nothing changed on the line items then 
//**              the approval is considered as redundant and it should be skipped 2nd time onwards.
//** 
//** Param:       keyVsEventDict        - String dictionary containing the events such as TIMESTAMP, MRC, 
//**                                      GOOD_FOR_DAYS, LAST_APPROVAL_DATE (these are the keys as well)
//**              keyVsCurrentValueDict - string dictionary containing current values for TIMESTAMP, MRC, 
//**                                      GOOD_FOR_DAYS (these are the keys as well). These are compared against 
//**                                      the values in the keyVsEventDict
//**
//** Return type: Boolean - returns true if we need reapproval
//**                        returns false if approval need to be skipped
//**
//** History:     Date     Author       Comment 
//**              03/29/13 Skharche    VER 66620 - Checks if approval is redundant
//************************************************************************************************************

lastApprovalTS      = "";
MRC                 = "";
goodForDays         = "";
currentTS           = "";
currentMRC          = "";
currentGoodForDays  = "";
lastApprovalDate    = "";

reapprovalNeeded = false;

// Default diff in days to a big number, because we are checking if diffInDays < goodForDays
// If we default diffInDays to 0 then this check will return incorrect results when the approval is required for the first time
diffInDays       = 999;

// USE CASE 1 - CREDIT approval
// If keyVsEventDict contains MRC then we should do the below logic
if(containskey(keyVsEventDict, "MRC")) {
    MRC = get(keyVsEventDict, "MRC");

    // Get the current MRC
    if(containskey(keyVsCurrentValueDict, "MRC")) {
        currentMRC = get(keyVsCurrentValueDict, "MRC");
    }

    // If the currentMRC equals the event's MRC then the current approval is reduandant
    if(isnumber(currentMRC) AND isnumber(MRC)) {
        if(atof(currentMRC) > atof(MRC)) {
            reapprovalNeeded = true;
        }
    }
}

// USE CASE 2 - CAPACITY, CREDIT approvals
// If keyVsEventDict contains last approval date then we should do the below logic
if(containskey(keyVsEventDict, "LAST_APPROVAL_DATE")) {
    lastApprovalDate = get(keyVsEventDict, "LAST_APPROVAL_DATE");

    currentDate = datetostr(getdate());

    if(lastApprovalDate <> "") {
        diffInDays = getdiffindays(strtojavadate(currentDate, "MM/dd/yyyy HH:mm"), strtojavadate(lastApprovalDate, "MM/dd/yyyy HH:mm"));
    }
 
    // Get goodForDays
    if(containskey(keyVsEventDict, "GOOD_FOR_DAYS")) {
        goodForDays = get(keyVsEventDict, "GOOD_FOR_DAYS");
    }

    // If the last approval was approved before the goodForDays then current approval is a redundant approval
    if(isnumber(goodForDays)) {
        if(diffInDays > atoi(goodForDays)) {
            reapprovalNeeded = true;
        }
    }
}

// USE CASE 3 - CAPACITY, CREDIT, DA, SE, SOW approvals
// If keyVsEventDict contains time stamp then we should do the below logic
if(containskey(keyVsEventDict, "TIMESTAMP") AND containskey(keyVsCurrentValueDict, "TIMESTAMP")) {
    lastApprovalTS = get(keyVsEventDict, "TIMESTAMP");

    // Get the current timestamp
    if(containskey(keyVsCurrentValueDict, "TIMESTAMP")) {
        currentTS = get(keyVsCurrentValueDict, "TIMESTAMP");
    }
    
    // If the no line is added/reconfigured/deleted since the last approval then the current approval is reduandant
    if(isnumber(currentTS) AND isnumber(lastApprovalTS)) {
        if(atoi(currentTS) > atoi(lastApprovalTS)) {
            reapprovalNeeded = true;
        }
    }
    
    // If currentTS is blank then i.e. lastLineConfigured_quote is blank then we should not skip approval
    // This is to cover inflight quotes
    if(currentTS == "") {
        reapprovalNeeded = true;
    }
}

return reapprovalNeeded;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_checkReapprovalNeeded_392706778]]></java_class_name><child_class_names></child_class_names><date_modified>1366470384000</date_modified><guid><![CDATA[testsavvis_290103814]]></guid><_children></_children></bm_function><bm_lib_func_param><id>392706780</id><bm_lib_func_id>392706779</bm_lib_func_id><param_name><![CDATA[keyVsEventDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1366470384000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_290103817]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706781</id><bm_lib_func_id>392706779</bm_lib_func_id><param_name><![CDATA[keyVsCurrentValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1366470384000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_290103818]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>392706772</id><name><en><![CDATA[Get Pricing]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getPricing]]></variable_name><description><en><![CDATA[VER 66500: Generates the full XML of the pricing integration piece, then sends it to the pricing web service to get back the correct pricing strings. Used in getAllPrices commerce function.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>32</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>392706771</function_id><main_script_text></main_script_text><date_modified>1386650487000</date_modified><guid><![CDATA[testsavvis_279240801]]></guid><_children><bm_function><id>392706771</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Get Pricing (getPricing)
//** Type:        Utility Library Function   
//**
//** Description: Generates the full XML of the pricing integration piece, then sends it to the pricing web   
//**              service to get back the correct pricing strings. Used in getAllPricing commerce function.    
//** 
//** Param:       keyVsQuoteValueDict      - contains quote level information such as quote number, session id, transaction id etc
//**              docNumArray              - list of document numbers that forms part of the key to docNumKeyVsLineValueDict
//**              docNumKeyVsLineValueDict - contains line level information such as part number, aip, a & z address etc
//**                                       - it has a complex key with format docNum:KEY (the valid values for KEY are mentioned below)
//**
//** Return type: dictionary of string dictionaries - contains various dictionaries such as pricing string, options string etc
//**                                                - outer dict key: valid values for key GENERAL_INFO, PRICING_STRING, OPTION_STRING, 
//**                                                                                       VENDOR_STRING, USAGE_STRING, TOTAL_STRING,
//**                                                                                       SPMAX_MRC, SPMAX_MRC_TYPE, SPMAX_NRC, 
//**                                                                                       SPMAX_NRC_TYPE
//**                                                - inner dict key: documentNumber
//**
//** History:     Date     Author       Comment    
//**              01/01/11 Big Machines Initial Implementation by Big Machines 
//**              07/30/12 KNewyeare    VER 63991 - Add additional dictionary for Parent Part Doc Number 
//**              08/27/12 SKharche     VER 64170 - Pass BPid to Pricing Service  
//**              09/05/12 SKharche     VER 64496 - Pass Savvis Company Name to Pricing Service 
//**              01/22/13 STillett     VER 65916 - create new dict parameter to hold general values
//**              03/25/13 SKharche     VER 66500 - Pricing code refactor   
//**              04/24/13 STillett     VER 66818: Add identifying tags to WS
//**              05/09/13 STillett     VER 67036 - Add NODE_NAME to XML
//**              07/02/13 CMertz       BIGMACH-2190 - Optimize Get Prices to price chunk of lines at a time
//**              08/22/13 STillett     BIGMACH-2237 - Look for SP Max tags for MRC/NRC
//**              11/20/13 STillett     BIGMACH-3025 - look for different usage label in table 
//**              12/02/13 SKharche     BIGMACH-3023 - Change URL prefix to support layer 7
//************************************************************************************************************

/*
ALGORITHM - we now can price just NYP or All Lines. We also call pricing in chunks to ensure we don't timeout
    1. If LASTPRICEDSEQ is 0 (or blank) then the pricing webservice is called for the first time
       and all the models that should be priced together are sent in this first call.
    2. If there is any room available in the 1st call (based on MODELS_TO_PRICE_PER_CALL) then more
       models are sent in the same call.
    3. If there are any models left to be priced then lastPricedLineSeqNum_quote is set to the last
       priced line's seq num and autoTriggerAction_quote is set to get_prices so that javascript can
       resubmit this action. JS is kicked if autoTriggerAction_quote is NOT blank and triggers the action
       specified by this attribute.
    4. If repriceAllLines_quote is true then all the items on the quote are priced in chunks.
    5. If repriceAllLines_quote is false then only NYP items on the quote are priced in chunks.
*/

/* LIST of keys for quote info dict
    SYSTEM          - _system_supplier_company_name
    BPID            - bPID_quote
    SAVVISCOMPANY   - savvisCompany_quote
    QUOTENUMBER     - quoteNumber_quote
    TRANSACTIONID   - transactionID_quote
    BANNUMBER       - banNumber_quote
    CONTRACTTERMS   - comma seperated list of term 1,2,3 subscription months
    CURRENCY        - USD or if outputCurrency_quote is NOT empty then it's value
    SESSIONID       - current session id
    PRICEALL        - flag specifying if we price all lines or just NYP/ERR   BIGMACH-2190
    LASTPRICEDSEQ   - last line that has been repriced BIGMACH-2190
*/

/* LIST of keys for line info dict - key is a complex key with format docNum:KEY
    AIP             - AIP id
    OPTION          - tech description
    PACKAGE         - standard part name
    REUSE_LOOP      - value from reuse network loop line level attribute
    A_ADDRESS       - A address
    Z_ADDRESS       - Z address
    REFERENCE_AIP   - network resiliency existing service
    REFERENCE_PART  - network resiliency primary 
    REPLACEMENT     - parent AIP
    RENEWAL         - true or false based on renewalConfig_line of the model
    REGION          - installation region
    PARENT          - sequence number of the first part of the model aka parent part
    MODELNAME       - Model Name of the part BIGMACH-2190
    PRICESRC1       - contractType for term 1 BIGMACH-2190
    PRICESRC2       - contractType for term 1 BIGMACH-2190
    PRICESRC3       - contractType for term 1 BIGMACH-2190
    SEQNUM          - sequence number BIGMACH-2190
*/

/*
    NOTE: delimited strings are returned by the pricing web service, below are the details of those delimited strings
    pricingString - for more infomeation refer attribtue description for pricingString_line
    optionsString - for more infomeation refer attribtue description for optionsString_line
    tierString    - for more infomeation refer attribtue description for tierString_line
    totalString   - for more infomeation refer attribtue description for totalsString_line
    vendorString  - for more infomeation refer attribtue description for vendorString_line
*/

// CMM - this has to be refactored because we can't call util in util
//MODELS_TO_PRICE_PER_CALL = atoi(util.getGlobalValue("MODELS_TO_PRICE_PER_CALL"));

MODELS_TO_PRICE_PER_CALL = "";
allAttrs = bmql("SELECT Value FROM GlobalVars WHERE Keyword = 'MODELS_TO_PRICE_PER_CALL'");
for val in allAttrs {
    MODELS_TO_PRICE_PER_CALL = get(val, "Value");
}

// Since pricing is done in chunk now, we need to make sure models that have dependency should be send 
// to the pricing webservice in one chunk. Below are the models that should be send in one chunk and 
// these are sent in the 1st chunk itself. The below dict is used for search purposes and hence the value is blank.
modelsToPriceTogetherDict = dict("string");
put(modelsToPriceTogetherDict, "Application Transport Service 2.0", "");
put(modelsToPriceTogetherDict, "Financial Application Transport Service 1.0", "");
put(modelsToPriceTogetherDict, "Network Dedicated Connectivity 1.0", "");
put(modelsToPriceTogetherDict, "Custom ATS 2.0", "");
put(modelsToPriceTogetherDict, "TR Network Connect 1.0", "");

inputXML    = "";
allProducts = "";
lineRetStr  = "";
system      = "";
allConfigs  = "";

row = 0;

optionPartArray = string[];

retTable = string[][];

inputHeaders               = dict("string");
generalInfoKeyVsValueDict  = dict("string");    // key: documentNumber, value: general information like error message, fault string etc
docNumVsPricingStringsDict = dict("string");    // key: documentNumber, value: pricing string present in <price> tag in the response xml
docNumVsOptionStringsDict  = dict("string");    // key: documentNumber, value: options string present in <option> tag in the response xml
docNumVsTierStringsDict    = dict("string");    // key: documentNumber, value: usage string present in <usage> tag in the response xml
docNumVsTotalStringsDict   = dict("string");    // key: documentNumber, value: total string present in <total> tag in the response xml
docNumVsVendorStringDict   = dict("string");    // key: documentNumber, value: vendor string present in <vendor> tag in the response xml
docNumVsSPMaxMRCDict       = dict("string");    // key: documentNumber, value: SP Max MRC present in <maxDiscountMRC> tag in the response xml
docNumVsSPMaxMRCTypeDict   = dict("string");    // key: documentNumber, value: SP Max MRC type present in <maxDiscountMRCType> tag in the response xml
docNumVsSPMaxNRCDict       = dict("string");    // key: documentNumber, value: SP Max nRC present in <maxDiscountNRC> tag in the response xml
docNumVsSPMaxNRCTypeDict   = dict("string");    // key: documentNumber, value: SP Max nRC type present in <maxDiscountNRCType> tag in the response xml
docNumVsIntegrationXMLDict = dict("string");    // key: documentNumber, value: line level integration XML that is passed to WS

docNumVsOptionsDict        = dict("string[]");  // key: docNum, value: array of all options on line; BIGMACH-3025


retDict = dict("dict<string>"); // key: {GENERAL_INFO, PRICING_STRING, OPTION_STRING, VENDOR_STRING, USAGE_STRING, TOTAL_STRING, SPMAX_MRC, SPMAX_MRC_TYPE, SPMAX_NRC, SPMAX_NRC_TYPE}, value: corresponding dictionaries created above that stores the web service response

// BIGMACH-2109 - now that we chunk, we need to figure out what really goes on this call
// if this is the first call for a pricing event then we add all the keep togethers
// then we fill any remaining space. We build up a list of parent doc nums as we 
// get to the MODELS_PER_PRICE_CALL

filteredDocNumArray = string[];

lastPricedLineSeqNum =  0;
pricedModelsCount = 0;
repriceAllLines = "false";
haveModelsToPriceTogether = false;
moreModelsToPrice = false;
parentDocNumToPriceDict = dict("string");    // holds the doc numbers that we will send to pricing

contractType1 = "";
contractType2 = "";
contractType3 = ""; 

if(containsKey(keyVsQuoteValueDict, "LASTPRICEDSEQ")) {
    lastPricedLineSeqNum = atoi(get(keyVsQuoteValueDict, "LASTPRICEDSEQ"));
}
if(containsKey(keyVsQuoteValueDict, "REPRICEALL")) {
    repriceAllLines = get(keyVsQuoteValueDict, "REPRICEALL");
}

// BIGMACH-2190 - Get document number of models that needs to be send to pricing webservice
// If lastPricedLineSeqNum is 0 that means this is the first pricing call and we should 
// send the below models in the 1st call itself. The below models have dependency on one another
// (primary/secondary or similar) and should be priced together.
if (lastPricedLineSeqNum == 0) {

    // We need to make sure all the keep together models should be priced together.
    // For eg: if a quote has ATS and it is priced and we add aa secondary ATS later then upon pricing next time
    // we should send both primary and secondary ATS (this is applicable to all keep together models)
    keepTogetherNeedsPricing = false;
    for docNum in docNumArray {
        modelName     = get(docNumKeyVsLineValueDict, docNum + ":MODELNAME");
        contractType1 = get(docNumKeyVsLineValueDict, docNum + ":PRICESRC1");
        contractType2 = get(docNumKeyVsLineValueDict, docNum + ":PRICESRC2");
        contractType3 = get(docNumKeyVsLineValueDict, docNum + ":PRICESRC3");
        
        if(containskey(modelsToPriceTogetherDict, modelName) AND
          (repriceAllLines == "true" OR contractType1 == "NYP" OR contractType2 == "NYP" OR contractType3 == "NYP")) {
            keepTogetherNeedsPricing = true;
            break;
        }
    }
    
    if(keepTogetherNeedsPricing) {
        for docNum in docNumArray {
            modelName     = get(docNumKeyVsLineValueDict, docNum + ":MODELNAME");
            contractType1 = get(docNumKeyVsLineValueDict, docNum + ":PRICESRC1");
            contractType2 = get(docNumKeyVsLineValueDict, docNum + ":PRICESRC2");
            contractType3 = get(docNumKeyVsLineValueDict, docNum + ":PRICESRC3");
            parentDocNum  = get(docNumKeyVsLineValueDict, docNum + ":PARENTDOC");

            // if model is a keep together and we should price it, then add it to the list
            if(containskey(modelsToPriceTogetherDict, modelName)) {
                // BIGMACH-2190 - On the below line parentDocNum was present as a string value "parentDocNum"
                // instead it should be a variable since it holds the actual parent doc number.
                if(NOT(containsKey(parentDocNumToPriceDict, parentDocNum))) {
                    put(parentDocNumToPriceDict, parentDocNum, "");
                    pricedModelsCount = pricedModelsCount + 1;

                    haveModelsToPriceTogether = true;
                }
            }
        }
    }
}

// now we loop through all the regular lines
for docNum in docNumArray {
    modelName     = get(docNumKeyVsLineValueDict, docNum + ":MODELNAME");
    contractType1 = get(docNumKeyVsLineValueDict, docNum + ":PRICESRC1");
    contractType2 = get(docNumKeyVsLineValueDict, docNum + ":PRICESRC2");
    contractType3 = get(docNumKeyVsLineValueDict, docNum + ":PRICESRC3");
    parentDocNum  = get(docNumKeyVsLineValueDict, docNum + ":PARENTDOC");

    // if this is a KeepTogether, they've been handled above
    if (containskey(modelsToPriceTogetherDict, modelName)) {
        continue;
    }

    // BIGMACH-2190 - Get document number of models that needs to be send to pricing webservice.
    // If current sequence number is greater than lastPricedLineSeqNum then we should look at the items,
    // all other items will be priced. We do not send delete models to pricing webservice, 
    // so we should not include those in the chunks.

    seqNum = get(docNumKeyVsLineValueDict, docNum + ":SEQNUM");

    if (atoi(seqNum) > lastPricedLineSeqNum) { 
        // If pricedModelsCount is less than MODELS_TO_PRICE_PER_CALL then there is room to send more 
        // models to pricing.
        
        if(pricedModelsCount < atoi(MODELS_TO_PRICE_PER_CALL) OR
           containskey(parentDocNumToPriceDict, parentDocNum)) {
            
            // If repriceAllLines is true then all lines should be used (in chunks)
            // If repriceAllLines is false then only NYP lines should be repriced (in chunks)

            if (repriceAllLines == "true" OR contractType1 == "NYP" OR contractType2 == "NYP" OR contractType3 == "NYP") {
                
                // if this parent not yet covered, then lets add it and count it
                if (NOT(containskey(parentDocNumToPriceDict, parentDocNum))) {
                    put(parentDocNumToPriceDict, parentDocNum, "");
                    pricedModelsCount = pricedModelsCount + 1;
                }
            
                // Since we have room for any models apart from modelsToPriceTogether the flag
                // haveModelsToPriceTogether should be reset to false so that correct sequence number
                // of the last priced line gets populated in lastPricedLineSeqNum_quote
                haveModelsToPriceTogether = false;
                
                // BIGMACH-2190 - Note last item's seq num
                lastPricedLineSeqNum = atoi(seqNum);
            }
        }
        else {
            moreModelsToPrice = true;
        }
    }
}

// Pricing webservice should be called if we have at least 1 product, else return empty dict
if(pricedModelsCount == 0) {
    return retDict;
}

// now that we have all the models we want to build out
// we loop through the lines adding any parts for the matching parent doc nums
// to the filtered list

for eachdocNum in docNumArray {
    parentDocNum = get(docNumKeyVsLineValueDict, eachdocNum + ":PARENTDOC");
    if (containskey(parentDocNumToPriceDict, parentDocNum)) {
        append(filteredDocNumArray, eachdocNum);
        
        // lets make sure we set the lastPricedLineSeqNum
        // we couldn't do this above because we are only checking
        // models and we would miss the sequence numbers of the last
        // part of the last model above. Here, we walk through each
        // part so we're certain to get the highest sequence number
        // of the parts we send to the pricing service

        /* SEQ NUM IS POPULATED ABOVE - CRAIG please remove this code and the above comments after code review
        seqNum = get(docNumKeyVsLineValueDict, eachdocNum + ":SEQNUM");

        if (atoi(seqNum) > lastPricedLineSeqNum) {    
            lastPricedLineSeqNum = atoi(seqNum);
        }*/
    }
}

// iterate through all the filteredDocNum's (this is just enough based on chunking)
// we build the allProducts for the ws input and set the integrationXML_line that is returned
for each in filteredDocNumArray {
    eachAIP             = "";
    eachOption          = "";    
    eachPackage         = "";
    eachAddressA        = "";
    eachAddressZ        = "";
    eachReuseLoop       = "";
    eachReferencePart   = "";
    eachReferenceAIP    = "";
    eachReplacement     = "";
    eachRenewal         = "";
    eachRegion          = "";
    eachParent          = "";
    productXML          = "";
    
    eachAddrAArray = string[];
    eachAddrZArray = string[];
    
    if(containskey(docNumKeyVsLineValueDict, each + ":AIP")){
        eachAIP = get(docNumKeyVsLineValueDict, each + ":AIP");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":OPTION")){
        eachOption = get(docNumKeyVsLineValueDict, each + ":OPTION");
        //BIGMACH-3025: keep track of the options for each line for later use
        optionArray = string[];
        eachOptionArray = split(eachOption, "^-^");
        for optionType in eachOptionArray {
            optionTypeArray = split(optionType, "^=^");
            append(optionArray, optionTypeArray[0]);
        }
        put(docNumVsOptionsDict, each, optionArray);
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":PACKAGE")){
        eachPackage = get(docNumKeyVsLineValueDict, each + ":PACKAGE");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":REUSE_LOOP")){
        eachReuseLoop = get(docNumKeyVsLineValueDict, each + ":REUSE_LOOP");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":A_ADDRESS")){
        eachAddressA = get(docNumKeyVsLineValueDict, each + ":A_ADDRESS");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":Z_ADDRESS")){
        eachAddressZ = get(docNumKeyVsLineValueDict, each + ":Z_ADDRESS");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":REFERENCE_AIP")){
        eachReferenceAIP = get(docNumKeyVsLineValueDict, each + ":REFERENCE_AIP");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":REFERENCE_PART")){
        eachReferencePart = get(docNumKeyVsLineValueDict, each + ":REFERENCE_PART");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":REPLACEMENT")){
        eachReplacement = get(docNumKeyVsLineValueDict, each + ":REPLACEMENT");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":RENEWAL")){
        eachRenewal = get(docNumKeyVsLineValueDict, each + ":RENEWAL");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":REGION")){
        eachRegion = get(docNumKeyVsLineValueDict, each + ":REGION");
    }
    if(containskey(docNumKeyVsLineValueDict, each + ":PARENT")){
        eachParent = get(docNumKeyVsLineValueDict, each + ":PARENT");
    }
    
    productXML = productXML + "<productConfig>"
                            + "<extId><![CDATA[" + each + "&_cd;</extId>";
    
    // VER 63991 - Add parentExtId tag
    if(eachParent <> ""){
        productXML = productXML + "<parentExtId><![CDATA[" + eachParent + "&_cd;</parentExtId>";
    }
    if(eachAIP <> ""){
        productXML = productXML + "<aipId><![CDATA[" + eachAIP + "&_cd;</aipId>";
    }
    
    productXML = productXML + "<attemptReuseNetworkLoop><![CDATA[" + eachReuseLoop + "&_cd;</attemptReuseNetworkLoop>"
                            + "<optionEncodedString><![CDATA[" + eachOption + "&_cd;</optionEncodedString>"
                            + "<salesPackageName><![CDATA[" + eachPackage + "&_cd;</salesPackageName>";
                            
    if(eachAddressA <> ""){
        productXML = productXML + "<siteAAddress><![CDATA[" + eachAddressA + "&_cd;</siteAAddress>";
    }
    if(eachAddressZ <> ""){
        productXML = productXML + "<siteZAddress><![CDATA[" + eachAddressZ + "&_cd;</siteZAddress>";
    }
    if(eachReferenceAIP <> ""){
        productXML = productXML + "<primaryReference><aipId><![CDATA[" + eachReferenceAIP + "&_cd;</aipId></primaryReference>";
    }
    elif(eachReferencePart <> ""){
        productXML = productXML + "<primaryReference><extId><![CDATA[" + eachReferencePart + "&_cd;</extId></primaryReference>";
    }
    if(eachReplacement <> "" AND eachReplacement <> "0"){
        productXML = productXML + "<replacesAipId><![CDATA[" + eachReplacement + "&_cd;</replacesAipId>";
    }
    productXML = productXML + "<renewal><![CDATA[" + eachRenewal + "&_cd;</renewal>";
    
    // VER 63532 - Add additional flag for installation region
    if(eachRegion <> ""){
        productXML = productXML + "<installationRegion><![CDATA[" + eachRegion + "&_cd;</installationRegion>";
    }
    productXML = productXML + "</productConfig>";
    allProducts = allProducts + productXML;
    put(docNumVsIntegrationXMLDict, each, replace(replace(productXML, "<![CDATA[", ""), "&_cd;", ""));
    lineRetStr = lineRetStr + each + "~integrationXML_line~" + replace(replace(productXML, "<![CDATA[", ""), "&_cd;", "") + "|";
}

//-------------------------------
// lets prepare the inputXML
//-------------------------------
if(containsKey(keyVsQuoteValueDict, "SYSTEM")) {
    system = get(keyVsQuoteValueDict, "SYSTEM");
}

// Grab the pricing ws input template
inputXML = urldatabypost("https://" + system + ".bigmachines.com/bmfsweb/" + system + "/image/WebServices/PricingRequest2.xml", "", "");

// VER 64170 - Pass BPid to Pricing Service
if(containsKey(keyVsQuoteValueDict, "BPID")){
    inputXML = replace(inputXML, "%BPID%", get(keyVsQuoteValueDict, "BPID"));
}

// VER 64496 - Pass Savvis Company Name to Pricing Service
if(containsKey(keyVsQuoteValueDict, "SAVVISCOMPANY")){
    inputXML = replace(inputXML, "%SAVVISCOMPANY%", get(keyVsQuoteValueDict, "SAVVISCOMPANY"));
}

//SHANNON VER 65916 - Pass Quote Number/Transaction ID to Pricing Service
if(containsKey(keyVsQuoteValueDict, "QUOTENUMBER")){
    inputXML = replace(inputXML, "%QUOTENUMBER%", get(keyVsQuoteValueDict, "QUOTENUMBER"));
    inputXML = replace(inputXML, "%QN%", get(keyVsQuoteValueDict, "QUOTENUMBER"));
}
if(containsKey(keyVsQuoteValueDict, "TRANSACTIONID")){
    inputXML = replace(inputXML, "%TRANSACTION%", get(keyVsQuoteValueDict, "TRANSACTIONID"));
    inputXML = replace(inputXML, "%TRAN%", get(keyVsQuoteValueDict, "TRANSACTIONID"));
}
//VER 66818: Add Username to xml call
if(containsKey(keyVsQuoteValueDict, "USERNAME")){
    inputXML = replace(inputXML, "%USERNAME%", get(keyVsQuoteValueDict, "USERNAME"));
}
if(containsKey(keyVsQuoteValueDict, "BANNUMBER")){
    inputXML = replace(inputXML, "%BANNUMBER%", get(keyVsQuoteValueDict, "BANNUMBER"));
}
if(containsKey(keyVsQuoteValueDict, "CONTRACTTERMS")){
    inputXML = replace(inputXML, "%CONTRACTTERMS%", get(keyVsQuoteValueDict, "CONTRACTTERMS"));
}
if(containsKey(keyVsQuoteValueDict, "CURRENCY")){
    inputXML = replace(inputXML, "%CURRENCY%", get(keyVsQuoteValueDict, "CURRENCY"));
}
// VER 67036 - Add NODE_NAME to XML
if(containsKey(keyVsQuoteValueDict, "NODENAME")){
    inputXML = replace(inputXML, "%NODE_NAME%", get(keyVsQuoteValueDict, "NODENAME"));
}

inputXML = replace(inputXML, "%PRODUCTXML%", allProducts);

if(containsKey(keyVsQuoteValueDict, "SESSIONID")){
    inputXML = replace(inputXML, "%SESSION_ID%", get(keyVsQuoteValueDict, "SESSIONID"));
}

webServiceLoc = "";
// BIGMACH-3023 - Update URL prefix to support Layer 7. If this is not present then use the regular prefix. This 
// is to ensure backward compability and to provide flexibility to turn ON/OFF layer 7
allAttrs = bmql("SELECT Value FROM GlobalVars WHERE Keyword='SVVS_URL_PREFIX_BMIWS'"); 
for record in allAttrs {
    webServiceLoc = get(record, "Value");
}

if(webServiceLoc == "") {
    allAttrs = bmql("SELECT Value FROM GlobalVars WHERE Keyword = 'SVVS_URL_PREFIX'");
    for val in allAttrs {
        webServiceLoc = get(val, "Value");
    }
}
inputURL = webServiceLoc + "BMWebServices/pricing2";

put(inputHeaders, "Content-Type", "text/xml");

outputXML = trim(urldatabypost(inputURL, inputXML, "NULL", inputHeaders));

outputXML = outputXML + "<integrationXML>" + lineRetStr + "</integrationXML>";

if(startswith(outputXML, "NULL")){
    put(generalInfoKeyVsValueDict, "INTEGRATION_ERROR", "There was an error with the Pricing Integration Web Service.");
}
else {
    faultString     = "";
    integrationXML  = "";
    
    listOfTags = string[] {"faultstring", "integrationXML", "productConfigs"}; // list of outer tags in the response xml, stored in array so that we can loop

    for searchTag in listOfTags {
        dataInTag         = "";    
        blankTag          = "<" + searchTag + "/>";
        startTag          = "<" + searchTag + ">";
        startTagWithExtra = "<" + searchTag + " ";
        endTag            = "</" + searchTag + ">";
        
        startLen = len(startTag);
        endLen   = len(endTag);

        if(find(outputXML, blankTag) <> -1){
            dataInTag = "";
        }
        elif((find(outputXML, startTag) <> -1) AND (find(outputXML, endTag) <> -1)){
            dataInTag = substring(outputXML, find(outputXML, startTag) + startLen, find(outputXML, endTag));
        }
        elif((find(outputXML, startTagWithExtra) <> -1) AND (find(outputXML, endTag) <> -1)){
            temp = substring(outputXML, find(outputXML, startTagWithExtra) +  startLen, find(outputXML, endTag)); 
            pos = find(temp,">");
            dataInTag = substring(temp, pos + 1, len(temp));
        }
        else{
            dataInTag = "NULL";
        }
        
        if(searchTag == "faultstring" AND find(outputXML, "<faultstring>") <> -1) {
            put(generalInfoKeyVsValueDict, "FAULT_STRING", "The Pricing Service returned the following error: " + dataInTag);
            break;
         }
        if(searchTag == "integrationXML") {
            put(generalInfoKeyVsValueDict, "INTEGRATION_XML", dataInTag);
        }
        if(searchTag == "productConfigs") {
            allConfigs = dataInTag;
        }      
    }
}

allConfigs  = replace(allConfigs, "</productConfig><productConfig>","</productConfig>!@!<productConfig>");
configArray = split(allConfigs, "!@!");
            
// lets process the line data that is returned from the web service
for config in configArray {
    configDocNum = "";

    listOfInnerTags = string[] {"extId", "price", "option", "vendor", "usage", "total", "maxDiscountMRC", "maxDiscountMRCType", "maxDiscountNRC", "maxDiscountNRCType"}; // list of inner tags in the response xml, store in array so that we can loop

    for searchTag in listOfInnerTags {
        outputXML         = config;
        
        dataInTag         = "";    
        blankTag          = "<" + searchTag + "/>";
        startTag          = "<" + searchTag + ">";
        startTagWithExtra = "<" + searchTag + " ";
        endTag            = "</" + searchTag + ">";
        
        startLen = len(startTag);
        endLen   = len(endTag);

        if(find(outputXML, blankTag) <> -1){
            dataInTag = "";
        }
        elif((find(outputXML, startTag) <> -1) AND (find(outputXML, endTag) <> -1)){
            dataInTag = substring(outputXML, find(outputXML, startTag) + startLen, find(outputXML, endTag));
        }
        elif((find(outputXML, startTagWithExtra) <> -1) AND (find(outputXML, endTag) <> -1)){
            temp = substring(outputXML, find(outputXML, startTagWithExtra) +  startLen, find(outputXML, endTag)); 
            pos = find(temp,">");
            dataInTag = substring(temp, pos + 1, len(temp));
        }
        else{
            dataInTag = "NULL";
        }
        
        if(searchTag == "extId") {
            configDocNum = dataInTag;
        }
        elif(searchTag == "price" AND upper(dataInTag) <> "NULL") {
            put(docNumVsPricingStringsDict, configDocNum, dataInTag);
        }
        elif(searchTag == "option" AND upper(dataInTag) <> "NULL") {
            put(docNumVsOptionStringsDict, configDocNum, dataInTag);
        }
        elif(searchTag == "vendor" AND upper(dataInTag) <> "NULL") {
            put(docNumVsVendorStringDict, configDocNum, dataInTag);
        }
        elif(searchTag == "usage" AND upper(dataInTag) <> "NULL") {
             //BIGMACH-3025: look in table to see if there is a special usage label
             // to use for this option/package instead of the default: "overage"
             // if there is a special label, we find and replace the instances of "overage"
             // in the string passed back from the pricing service.
             optionArr = string[];
             if(containskey(docNumVsOptionsDict, configDocNum)) {
                optionArr = get(docNumVsOptionsDict, configDocNum);
             }
             packageName = "";
             if(containsKey(docNumKeyVsLineValueDict, configDocNum + ":PACKAGE")) {
                packageName = get(docNumKeyVsLineValueDict, configDocNum + ":PACKAGE");
             }
             usageLabels = bmql("SELECT UsageLabel FROM SvcPkgOptionDef WHERE SvcPkgName = $packageName AND OptionDefName IN $optionArr");
             usageLabel = "";
             for each in usageLabels {
                usageLabel = get(each, "UsageLabel");
             }
             if(usageLabel <> "" AND NOT(isnull(usageLabel))) {
                dataInTag = replace(dataInTag, "Overage", usageLabel);
             }
             put(docNumVsTierStringsDict, configDocNum, dataInTag);
        }
        elif(searchTag == "total" AND upper(dataInTag) <> "NULL") {
            put(docNumVsTotalStringsDict, configDocNum, dataInTag);
        }
        //BIGMACH-2237: look for SP MAX tags 
        elif(searchTag == "maxDiscountMRC" AND upper(dataInTag) <> "NULL") {
            put(docNumVsSPMaxMRCDict, configDocNum, dataInTag);
        }
        elif(searchTag == "maxDiscountMRCType" AND upper(dataInTag) <> "NULL") {
            put(docNumVsSPMaxMRCTypeDict, configDocNum, dataInTag);
        }
        elif(searchTag == "maxDiscountNRC" AND upper(dataInTag) <> "NULL") {
            put(docNumVsSPMaxNRCDict, configDocNum, dataInTag);
        }
        elif(searchTag == "maxDiscountNRCType" AND upper(dataInTag) <> "NULL") {
            put(docNumVsSPMaxNRCTypeDict, configDocNum, dataInTag);
        }
    }
}
xmlRetString = "";
for each in filteredDocNumArray {
    tempXML = get(docNumVsIntegrationXMLDict, each);
    if(containskey(docNumVsSPMaxMRCTypeDict, each)) {
        tempXML = tempXML + "\n  maxDiscountMRCType=" + get(docNumVsSPMaxMRCTypeDict, each);
    }
    xmlRetString = xmlRetString + each + "~integrationXML_line~" + tempXML + "|";
}
if(xmlRetString <> "") {
    put(generalInfoKeyVsValueDict, "INTEGRATION_XML", xmlRetString);
}


// BIGMACH-2190 - Capture document number of the last priced line
// If the last model on the quote is priced then we don't have anything else to price.
if(moreModelsToPrice) { 
    // If haveModelsToPriceTogether then the last seq num should be set to 1 so that on subsequent
    // calls to getAllPricing() the lines will start scanning from the top and will not skip any lines
    // incorrectly.    
    if(haveModelsToPriceTogether) {
        put(generalInfoKeyVsValueDict, "LAST_PRICED_LINE_SEQ_NUM", "1");
    }
    else {
        put(generalInfoKeyVsValueDict, "LAST_PRICED_LINE_SEQ_NUM", string(lastPricedLineSeqNum));
    }
    
    put(generalInfoKeyVsValueDict, "MORE_ROWS_TO_PRICE", "1");
}

put(retDict, "GENERAL_INFO", generalInfoKeyVsValueDict);
put(retDict, "PRICING_STRING", docNumVsPricingStringsDict);
put(retDict, "OPTION_STRING", docNumVsOptionStringsDict);
put(retDict, "VENDOR_STRING", docNumVsVendorStringDict);
put(retDict, "USAGE_STRING", docNumVsTierStringsDict);
put(retDict, "TOTAL_STRING", docNumVsTotalStringsDict);
//BIGMACH-2237: pass back SP MAX info dicts
put(retDict, "SPMAX_MRC", docNumVsSPMaxMRCDict);
put(retDict, "SPMAX_MRC_TYPE", docNumVsSPMaxMRCTypeDict);
put(retDict, "SPMAX_NRC", docNumVsSPMaxNRCDict);
put(retDict, "SPMAX_NRC_TYPE", docNumVsSPMaxNRCTypeDict);

return retDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getPricing_392706771]]></java_class_name><child_class_names></child_class_names><date_modified>1386650487000</date_modified><guid><![CDATA[testsavvis_279240800]]></guid><_children></_children></bm_function><bm_lib_func_param><id>392706773</id><bm_lib_func_id>392706772</bm_lib_func_id><param_name><![CDATA[keyVsQuoteValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1386650487000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_279240803]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706774</id><bm_lib_func_id>392706772</bm_lib_func_id><param_name><![CDATA[docNumArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1386650487000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_279240804]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706775</id><bm_lib_func_id>392706772</bm_lib_func_id><param_name><![CDATA[docNumKeyVsLineValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1386650487000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_279240805]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>13625065</id><name><en><![CDATA[Is Addon Selected]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[isAddonSelected]]></variable_name><description><en><![CDATA[Checks if the addon is selected]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>13625064</function_id><main_script_text></main_script_text><date_modified>1358564315000</date_modified><guid><![CDATA[LEGACY_13625065]]></guid><_children><bm_function><id>13625064</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Is Addon Selected (isAddonSelected)                                                         **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Checks if the addon is selected                                                             **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************


//If add-on is actually selected or if AIP is present and the installBaseQuantity > 0 then add-on is selected
selectedAddOns  = split(addonProducts, "~");
isAddOnSelected = findinarray(selectedAddOns, addon);
if(isAddOnSelected <> -1 OR (AIP <> "" AND installBaseQuantity > 0)) { return true; }
return false;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_isAddonSelected_13625064]]></java_class_name><child_class_names></child_class_names><date_modified>1358564315000</date_modified><guid><![CDATA[LEGACY_13625064]]></guid><_children></_children></bm_function><bm_lib_func_param><id>13625067</id><bm_lib_func_id>13625065</bm_lib_func_id><param_name><![CDATA[addonProducts]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564315000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_13625067]]></guid></bm_lib_func_param><bm_lib_func_param><id>13625068</id><bm_lib_func_id>13625065</bm_lib_func_id><param_name><![CDATA[addon]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564315000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_13625068]]></guid></bm_lib_func_param><bm_lib_func_param><id>13625069</id><bm_lib_func_id>13625065</bm_lib_func_id><param_name><![CDATA[AIP]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564315000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_13625069]]></guid></bm_lib_func_param><bm_lib_func_param><id>13625070</id><bm_lib_func_id>13625065</bm_lib_func_id><param_name><![CDATA[installBaseQuantity]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1358564315000</date_modified><order_no>4</order_no><guid><![CDATA[LEGACY_13625070]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>14631925</id><name><en><![CDATA[Get Addon Limited By DataCenter]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getAddonLimitedByDataCenter]]></variable_name><description><en><![CDATA[Returns a list of valid add-ons based on the data center]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>14631924</function_id><main_script_text></main_script_text><date_modified>1358564311000</date_modified><guid><![CDATA[LEGACY_14631925]]></guid><_children><bm_function><id>14631924</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Addon Limited By DataCenter (getAddonLimitedByDataCenter)                               
//** Type:        Utility Library Function                                                                    
//**                                                                                                          
//** Description: Returns a list of valid add-ons based on the data center                                    
//**                                                                                                          
//** Parameters:  addons     - dilimited list of addon names that are valid for the current product           
//**              delimiter  - **                                                                             
//**              dataCenter - data center selected for the parent product                                    
//**                                                                                                          
//** History:     Date     Author       Comment                                                               
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                
//**              09/28/12 SKharche     VER 64794 - Added comments                                            
//**              11/02/12 SKharche     VER 64474 - Constrain Addons by Data Center 
//**************************************************************************************************************

//new list of addons to return
newListOfAddons = string[];

//addons is a input with a dilimited list of addon names
listOfAddons = split(addons, "**");

//dictionary: Key: addon name, Value: data center
addonVsDataCenterDict = dict("string");

//get the list of service packages for the selected data center
rows = bmql("SELECT SvcPkgName FROM SvcPkgLocAvailable WHERE DataCenter = $dataCenter");
for row in rows {
    addon = get(row, "SvcPkgName"); 
    
    //if the addon is present in the dictionary then get the list of the data centers associated with it and update the list by appending the current data center
    if( containskey(addonVsDataCenterDict, addon) ) {
        dataCenterVal = "";
        dataCenterVal = get(addonVsDataCenterDict, addon);
        dataCenterVal = dataCenterVal + "**" + dataCenter;
        put(addonVsDataCenterDict, addon, dataCenterVal);
    }
    elif( find(addons, addon) > -1 ) {
        put(addonVsDataCenterDict, addon, dataCenter);
    }
}

for addon in listOfAddons {
    avlDataCenter = get(addonVsDataCenterDict, addon);
    
    //if addon is found in the dictionary and if it has a data center matching to the input parameter data center then add it to the return list
    if(NOT isnull(avlDataCenter)) {
        if( find(avlDataCenter, dataCenter) == -1 ) {
            continue;
        }
        else {
            append(newListOfAddons, addon);
        }
    }
    // VER 64474 - Constrain Addons by Data Center
    // Don't add the addon to the new list if it is not available - blanks are allowed to make sure we do
    // do not get internal constraint errors
    elif(addon == "") {
        append(newListOfAddons, addon);
    }
    
}

return join(newListOfAddons, "|^|");]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getAddonLimitedByDataCenter_14631924]]></java_class_name><child_class_names></child_class_names><date_modified>1358564311000</date_modified><guid><![CDATA[LEGACY_14631924]]></guid><_children></_children></bm_function><bm_lib_func_param><id>14631927</id><bm_lib_func_id>14631925</bm_lib_func_id><param_name><![CDATA[addons]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564311000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_14631927]]></guid></bm_lib_func_param><bm_lib_func_param><id>14631928</id><bm_lib_func_id>14631925</bm_lib_func_id><param_name><![CDATA[dataCenter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1358564311000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_14631928]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>392706765</id><name><en><![CDATA[Concat String Dict]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[concatStringDict]]></variable_name><description><en><![CDATA[Appends data from sourceDict to targetDict]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>15</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>392706764</function_id><main_script_text></main_script_text><date_modified>1366470384000</date_modified><guid><![CDATA[testsavvis_279240817]]></guid><_children><bm_function><id>392706764</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Concat String Dictionaries (concatStringDict)
//** Type:        Utility Library Function   
//**
//** Description: Appends data from sourceDict to targetDict
//** 
//** Param:       keysArray  - list of keys that forms key to sourceDict
//**              sourceDict - source dict, the data from this dictionary will be added to the target dictionary
//**              targetDict - target dict, the data from source dictionary will be added to this dictionary
//**
//** Return type: string dictionary with data added from sourceDict to targetDict
//**
//** History:     Date     Author       Comment    
//**              03/20/13 SKharche     VER 66500 - Pricing code refactor  
//************************************************************************************************************

for key in keysArray {
    if(containskey(sourceDict, key)) {
        put(targetDict, key, get(sourceDict, key));
    }
}

return targetDict;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_concatStringDict_392706764]]></java_class_name><child_class_names></child_class_names><date_modified>1366470384000</date_modified><guid><![CDATA[testsavvis_279240816]]></guid><_children></_children></bm_function><bm_lib_func_param><id>392706766</id><bm_lib_func_id>392706765</bm_lib_func_id><param_name><![CDATA[keysArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1366470384000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_279240819]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706767</id><bm_lib_func_id>392706765</bm_lib_func_id><param_name><![CDATA[sourceDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1366470384000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_279240820]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706768</id><bm_lib_func_id>392706765</bm_lib_func_id><param_name><![CDATA[targetDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1366470384000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_279240821]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>25812154</id><name><en><![CDATA[Get SOW Pricing Total Per Item For Float Qty]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getSOWPricingTotalPerItemForFloatQty]]></variable_name><description><en><![CDATA[Returns total for each item present in an array calculated as quantity * unit rate]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>9</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>25812153</function_id><main_script_text></main_script_text><date_modified>1358564314000</date_modified><guid><![CDATA[LEGACY_25812154]]></guid><_children><bm_function><id>25812153</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get SOW Pricing Total Per Item For Float Qty (getSOWPricingTotalPerItemForFloatQty)         **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: Returns total for each item present in an array calculated as quantity * unit rate          **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**************************************************************************************************************

totals = float[];
indexes = range(arrayQuantity);

//Loops through all the array items and calculates the total for each item
for index in indexes {
	append(totals, quantity[index] * unitRate[index]);
}
return totals;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getSOWPricingTotalPerItemForFloatQty_25812153]]></java_class_name><child_class_names></child_class_names><date_modified>1358564314000</date_modified><guid><![CDATA[LEGACY_25812153]]></guid><_children></_children></bm_function><bm_lib_func_param><id>25812156</id><bm_lib_func_id>25812154</bm_lib_func_id><param_name><![CDATA[arrayQuantity]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1358564314000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_25812156]]></guid></bm_lib_func_param><bm_lib_func_param><id>25812157</id><bm_lib_func_id>25812154</bm_lib_func_id><param_name><![CDATA[quantity]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>8</datatype><date_modified>1358564314000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_25812157]]></guid></bm_lib_func_param><bm_lib_func_param><id>25812158</id><bm_lib_func_id>25812154</bm_lib_func_id><param_name><![CDATA[unitRate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>8</datatype><date_modified>1358564314000</date_modified><order_no>3</order_no><guid><![CDATA[LEGACY_25812158]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>729439744</id><name><en><![CDATA[No Special Characters]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[noSpecialCharacters]]></variable_name><description><en><![CDATA[This util will take the value in your attribute you pass it, and output true if all characters in the string attr is either a alpha, numeric, or a space. It will pass a false if any special characters. It was written for DE228.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>4</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>729439743</function_id><main_script_text></main_script_text><date_modified>1388675217000</date_modified><guid><![CDATA[int1centurylink_729439744]]></guid><_children><bm_function><id>729439743</id><ref_type>16</ref_type><script_text><![CDATA[//*****************************************************************************************************
//** Function:    No special characters (ctlnospecialcharacters)                                              
//** Type:        Util                                                                 
//**                                                                                                 
//** Description: It will go through your attribute to verify that only Alpha, Numeric or spaces are entered 
//**                 
//** Parameters:  input: The string you want checked
//**                                                                                            
//** History:     Date     Author     Comment                                                        
//**              12/6/13 BBarnhart   This was written for DE228
//*****************************************************************************************************
retVal = false;
charArr = split(input,"");
remove (charArr, 0);
   
for char in charArr{
          if((char >= "a" AND char <= "Z") OR isnumber(char) OR  char == " ") {
			retVal = true;
	}
	  else{
	    retVal = false;
		break;
     }
}     
return retVal;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_noSpecialCharacters_729439743]]></java_class_name><child_class_names></child_class_names><date_modified>1388675217000</date_modified><guid><![CDATA[int1centurylink_729439743]]></guid><_children></_children></bm_function><bm_lib_func_param><id>729439746</id><bm_lib_func_id>729439744</bm_lib_func_id><param_name><![CDATA[input]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1388675217000</date_modified><order_no>1</order_no><guid><![CDATA[int1centurylink_729439746]]></guid></bm_lib_func_param><bm_lib_func_param><id>729439747</id><bm_lib_func_id>729439744</bm_lib_func_id><param_name><![CDATA[extraInfoDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1388675217000</date_modified><order_no>2</order_no><guid><![CDATA[int1centurylink_729439747]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>485337018</id><name><en><![CDATA[CTL Get Part Sequence Number]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[ctlGetPartSequenceNumber]]></variable_name><description><en><![CDATA[US994: Move Part Sequencing to Service Package Master.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>485337017</function_id><main_script_text></main_script_text><date_modified>1371905636000</date_modified><guid><![CDATA[sbcenturylink_364399526]]></guid><_children><bm_function><id>485337017</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    CTL Get Part Sequence Number (ctlGetPartSequenceNumber)
//** Type:        Utility Library Function   
//**
//** Description: Generates value for hierarchy level as described in the getRecommendedItemsReturnString2 util.
//**              Suffix determined via BMQL on the ctlSvcPkgMaster table.    
//** 
//** Param:       
//**          svcPkgName - Name of service package (BMI part #)              
//**          modelVariableName - Optional param: BMI config model variable name. If model name not found, will look for any entries where this is blank.
//**
//** Return type: String - suffix porition of hierarchyLevel string.
//**                       Format of .XXX.
//**
//** History:     Date     Author       Comment   
//**              06/04/13 SKharche     BIGMACH-2002 - CTL code reconciliation 
//**              05/28/13 RConaghan    Initial creation
//************************************************************************************************************


retVal = "";
recSet = recordSet();

//Lookup hierarchyLevel by model.
if(modelVariableName <> ""){
    recSet = bmql("SELECT hierarchyLevel FROM ctlSvcPkgMaster WHERE SvcPkgName = $svcPkgName AND ModelVariableName = $modelVariableName");
    for record in recSet{
        retVal = get(record, "hierarchyLevel");
    }
}
//If no sequence previously found for model or that param is blank, then do lookup w/o model variable name
if(retVal == ""){ 
    recSet = bmql("SELECT hierarchyLevel FROM ctlSvcPkgMaster WHERE SvcPkgName = $svcPkgName AND ModelVariableName IS NULL");
    for record in recSet{
        retVal = get(record, "hierarchyLevel");
    }
}

//If still no hierarchyLevel found, default to ".999";
if(retVal == ""){
    retVal = "999";
}

//Do formatting logic on string just in case table was input wrong (ie a value was set as 1 instead of 001)
if(len(retVal) < 3 AND isnumber(retVal)){
    if(atoi(retVal) < 10){
        retVal = "00"+retVal;
    }
    elif(atoi(retVal) < 100){
        retVal = "0"+retVal;
    }
}


return "." + retVal;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_ctlGetPartSequenceNumber_485337017]]></java_class_name><child_class_names></child_class_names><date_modified>1371905636000</date_modified><guid><![CDATA[sbcenturylink_364399525]]></guid><_children></_children></bm_function><bm_lib_func_param><id>485337019</id><bm_lib_func_id>485337018</bm_lib_func_id><param_name><![CDATA[svcPkgName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905636000</date_modified><order_no>1</order_no><guid><![CDATA[sbcenturylink_364399528]]></guid></bm_lib_func_param><bm_lib_func_param><id>485337020</id><bm_lib_func_id>485337018</bm_lib_func_id><param_name><![CDATA[modelVariableName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905636000</date_modified><order_no>2</order_no><guid><![CDATA[sbcenturylink_364399529]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>729473959</id><name><en><![CDATA[CTL Get User Hierarchy]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[ctlGetUserHierarchy]]></variable_name><description><en><![CDATA[US 2327 - This Util calls SFA web service and returns an XML response consisting User Hierarchy in a string.]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>729473958</function_id><main_script_text></main_script_text><date_modified>1389392372000</date_modified><guid><![CDATA[sbcenturylink_749356916]]></guid><_children><bm_function><id>729473958</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Get User Hierarchy (getUserHierarchyDetails)
//** Type:        Util BML Library Function 
//**
//** Description: Trigger SFDC hosted User Hierarchy web service
//**
//** Return Type: String (returns string of hierarchy data) 
//** 
//** History:     Date     Author   Comment 
//**            01/07/14  RMendoza  US-2327 - Initial Implementation   
//************************************************************************************************************

ret                 = "";
inputXML            = "";
outputXML           = "";
allResponse         = "";
preValidationError  = "";
webServiceURL       = "";
contractName        = "";
inputHeaders        = dict("string");

inputXML = "<?xml version=\"1.0\" encoding=\"utf-8\" ?>"
+ "<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"><soap:Header>"
+ "<ns1:SessionHeader xmlns:ns1=\"_http://soap.sforce.com/schemas/class/WS_UserHierarchy_Services\"><ns1:sessionId>" + _user_partner_session_Id + "</ns1:sessionId></ns1:SessionHeader></soap:Header>"
+ "<soap:Body><GetUserHierarchyDetails xmlns=\"http://soap.sforce.com/schemas/class/WS_UserHierarchy_Services\"><Request><BigMachinesUserName>"
+ _user_login							
+ "</BigMachinesUserName></Request></GetUserHierarchyDetails></soap:Body></soap:Envelope>";
globalVarsResult = bmql("SELECT Keyword, Value FROM ctlGlobalVars");
for val in globalVarsResult {
	if(get(val, "Keyword") == "USERHIERARCHY_ENDPOINT_URL"){
		webServiceURL = get(val, "Value");
	} 
}
put(inputHeaders, "Content-Type", "text/xml");
put(inputHeaders,"SOAPAction","Action");    
put(inputHeaders,"Content-Length",string(len(inputXML)));
print inputXML;
outputXML = trim(urldatabypost(webServiceURL, inputXML, "NULL", inputHeaders));                     

return outputXML;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_ctlGetUserHierarchy_729473958]]></java_class_name><child_class_names></child_class_names><date_modified>1389392372000</date_modified><guid><![CDATA[sbcenturylink_749356915]]></guid><_children></_children></bm_function><bm_lib_func_param><id>729473960</id><bm_lib_func_id>729473959</bm_lib_func_id><param_name><![CDATA[_user_partner_session_Id]]></param_name><ref_id>44</ref_id><param_location>1</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1389392372000</date_modified><order_no>1</order_no><guid><![CDATA[sbcenturylink_749356918]]></guid></bm_lib_func_param><bm_lib_func_param><id>729473961</id><bm_lib_func_id>729473959</bm_lib_func_id><param_name><![CDATA[_user_login]]></param_name><ref_id>3</ref_id><param_location>1</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1389392372000</date_modified><order_no>2</order_no><guid><![CDATA[sbcenturylink_749356919]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>392706757</id><name><en><![CDATA[Add Event 2]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[addEvent2]]></variable_name><description><en><![CDATA[VER 66620 - Encodes events into a hash map which is then stored as a string]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>392706756</function_id><main_script_text><![CDATA[eventString = " SE___TIMESTAMP=538784!^!";
eventKey = "DA";
extraInfoNameArray = string[] ;
extraInfoValueArray = string[] ;

return util.addEvent2(eventString, eventKey, extraInfoNameArray, extraInfoValueArray );]]></main_script_text><date_modified>1371905636000</date_modified><guid><![CDATA[testsavvis_298653023]]></guid><_children><bm_function><id>392706756</id><ref_type>16</ref_type><script_text><![CDATA[//************************************************************************************************************
//** Function:    Add Event 2(addEvent2)
//** Type:        Utility Library Function   
//**
//** Description: Encodes events into a hash map which is then stored as a string
//** 
//** Param:       eventString         - String containing the data that becomes value in the hash map
//**              eventKey            - String containing key that becomes key in the hash map
//**                                    valid keys: CREDIT, CAPACITY, DA, SE, SOW
//**              extraInfoNameArray  - extra information's keywords/names that needs to be added to the hash map
//**              extraInfoValueArray - extra information's values that needs to be added to the hash map
//**
//** Return type: String - Delimited string of name-value pairs
//**              String Format is: name1=value1,value11!^!name2=value2!^!
//**
//** History:     Date     Author       Comment 
//**              04/10/13 Skharche    VER 66620 - Creates a hash map of all the events that are passed into it
//**              05/24/13 SKharche    BIGMACH-2031 - If the eventNameValuePair is NOT empty then we should add it to the event
//************************************************************************************************************

/*
LIST of MAJOR keys
    CREDIT
    CAPACITY
    DA
    SE
    SOW

LIST of MINOR keys
    TIMESTAMP
    MRC
    GOOD_FOR_DAYS
    LAST_APPROVAL_DATE
    
The ACTUAL keys are the combination of MAJOR and MINOR keys
    eg: CREDIT___TIMESTAMP, DA___TIMESTAMP etc
*/

retVal       = "";
nameValDelim = "=";
pairDelim    = "!^!";

// The internal key representation is the pretty key + 3 underscore bars
internalEventKey = eventKey + "___";

// Lets strip out the old data for this event
eventNameValuePairs = split(eventString, pairDelim);
for eventNameValuePair in eventNameValuePairs {
    // BIGMACH-2031 - If the eventNameValuePair is NOT empty then we should add it to the event
    // Before this condition it was adding the empty pair followed by a delimiter
    if(eventNameValuePair <> "" AND NOT startswith(eventNameValuePair, internalEventKey)) {
        retVal = retVal + eventNameValuePair + pairDelim;
    }
}

// Now we have gotten rid of all the old data for the event
// Lets add the new data to the return string

// Get the Current Time in Minutes - Subtract off the base value to avoid blowing the atoi integer limit
// IMPORTANT NOTE !!! - This calculation MUST be kept in synch with util.getCurrentMinutes() !!!
currentTime = string(getcurrenttimeinmillis()/60000 - 22284000);

retVal = retVal + internalEventKey + "TIMESTAMP" + nameValDelim + currentTime + pairDelim;

// If extraInfoNames are present then append those to the values
// NOTE: The below code is copied from the util encodeNameValuePair.
//       Once we get the functionality of util calling util then the below code should be replaced by util call
index = 0;
for extraInfoName in extraInfoNameArray {
    if(NOT isnull(extraInfoValueArray[index]) AND extraInfoValueArray[index] <> ""){
        retVal = retVal + internalEventKey + extraInfoName + nameValDelim + extraInfoValueArray[index] + pairDelim;
    }
    index = index + 1;
}

return retVal;]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_addEvent2_392706756]]></java_class_name><child_class_names></child_class_names><date_modified>1371905636000</date_modified><guid><![CDATA[testsavvis_298653022]]></guid><_children></_children></bm_function><bm_lib_func_param><id>392706758</id><bm_lib_func_id>392706757</bm_lib_func_id><param_name><![CDATA[eventString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905636000</date_modified><order_no>1</order_no><guid><![CDATA[testsavvis_298653025]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706759</id><bm_lib_func_id>392706757</bm_lib_func_id><param_name><![CDATA[eventKey]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1371905636000</date_modified><order_no>2</order_no><guid><![CDATA[testsavvis_298653026]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706760</id><bm_lib_func_id>392706757</bm_lib_func_id><param_name><![CDATA[extraInfoNameArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1371905636000</date_modified><order_no>3</order_no><guid><![CDATA[testsavvis_298653027]]></guid></bm_lib_func_param><bm_lib_func_param><id>392706761</id><bm_lib_func_id>392706757</bm_lib_func_id><param_name><![CDATA[extraInfoValueArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1371905636000</date_modified><order_no>4</order_no><guid><![CDATA[testsavvis_298653028]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4940124</id><name><en><![CDATA[Get Config Tech Description]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getConfigTechDescription]]></variable_name><description><en><![CDATA[returns encoded tech description string of attributes in format of "attribute=value^-^attribute=value". input: attribute names (string array), attribute values (string array).]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>4940123</function_id><main_script_text></main_script_text><date_modified>1358564310000</date_modified><guid><![CDATA[LEGACY_4940124]]></guid><_children><bm_function><id>4940123</id><ref_type>16</ref_type><script_text><![CDATA[//**************************************************************************************************************
//** Function:    Get Config Tech Description (getConfigTechDescription)                                      **
//** Type:        Utility Library Function                                                                    **
//**                                                                                                          **
//** Description: returns encoded tech description string of attributes in format of                          **
//**              "attribute=value^-^attribute=value".                                                        **
//**              input: attribute names (string array), attribute values (string array).                     **
//**                                                                                                          **
//** History:     Date     Author       Comment                                                               **
//**              01/01/11 Big Machines Initial Implementation by Big Machines                                **
//**              07/25/12 KNewyear     VER 63966 - Change the "=" delimiter to "^=^"                         **
//**************************************************************************************************************

encStr = "";

index = range(sizeofarray(attributes));
for i in index {
	// VER 63966 - Change the first delimiter to "^=^"
	//encStr = encStr + attributes[i] + "=" + values[i] + "^-^";
	encStr = encStr + attributes[i] + "^=^" + values[i] + "^-^";
}
	
return substring(encStr,0,-3);]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getConfigTechDescription_4940123]]></java_class_name><child_class_names></child_class_names><date_modified>1358564310000</date_modified><guid><![CDATA[LEGACY_4940123]]></guid><_children></_children></bm_function><bm_lib_func_param><id>4940126</id><bm_lib_func_id>4940124</bm_lib_func_id><param_name><![CDATA[attributes]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564310000</date_modified><order_no>1</order_no><guid><![CDATA[LEGACY_4940126]]></guid></bm_lib_func_param><bm_lib_func_param><id>4940127</id><bm_lib_func_id>4940124</bm_lib_func_id><param_name><![CDATA[values]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1358564310000</date_modified><order_no>2</order_no><guid><![CDATA[LEGACY_4940127]]></guid></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>118969718</id><name><en><![CDATA[Get System User Login Names]]></en><fr_CA><![CDATA[]]></fr_CA></name><variable_name><![CDATA[getSystemUserLoginNames]]></variable_name><description><en><![CDATA[Returns a string containing the logins used by back end system processes, separated by ~ characters (I.e. bssuser~user2~user3 )]]></en><fr_CA><![CDATA[]]></fr_CA></description><return_type>1</return_type><func_type>1</func_type><folder_name><![CDATA[util]]></folder_name><function_id>118969717</function_id><main_script_text></main_script_text><date_modified>1358564314000</date_modified><guid><![CDATA[testsavvis_118969718]]></guid><_children><bm_function><id>118969717</id><ref_type>16</ref_type><script_text><![CDATA[/*************************************************************************************************************
-- Function:    Get System User Login Names (getSystemUserLoginNames)
-- Type:        utility function
--
-- History:    This Function was created to provide a single place to consolodate all of the user logins 
--             that will have special handling during the locking processes.
-- 
--  Date         Author     Comment  
--  05/11/12     MBelin     VER 62483 - Quote Locking Functionality
--  06/06/12     MBelin     VER 63306 - Changing Backend User to be bssadmin
*************************************************************************************************************/

// Currently there is only one user login that is used for backend processing ... 

// return "bssuser";
return "bssadmin";]]></script_text><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getSystemUserLoginNames_118969717]]></java_class_name><child_class_names></child_class_names><date_modified>1358564314000</date_modified><guid><![CDATA[testsavvis_118969717]]></guid><_children></_children></bm_function></_children></bm_lib_func></_children></bm_lib_func_zip_deploy>